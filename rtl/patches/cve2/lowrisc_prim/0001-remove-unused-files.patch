From 32df3d3c21d4b96aec4fff64ae11fb539be445dd Mon Sep 17 00:00:00 2001
From: Philippe Sauter <phsauter@iis.ee.ethz.ch>
Date: Tue, 19 Nov 2024 16:15:45 +0100
Subject: [PATCH] remove unused files

---
 prim_alert_pkg.sv                    |   27 -
 prim_alert_receiver.sv               |  386 ------
 prim_alert_sender.sv                 |  384 ------
 prim_arbiter_fixed.sv                |  170 ---
 prim_arbiter_ppc.sv                  |  225 ----
 prim_arbiter_tree.sv                 |  291 -----
 prim_cdc_rand_delay.sv               |  204 ---
 prim_cipher_pkg.sv                   |  397 ------
 prim_clock_div.sv                    |  120 --
 prim_clock_gating_sync.sv            |   34 -
 prim_clock_meas.sv                   |  209 ---
 prim_clock_timeout.sv                |   65 -
 prim_count.sv                        |  212 ---
 prim_count_pkg.sv                    |   22 -
 prim_crc32.sv                        |  324 -----
 prim_diff_decode.sv                  |  283 ----
 prim_dom_and_2share.sv               |  120 --
 prim_double_lfsr.sv                  |   99 --
 prim_edge_detector.sv                |   55 -
 prim_edn_req.sv                      |  145 ---
 prim_esc_pkg.sv                      |   23 -
 prim_esc_receiver.sv                 |  277 ----
 prim_esc_sender.sv                   |  272 ----
 prim_fifo_async.sv                   |  286 -----
 prim_fifo_async_sram_adapter.sv      |  439 -------
 prim_fifo_sync.sv                    |  178 ---
 prim_filter.sv                       |   73 --
 prim_filter_ctr.sv                   |   82 --
 prim_flop_2sync.sv                   |   43 -
 prim_gate_gen.sv                     |  109 --
 prim_gf_mult.sv                      |  171 ---
 prim_intr_hw.sv                      |   58 -
 prim_keccak.sv                       |  295 -----
 prim_lc_combine.sv                   |   73 --
 prim_lc_dec.sv                       |   28 -
 prim_lc_sender.sv                    |   68 -
 prim_lc_sync.sv                      |  107 --
 prim_lfsr.sv                         |  669 ----------
 prim_max_tree.sv                     |  147 ---
 prim_msb_extend.sv                   |   27 -
 prim_mubi12_dec.sv                   |   48 -
 prim_mubi12_sender.sv                |   94 --
 prim_mubi12_sync.sv                  |  165 ---
 prim_mubi16_dec.sv                   |   48 -
 prim_mubi16_sender.sv                |   94 --
 prim_mubi16_sync.sv                  |  165 ---
 prim_mubi4_dec.sv                    |   48 -
 prim_mubi4_sender.sv                 |   94 --
 prim_mubi4_sync.sv                   |  165 ---
 prim_mubi8_dec.sv                    |   48 -
 prim_mubi8_sender.sv                 |   94 --
 prim_mubi8_sync.sv                   |  165 ---
 prim_mubi_pkg.sv                     |  531 --------
 prim_multibit_sync.sv                |  103 --
 prim_otp_pkg.sv                      |   26 -
 prim_packer.sv                       |  297 -----
 prim_packer_fifo.sv                  |  180 ---
 prim_pad_wrapper_pkg.sv              |   46 -
 prim_present.sv                      |  158 ---
 prim_prince.sv                       |  248 ----
 prim_pulse_sync.sv                   |   66 -
 prim_ram_1p_adv.sv                   |  269 ----
 prim_ram_1p_pkg.sv                   |   20 -
 prim_ram_1p_scr.sv                   |  425 ------
 prim_ram_2p_adv.sv                   |   95 --
 prim_ram_2p_async_adv.sv             |  358 ------
 prim_ram_2p_pkg.sv                   |   22 -
 prim_reg_cdc.sv                      |  156 ---
 prim_rom_adv.sv                      |   53 -
 prim_rom_pkg.sv                      |   15 -
 prim_sec_anchor_buf.sv               |   21 -
 prim_sec_anchor_flop.sv              |   27 -
 prim_secded_22_16_dec.sv             |   45 -
 prim_secded_22_16_enc.sv             |   22 -
 prim_secded_28_22_dec.sv             |   51 -
 prim_secded_28_22_enc.sv             |   22 -
 prim_secded_39_32_dec.sv             |   62 -
 prim_secded_39_32_enc.sv             |   23 -
 prim_secded_64_57_dec.sv             |   87 --
 prim_secded_64_57_enc.sv             |   23 -
 prim_secded_72_64_dec.sv             |   95 --
 prim_secded_72_64_enc.sv             |   24 -
 prim_secded_hamming_22_16_dec.sv     |   45 -
 prim_secded_hamming_22_16_enc.sv     |   22 -
 prim_secded_hamming_39_32_dec.sv     |   62 -
 prim_secded_hamming_39_32_enc.sv     |   23 -
 prim_secded_hamming_72_64_dec.sv     |   95 --
 prim_secded_hamming_72_64_enc.sv     |   24 -
 prim_secded_hamming_76_68_dec.sv     |   99 --
 prim_secded_hamming_76_68_enc.sv     |   24 -
 prim_secded_inv_22_16_dec.sv         |   45 -
 prim_secded_inv_22_16_enc.sv         |   22 -
 prim_secded_inv_28_22_dec.sv         |   51 -
 prim_secded_inv_28_22_enc.sv         |   22 -
 prim_secded_inv_39_32_dec.sv         |   62 -
 prim_secded_inv_39_32_enc.sv         |   23 -
 prim_secded_inv_64_57_dec.sv         |   87 --
 prim_secded_inv_64_57_enc.sv         |   23 -
 prim_secded_inv_72_64_dec.sv         |   95 --
 prim_secded_inv_72_64_enc.sv         |   24 -
 prim_secded_inv_hamming_22_16_dec.sv |   45 -
 prim_secded_inv_hamming_22_16_enc.sv |   22 -
 prim_secded_inv_hamming_39_32_dec.sv |   62 -
 prim_secded_inv_hamming_39_32_enc.sv |   23 -
 prim_secded_inv_hamming_72_64_dec.sv |   95 --
 prim_secded_inv_hamming_72_64_enc.sv |   24 -
 prim_secded_inv_hamming_76_68_dec.sv |   99 --
 prim_secded_inv_hamming_76_68_enc.sv |   24 -
 prim_secded_pkg.sv                   | 1778 --------------------------
 prim_slicer.sv                       |   32 -
 prim_sparse_fsm_flop.sv              |   56 -
 prim_sram_arbiter.sv                 |  153 ---
 prim_subreg.sv                       |   82 --
 prim_subreg_arb.sv                   |   81 --
 prim_subreg_async.sv                 |   85 --
 prim_subreg_cdc.sv                   |  135 --
 prim_subreg_ext.sv                   |   28 -
 prim_subreg_ext_async.sv             |   68 -
 prim_subreg_pkg.sv                   |   17 -
 prim_subreg_shadow.sv                |  186 ---
 prim_subst_perm.sv                   |   92 --
 prim_sum_tree.sv                     |  119 --
 prim_sync_reqack.sv                  |  180 ---
 prim_sync_reqack_data.sv             |  130 --
 prim_sync_slow_fast.sv               |   59 -
 prim_util_get_scramble_params.svh    |   36 -
 prim_util_memload.svh                |   82 --
 prim_util_pkg.sv                     |   89 --
 prim_xoshiro256pp.sv                 |   87 --
 129 files changed, 16812 deletions(-)
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_alert_pkg.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_alert_receiver.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_alert_sender.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_arbiter_fixed.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_arbiter_ppc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_arbiter_tree.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_cdc_rand_delay.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_cipher_pkg.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_clock_div.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_clock_gating_sync.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_clock_meas.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_clock_timeout.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_count.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_count_pkg.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_crc32.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_diff_decode.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_dom_and_2share.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_double_lfsr.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_edge_detector.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_edn_req.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_esc_pkg.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_esc_receiver.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_esc_sender.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_fifo_async.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_fifo_async_sram_adapter.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_fifo_sync.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_filter.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_filter_ctr.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_flop_2sync.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_gate_gen.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_gf_mult.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_intr_hw.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_keccak.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_lc_combine.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_lc_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_lc_sender.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_lc_sync.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_lfsr.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_max_tree.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_msb_extend.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_mubi12_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_mubi12_sender.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_mubi12_sync.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_mubi16_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_mubi16_sender.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_mubi16_sync.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_mubi4_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_mubi4_sender.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_mubi4_sync.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_mubi8_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_mubi8_sender.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_mubi8_sync.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_mubi_pkg.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_multibit_sync.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_otp_pkg.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_packer.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_packer_fifo.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_pad_wrapper_pkg.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_present.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_prince.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_pulse_sync.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_ram_1p_adv.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_ram_1p_pkg.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_ram_1p_scr.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_ram_2p_adv.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_ram_2p_async_adv.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_ram_2p_pkg.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_reg_cdc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_rom_adv.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_rom_pkg.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_sec_anchor_buf.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_sec_anchor_flop.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_22_16_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_22_16_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_28_22_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_28_22_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_39_32_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_39_32_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_64_57_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_64_57_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_72_64_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_72_64_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_hamming_22_16_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_hamming_22_16_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_hamming_39_32_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_hamming_39_32_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_hamming_72_64_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_hamming_72_64_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_hamming_76_68_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_hamming_76_68_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_22_16_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_22_16_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_28_22_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_28_22_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_39_32_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_39_32_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_64_57_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_64_57_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_72_64_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_72_64_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_hamming_22_16_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_hamming_22_16_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_hamming_39_32_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_hamming_39_32_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_hamming_72_64_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_hamming_72_64_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_hamming_76_68_dec.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_inv_hamming_76_68_enc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_secded_pkg.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_slicer.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_sparse_fsm_flop.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_sram_arbiter.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_subreg.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_subreg_arb.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_subreg_async.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_subreg_cdc.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_subreg_ext.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_subreg_ext_async.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_subreg_pkg.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_subreg_shadow.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_subst_perm.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_sum_tree.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_sync_reqack.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_sync_reqack_data.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_sync_slow_fast.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_util_get_scramble_params.svh
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_util_memload.svh
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_util_pkg.sv
 delete mode 100644 vendor/lowrisc_ip/ip/prim/rtl/prim_xoshiro256pp.sv

diff --git a/prim_alert_pkg.sv b/prim_alert_pkg.sv
deleted file mode 100644
index a3594b61..00000000
--- a/prim_alert_pkg.sv
+++ /dev/null
@@ -1,27 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-
-package prim_alert_pkg;
-
-  typedef struct packed {
-    logic alert_p;
-    logic alert_n;
-  } alert_tx_t;
-
-  typedef struct packed {
-    logic ping_p;
-    logic ping_n;
-    logic ack_p;
-    logic ack_n;
-  } alert_rx_t;
-
-  parameter alert_tx_t ALERT_TX_DEFAULT = '{alert_p:  1'b0,
-                                            alert_n:  1'b1};
-
-  parameter alert_rx_t ALERT_RX_DEFAULT = '{ping_p: 1'b0,
-                                            ping_n: 1'b1,
-                                            ack_p: 1'b0,
-                                            ack_n: 1'b1};
-
-endpackage : prim_alert_pkg
diff --git a/prim_alert_receiver.sv b/prim_alert_receiver.sv
deleted file mode 100644
index 347d424c..00000000
--- a/prim_alert_receiver.sv
+++ /dev/null
@@ -1,386 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// The alert receiver primitive decodes alerts that have been differentially
-// encoded and transmitted via a handshake protocol on alert_p/n and
-// ack_p/n. In case an alert handshake is initiated, the output alert_o will
-// immediately be asserted (even before completion of the handshake).
-//
-// In case the differential input is not correctly encoded, this module will
-// raise an error by asserting integ_fail_o.
-//
-// Further, the module supports ping testing of the alert diff pair. In order to
-// initiate a ping test, ping_req_i shall be set to 1'b1 until ping_ok_o is
-// asserted for one cycle. The signal may be de-asserted (e.g. after a long)
-// timeout period. However note that all ping responses that come in after
-// deasserting ping_req_i will be treated as native alerts.
-//
-// The protocol works in both asynchronous and synchronous cases. In the
-// asynchronous case, the parameter AsyncOn must be set to 1'b1 in order to
-// instantiate additional synchronization logic. Further, it must be ensured
-// that the timing skew between all diff pairs is smaller than the shortest
-// clock period of the involved clocks.
-//
-// Note that in case of synchronous operation, alerts on the diffpair are
-// decoded combinationally and forwarded on alert_o within the same cycle.
-//
-// See also: prim_alert_sender, prim_diff_decode, alert_handler
-
-`include "prim_assert.sv"
-
-module prim_alert_receiver
-  import prim_alert_pkg::*;
-  import prim_mubi_pkg::mubi4_t;
-#(
-  // enables additional synchronization logic
-  parameter bit AsyncOn = 1'b0
-) (
-  input             clk_i,
-  input             rst_ni,
-  // if set to lc_ctrl_pkg::On, this triggers the in-band alert channel
-  // reset, which resets both the sender and receiver FSMs into IDLE.
-  input mubi4_t     init_trig_i,
-  // this triggers a ping test. keep asserted
-  // until ping_ok_o is asserted.
-  input             ping_req_i,
-  output logic      ping_ok_o,
-  // asserted if signal integrity issue detected
-  output logic      integ_fail_o,
-  // alert output (pulsed high) if a handshake is initiated
-  // on alert_p/n and no ping request is outstanding
-  output logic      alert_o,
-  // ping input diff pair and ack diff pair
-  output alert_rx_t alert_rx_o,
-  // alert output diff pair
-  input alert_tx_t  alert_tx_i
-);
-
-  import prim_mubi_pkg::mubi4_test_true_strict;
-
-  /////////////////////////////////
-  // decode differential signals //
-  /////////////////////////////////
-  logic alert_level, alert_sigint, alert_p, alert_n;
-
-  // This prevents further tool optimizations of the differential signal.
-  prim_sec_anchor_buf #(
-    .Width(2)
-  ) u_prim_buf_in (
-    .in_i({alert_tx_i.alert_n,
-           alert_tx_i.alert_p}),
-    .out_o({alert_n,
-            alert_p})
-  );
-
-  prim_diff_decode #(
-    .AsyncOn(AsyncOn)
-  ) u_decode_alert (
-    .clk_i,
-    .rst_ni,
-    .diff_pi  ( alert_p            ),
-    .diff_ni  ( alert_n            ),
-    .level_o  ( alert_level        ),
-    .rise_o   (                    ),
-    .fall_o   (                    ),
-    .event_o  (                    ),
-    .sigint_o ( alert_sigint       )
-  );
-
-  /////////////////////////////////////////////////////
-  //  main protocol FSM that drives the diff outputs //
-  /////////////////////////////////////////////////////
-  typedef enum logic [2:0] {Idle, HsAckWait, Pause0, Pause1, InitReq, InitAckWait} state_e;
-  state_e state_d, state_q;
-  logic ping_rise;
-  logic ping_tog_pd, ping_tog_pq, ping_tog_dn, ping_tog_nq;
-  logic ack_pd, ack_pq, ack_dn, ack_nq;
-  logic ping_req_d, ping_req_q;
-  logic ping_pending_d, ping_pending_q;
-  logic send_init;
-  logic send_ping;
-
-  // signal ping request upon positive transition on ping_req_i
-  // signalling is performed by a level change event on the diff output
-  assign ping_req_d  = ping_req_i;
-  assign ping_rise   = ping_req_d && !ping_req_q;
-  assign ping_tog_pd = (send_init) ? 1'b0         :
-                       (send_ping) ? ~ping_tog_pq : ping_tog_pq;
-
-  // in-band reset is performed by sending out an integrity error on purpose.
-  assign ack_dn      = (send_init) ? ack_pd : ~ack_pd;
-  assign ping_tog_dn = ~ping_tog_pd;
-
-  // This prevents further tool optimizations of the differential signal.
-  prim_sec_anchor_flop #(
-    .Width     (2),
-    .ResetValue(2'b10)
-  ) u_prim_generic_flop_ack (
-    .clk_i,
-    .rst_ni,
-    .d_i({ack_dn,
-          ack_pd}),
-    .q_o({ack_nq,
-          ack_pq})
-  );
-
-  prim_sec_anchor_flop #(
-    .Width     (2),
-    .ResetValue(2'b10)
-  ) u_prim_generic_flop_ping (
-    .clk_i,
-    .rst_ni,
-    .d_i({ping_tog_dn,
-          ping_tog_pd}),
-    .q_o({ping_tog_nq,
-          ping_tog_pq})
-  );
-
-  // the ping pending signal is used in the FSM to distinguish whether the
-  // incoming handshake shall be treated as an alert or a ping response.
-  // it is important that this is only set on a rising ping_en level change, since
-  // otherwise the ping enable signal could be abused to "mask" all native alerts
-  // as ping responses by constantly tying it to 1.
-  assign ping_pending_d = ping_rise | ((~ping_ok_o) & ping_req_i & ping_pending_q);
-
-  // diff pair outputs
-  assign alert_rx_o.ack_p = ack_pq;
-  assign alert_rx_o.ack_n = ack_nq;
-
-  assign alert_rx_o.ping_p = ping_tog_pq;
-  assign alert_rx_o.ping_n = ping_tog_nq;
-
-  // this FSM receives the four phase handshakes from the alert receiver
-  // note that the latency of the alert_p/n input diff pair is at least one
-  // cycle until it enters the receiver FSM. the same holds for the ack_* diff
-  // pair outputs.
-  always_comb begin : p_fsm
-    // default
-    state_d      = state_q;
-    ack_pd       = 1'b0;
-    ping_ok_o    = 1'b0;
-    integ_fail_o = 1'b0;
-    alert_o      = 1'b0;
-    send_init    = 1'b0;
-    // by default, a ping request leads to a toogle on the differential ping pair
-    send_ping    = ping_rise;
-
-    unique case (state_q)
-      Idle: begin
-        // wait for handshake to be initiated
-        if (alert_level) begin
-          state_d = HsAckWait;
-          ack_pd  = 1'b1;
-          // signal either an alert or ping received on the output
-          if (ping_pending_q) begin
-            ping_ok_o = 1'b1;
-          end else begin
-            alert_o   = 1'b1;
-          end
-        end
-      end
-      // waiting for deassertion of alert to complete HS
-      HsAckWait: begin
-        if (!alert_level) begin
-          state_d  = Pause0;
-        end else begin
-          ack_pd = 1'b1;
-        end
-      end
-      // pause cycles between back-to-back handshakes
-      Pause0: state_d = Pause1;
-      Pause1: state_d = Idle;
-      // this state is only reached if an in-band reset is
-      // requested via the low-power logic.
-      InitReq: begin
-        // we deliberately place a sigint error on the ack and ping lines in this case.
-        send_init = 1'b1;
-        // suppress any toggles on the ping line while we are in the init phase.
-        send_ping = 1'b0;
-        // As long as init req is asserted, we remain in this state and acknowledge all incoming
-        // ping requests. As soon as the init request is dropped however, ping requests are not
-        // acked anymore such that the ping mechanism can also flag alert channels that got stuck
-        // in the initialization sequence.
-        if (mubi4_test_true_strict(init_trig_i)) begin
-          ping_ok_o = ping_pending_q;
-        // the sender will respond to the sigint error above with a sigint error on the alert lines.
-        // hence we treat the alert_sigint like an acknowledgement in this case.
-        end else if (alert_sigint) begin
-          state_d = InitAckWait;
-        end
-      end
-      // We get here if the sender has responded with alert_sigint, and init_trig_i==lc_ctrl_pkg::On
-      // has been deasserted. At this point, we need to wait for the alert_sigint to drop again
-      // before resuming normal operation.
-      InitAckWait: begin
-        // suppress any toggles on the ping line while we are in the init phase.
-        send_ping = 1'b0;
-        if (!alert_sigint) begin
-          state_d = Pause0;
-          // If we get a ping request in this cycle, or if we realize that there is an unhandled
-          // ping request that came in during initialization (but after init_trig_i has been
-          // deasserted), we signal this to the alert sender by toggling the request line.
-          send_ping = ping_rise || ping_pending_q;
-        end
-      end
-      default: state_d = Idle;
-    endcase
-
-    // once the initialization sequence has been triggered,
-    // overrides are not allowed anymore until the initialization has been completed.
-    if (!(state_q inside {InitReq, InitAckWait})) begin
-      // in this case, abort and jump into the initialization sequence
-      if (mubi4_test_true_strict(init_trig_i)) begin
-        state_d      = InitReq;
-        ack_pd       = 1'b0;
-        ping_ok_o    = 1'b0;
-        integ_fail_o = 1'b0;
-        alert_o      = 1'b0;
-        send_init    = 1'b1;
-      // if we're not busy with an init request, we clamp down all outputs
-      // and indicate an integrity failure.
-      end else if (alert_sigint) begin
-        state_d      = Idle;
-        ack_pd       = 1'b0;
-        ping_ok_o    = 1'b0;
-        integ_fail_o = 1'b1;
-        alert_o      = 1'b0;
-      end
-    end
-  end
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin : p_reg
-    if (!rst_ni) begin
-      // Reset into the init request so that an alert handler reset implicitly
-      // triggers an in-band reset of all alert channels.
-      state_q        <= InitReq;
-      ping_req_q     <= 1'b0;
-      ping_pending_q <= 1'b0;
-    end else begin
-      state_q        <= state_d;
-      ping_req_q     <= ping_req_d;
-      ping_pending_q <= ping_pending_d;
-    end
-  end
-
-
-  ////////////////
-  // assertions //
-  ////////////////
-
-`ifdef INC_ASSERT
-  import prim_mubi_pkg::mubi4_test_false_loose;
-`endif
-
-  // check whether all outputs have a good known state after reset
-  `ASSERT_KNOWN(PingOkKnownO_A, ping_ok_o)
-  `ASSERT_KNOWN(IntegFailKnownO_A, integ_fail_o)
-  `ASSERT_KNOWN(AlertKnownO_A, alert_o)
-  `ASSERT_KNOWN(PingPKnownO_A, alert_rx_o)
-
-  // check encoding of outgoing diffpairs. note that during init, the outgoing diffpairs are
-  // supposed to be incorrectly encoded on purpose.
-  // shift sequence two cycles to the right to avoid reset effects.
-  `ASSERT(PingDiffOk_A, alert_rx_o.ping_p ^ alert_rx_o.ping_n)
-  `ASSERT(AckDiffOk_A, ##2 $past(send_init) ^ alert_rx_o.ack_p ^ alert_rx_o.ack_n)
-  `ASSERT(InitReq_A, mubi4_test_true_strict(init_trig_i) &&
-          !(state_q inside {InitReq, InitAckWait}) |=> send_init)
-
-  // ping request at input -> need to see encoded ping request
-  `ASSERT(PingRequest0_A, ##1 $rose(ping_req_i) && !state_q inside {InitReq, InitAckWait}
-      |=> $changed(alert_rx_o.ping_p))
-  // ping response implies it has been requested
-  `ASSERT(PingResponse0_A, ping_ok_o |-> ping_pending_q)
-  // correctly latch ping request
-  `ASSERT(PingPending_A, ##1 $rose(ping_req_i) |=> ping_pending_q)
-
-  if (AsyncOn) begin : gen_async_assert
-    // signal integrity check propagation
-    `ASSERT(SigInt_A,
-        alert_tx_i.alert_p == alert_tx_i.alert_n [*2] ##2
-        !(state_q inside {InitReq, InitAckWait}) &&
-        mubi4_test_false_loose(init_trig_i)
-        |->
-        integ_fail_o)
-    // TODO: need to add skewed cases as well, the assertions below assume no skew at the moment
-    // ping response
-    `ASSERT(PingResponse1_A,
-        ##1 $rose(alert_tx_i.alert_p) &&
-        (alert_tx_i.alert_p ^ alert_tx_i.alert_n) ##2
-        state_q == Idle && ping_pending_q
-        |->
-        ping_ok_o,
-        clk_i, !rst_ni || integ_fail_o || mubi4_test_true_strict(init_trig_i))
-    // alert
-    `ASSERT(Alert_A,
-        ##1 $rose(alert_tx_i.alert_p) &&
-        (alert_tx_i.alert_p ^ alert_tx_i.alert_n) ##2
-        state_q == Idle &&
-        !ping_pending_q
-        |->
-        alert_o,
-        clk_i, !rst_ni || integ_fail_o || mubi4_test_true_strict(init_trig_i))
-  end else begin : gen_sync_assert
-    // signal integrity check propagation
-    `ASSERT(SigInt_A,
-        alert_tx_i.alert_p == alert_tx_i.alert_n &&
-        !(state_q inside {InitReq, InitAckWait}) &&
-        mubi4_test_false_loose(init_trig_i)
-        |->
-        integ_fail_o)
-    // ping response
-    `ASSERT(PingResponse1_A,
-        ##1 $rose(alert_tx_i.alert_p) &&
-        state_q == Idle &&
-        ping_pending_q
-        |->
-        ping_ok_o,
-        clk_i, !rst_ni || integ_fail_o || mubi4_test_true_strict(init_trig_i))
-    // alert
-    `ASSERT(Alert_A,
-        ##1 $rose(alert_tx_i.alert_p) &&
-        state_q == Idle &&
-        !ping_pending_q
-        |->
-        alert_o,
-        clk_i, !rst_ni || integ_fail_o || mubi4_test_true_strict(init_trig_i))
-  end
-
-  // check in-band init request is always accepted
-  `ASSERT(InBandInitRequest_A,
-      mubi4_test_true_strict(init_trig_i) &&
-      state_q != InitAckWait
-      |=>
-      state_q == InitReq)
-  // check in-band init sequence moves FSM into IDLE state
-  `ASSERT(InBandInitSequence_A,
-      (state_q == InitReq &&
-      mubi4_test_true_strict(init_trig_i)) ##1
-      (alert_sigint &&
-      mubi4_test_false_loose(init_trig_i)) [*1:$] ##1
-      (!alert_sigint &&
-      mubi4_test_false_loose(init_trig_i)) [*3]
-      |=>
-      state_q == Idle)
-  // check there are no spurious alerts during init
-  `ASSERT(NoSpuriousAlertsDuringInit_A,
-      mubi4_test_true_strict(init_trig_i) ||
-      (state_q inside {InitReq, InitAckWait})
-      |->
-      !alert_o)
-  // check that there are no spurious ping OKs
-  `ASSERT(NoSpuriousPingOksDuringInit_A,
-      (mubi4_test_true_strict(init_trig_i) ||
-      (state_q inside {InitReq, InitAckWait})) &&
-      !ping_pending_q
-      |->
-      !ping_ok_o)
-  // check ping request is bypassed when in init state
-  `ASSERT(PingOkBypassDuringInit_A,
-      $rose(ping_req_i) ##1
-      state_q == InitReq &&
-      mubi4_test_true_strict(init_trig_i)
-      |->
-      ping_ok_o)
-
-endmodule : prim_alert_receiver
diff --git a/prim_alert_sender.sv b/prim_alert_sender.sv
deleted file mode 100644
index e3063848..00000000
--- a/prim_alert_sender.sv
+++ /dev/null
@@ -1,384 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// The alert sender primitive module differentially encodes and transmits an
-// alert signal to the prim_alert_receiver module. An alert will be signalled
-// by a full handshake on alert_p/n and ack_p/n. The alert_req_i signal may
-// be continuously asserted, in which case the alert signalling handshake
-// will be repeatedly initiated.
-//
-// The alert_req_i signal may also be used as part of req/ack. The parent module
-// can keep alert_req_i asserted until it has been ack'd (transferred to the alert
-// receiver).  The parent module is not required to use this.
-//
-// In case the alert sender parameter IsFatal is set to 1, an incoming alert
-// alert_req_i is latched in a local register until the next reset, causing the
-// alert sender to behave as if alert_req_i were continously asserted.
-// The alert_state_o output reflects the state of this internal latching register.
-//
-// The alert sender also exposes an alert test input, which can be used to trigger
-// single alert handshakes. This input behaves exactly the same way as the
-// alert_req_i input with IsFatal set to 0. Test alerts do not cause alert_ack_o
-// to be asserted, nor are they latched until reset (regardless of the value of the
-// IsFatal parameter).
-//
-// Further, this module supports in-band ping testing, which means that a level
-// change on the ping_p/n diff pair will result in a full-handshake response
-// on alert_p/n and ack_p/n.
-//
-// The protocol works in both asynchronous and synchronous cases. In the
-// asynchronous case, the parameter AsyncOn must be set to 1'b1 in order to
-// instantiate additional synchronization logic. Further, it must be ensured
-// that the timing skew between all diff pairs is smaller than the shortest
-// clock period of the involved clocks.
-//
-// Incorrectly encoded diff inputs can be detected and will be signalled
-// to the receiver by placing an inconsistent diff value on the differential
-// output (and continuously toggling it).
-//
-// See also: prim_alert_receiver, prim_diff_decode, alert_handler
-
-`include "prim_assert.sv"
-
-module prim_alert_sender
-  import prim_alert_pkg::*;
-#(
-  // enables additional synchronization logic
-  parameter bit AsyncOn = 1'b1,
-  // alert sender will latch the incoming alert event permanently and
-  // keep on sending alert events until the next reset.
-  parameter bit IsFatal = 1'b0
-) (
-  input             clk_i,
-  input             rst_ni,
-  // alert test trigger (this will never be latched, even if IsFatal == 1)
-  input             alert_test_i,
-  // native alert from the peripheral
-  input             alert_req_i,
-  output logic      alert_ack_o,
-  // state of the alert latching register
-  output logic      alert_state_o,
-  // ping input diff pair and ack diff pair
-  input alert_rx_t  alert_rx_i,
-  // alert output diff pair
-  output alert_tx_t alert_tx_o
-);
-
-
-  /////////////////////////////////
-  // decode differential signals //
-  /////////////////////////////////
-  logic ping_sigint, ping_event, ping_n, ping_p;
-
-  // This prevents further tool optimizations of the differential signal.
-  prim_sec_anchor_buf #(
-    .Width(2)
-  ) u_prim_buf_ping (
-    .in_i({alert_rx_i.ping_n,
-           alert_rx_i.ping_p}),
-    .out_o({ping_n,
-            ping_p})
-  );
-
-  prim_diff_decode #(
-    .AsyncOn(AsyncOn)
-  ) u_decode_ping (
-    .clk_i,
-    .rst_ni,
-    .diff_pi  ( ping_p      ),
-    .diff_ni  ( ping_n      ),
-    .level_o  (             ),
-    .rise_o   (             ),
-    .fall_o   (             ),
-    .event_o  ( ping_event  ),
-    .sigint_o ( ping_sigint )
-  );
-
-  logic ack_sigint, ack_level, ack_n, ack_p;
-
-  // This prevents further tool optimizations of the differential signal.
-  prim_sec_anchor_buf #(
-    .Width(2)
-  ) u_prim_buf_ack (
-    .in_i({alert_rx_i.ack_n,
-           alert_rx_i.ack_p}),
-    .out_o({ack_n,
-            ack_p})
-  );
-
-  prim_diff_decode #(
-    .AsyncOn(AsyncOn)
-  ) u_decode_ack (
-    .clk_i,
-    .rst_ni,
-    .diff_pi  ( ack_p      ),
-    .diff_ni  ( ack_n      ),
-    .level_o  ( ack_level  ),
-    .rise_o   (            ),
-    .fall_o   (            ),
-    .event_o  (            ),
-    .sigint_o ( ack_sigint )
-  );
-
-
-  ///////////////////////////////////////////////////
-  // main protocol FSM that drives the diff output //
-  ///////////////////////////////////////////////////
-  typedef enum logic [2:0] {
-    Idle,
-    AlertHsPhase1,
-    AlertHsPhase2,
-    PingHsPhase1,
-    PingHsPhase2,
-    Pause0,
-    Pause1
-    } state_e;
-  state_e state_d, state_q;
-  logic alert_pq, alert_nq, alert_pd, alert_nd;
-  logic sigint_detected;
-
-  assign sigint_detected = ack_sigint | ping_sigint;
-
-
-  // diff pair output
-  assign alert_tx_o.alert_p = alert_pq;
-  assign alert_tx_o.alert_n = alert_nq;
-
-  // alert and ping set regs
-  logic alert_set_d, alert_set_q, alert_clr;
-  logic alert_test_set_d, alert_test_set_q;
-  logic ping_set_d, ping_set_q, ping_clr;
-  logic alert_req_trigger, alert_test_trigger, ping_trigger;
-
-  // if handshake is ongoing, capture additional alert requests.
-  logic alert_req;
-  prim_sec_anchor_buf #(
-    .Width(1)
-  ) u_prim_buf_in_req (
-    .in_i(alert_req_i),
-    .out_o(alert_req)
-  );
-
-  assign alert_req_trigger = alert_req | alert_set_q;
-  if (IsFatal) begin : gen_fatal
-    assign alert_set_d = alert_req_trigger;
-  end else begin : gen_recov
-    assign alert_set_d = (alert_clr) ? 1'b0 : alert_req_trigger;
-  end
-
-  // the alert test request is always cleared.
-  assign alert_test_trigger = alert_test_i | alert_test_set_q;
-  assign alert_test_set_d = (alert_clr) ? 1'b0 : alert_test_trigger;
-
-  logic alert_trigger;
-  assign alert_trigger = alert_req_trigger | alert_test_trigger;
-
-  assign ping_trigger = ping_set_q | ping_event;
-  assign ping_set_d  = (ping_clr) ? 1'b0 : ping_trigger;
-
-
-  // alert event acknowledge and state (not affected by alert_test_i)
-  assign alert_ack_o = alert_clr & alert_set_q;
-  assign alert_state_o = alert_set_q;
-
-  // this FSM performs a full four phase handshake upon a ping or alert trigger.
-  // note that the latency of the alert_p/n diff pair is at least one cycle
-  // until it enters the receiver FSM. the same holds for the ack_* diff pair
-  // input. in case a signal integrity issue is detected, the FSM bails out,
-  // sets the alert_p/n diff pair to the same value and toggles it in order to
-  // signal that condition over to the receiver.
-  always_comb begin : p_fsm
-    // default
-    state_d   = state_q;
-    alert_pd  = 1'b0;
-    alert_nd  = 1'b1;
-    ping_clr  = 1'b0;
-    alert_clr = 1'b0;
-
-    unique case (state_q)
-      Idle: begin
-        // alert always takes precedence
-        if (alert_trigger || ping_trigger) begin
-          state_d = (alert_trigger) ? AlertHsPhase1 : PingHsPhase1;
-          alert_pd = 1'b1;
-          alert_nd = 1'b0;
-        end
-      end
-      // waiting for ack from receiver
-      AlertHsPhase1: begin
-        if (ack_level) begin
-          state_d  = AlertHsPhase2;
-        end else begin
-          alert_pd = 1'b1;
-          alert_nd = 1'b0;
-        end
-      end
-      // wait for deassertion of ack
-      AlertHsPhase2: begin
-        if (!ack_level) begin
-          state_d = Pause0;
-          alert_clr = 1'b1;
-        end
-      end
-      // waiting for ack from receiver
-      PingHsPhase1: begin
-        if (ack_level) begin
-          state_d  = PingHsPhase2;
-        end else begin
-          alert_pd = 1'b1;
-          alert_nd = 1'b0;
-        end
-      end
-      // wait for deassertion of ack
-      PingHsPhase2: begin
-        if (!ack_level) begin
-          ping_clr = 1'b1;
-          state_d = Pause0;
-        end
-      end
-      // pause cycles between back-to-back handshakes
-      Pause0: begin
-        state_d = Pause1;
-      end
-      // clear and ack alert request if it was set
-      Pause1: begin
-        state_d = Idle;
-      end
-      // catch parasitic states
-      default : state_d = Idle;
-    endcase
-
-    // we have a signal integrity issue at one of the incoming diff pairs. this condition is
-    // signalled by setting the output diffpair to zero. If the sigint has disappeared, we clear
-    // the ping request state of this sender and go back to idle.
-    if (sigint_detected) begin
-      state_d   = Idle;
-      alert_pd  = 1'b0;
-      alert_nd  = 1'b0;
-      ping_clr  = 1'b1;
-      alert_clr = 1'b0;
-    end
-  end
-
-  // This prevents further tool optimizations of the differential signal.
-  prim_sec_anchor_flop #(
-    .Width     (2),
-    .ResetValue(2'b10)
-  ) u_prim_flop_alert (
-    .clk_i,
-    .rst_ni,
-    .d_i({alert_nd, alert_pd}),
-    .q_o({alert_nq, alert_pq})
-  );
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin : p_reg
-    if (!rst_ni) begin
-      state_q          <= Idle;
-      alert_set_q      <= 1'b0;
-      alert_test_set_q <= 1'b0;
-      ping_set_q       <= 1'b0;
-    end else begin
-      state_q          <= state_d;
-      alert_set_q      <= alert_set_d;
-      alert_test_set_q <= alert_test_set_d;
-      ping_set_q       <= ping_set_d;
-    end
-  end
-
-
-  ////////////////
-  // assertions //
-  ////////////////
-
-// however, since we use sequence constructs below, we need to wrap the entire block again.
-// typically, the ASSERT macros already contain this INC_ASSERT macro.
-`ifdef INC_ASSERT
-  // check whether all outputs have a good known state after reset
-  `ASSERT_KNOWN(AlertPKnownO_A, alert_tx_o)
-
-  if (AsyncOn) begin : gen_async_assert
-    sequence PingSigInt_S;
-      alert_rx_i.ping_p == alert_rx_i.ping_n [*2];
-    endsequence
-    sequence AckSigInt_S;
-      alert_rx_i.ping_p == alert_rx_i.ping_n [*2];
-    endsequence
-    // check propagation of sigint issues to output within three cycles
-    // shift sequence to the right to avoid reset effects.
-    `ASSERT(SigIntPing_A, ##1 PingSigInt_S |->
-        ##3 alert_tx_o.alert_p == alert_tx_o.alert_n)
-    `ASSERT(SigIntAck_A, ##1 AckSigInt_S |->
-        ##3 alert_tx_o.alert_p == alert_tx_o.alert_n)
-    // Test in-band FSM reset request (via signal integrity error)
-    `ASSERT(InBandInitFsm_A, PingSigInt_S or AckSigInt_S |-> ##3 state_q == Idle)
-    `ASSERT(InBandInitPing_A, PingSigInt_S or AckSigInt_S |-> ##3 !ping_set_q)
-    // output must be driven diff unless sigint issue detected
-    `ASSERT(DiffEncoding_A, (alert_rx_i.ack_p ^ alert_rx_i.ack_n) &&
-        (alert_rx_i.ping_p ^ alert_rx_i.ping_n) |->
-        ##3 alert_tx_o.alert_p ^ alert_tx_o.alert_n)
-
-    // handshakes can take indefinite time if blocked due to sigint on outgoing
-    // lines (which is not visible here). thus, we only check whether the
-    // handshake is correctly initiated and defer the full handshake checking to the testbench.
-    // TODO: add the staggered cases as well
-    `ASSERT(PingHs_A, ##1 $changed(alert_rx_i.ping_p) &&
-        (alert_rx_i.ping_p ^ alert_rx_i.ping_n) ##2 state_q == Idle |=>
-        $rose(alert_tx_o.alert_p), clk_i, !rst_ni || (alert_tx_o.alert_p == alert_tx_o.alert_n))
-  end else begin : gen_sync_assert
-    sequence PingSigInt_S;
-      alert_rx_i.ping_p == alert_rx_i.ping_n;
-    endsequence
-    sequence AckSigInt_S;
-      alert_rx_i.ping_p == alert_rx_i.ping_n;
-    endsequence
-    // check propagation of sigint issues to output within one cycle
-    `ASSERT(SigIntPing_A, PingSigInt_S |=>
-        alert_tx_o.alert_p == alert_tx_o.alert_n)
-    `ASSERT(SigIntAck_A,  AckSigInt_S |=>
-        alert_tx_o.alert_p == alert_tx_o.alert_n)
-    // Test in-band FSM reset request (via signal integrity error)
-    `ASSERT(InBandInitFsm_A, PingSigInt_S or AckSigInt_S |=> state_q == Idle)
-    `ASSERT(InBandInitPing_A, PingSigInt_S or AckSigInt_S |=> !ping_set_q)
-    // output must be driven diff unless sigint issue detected
-    `ASSERT(DiffEncoding_A, (alert_rx_i.ack_p ^ alert_rx_i.ack_n) &&
-        (alert_rx_i.ping_p ^ alert_rx_i.ping_n) |=> alert_tx_o.alert_p ^ alert_tx_o.alert_n)
-    // handshakes can take indefinite time if blocked due to sigint on outgoing
-    // lines (which is not visible here). thus, we only check whether the handshake
-    // is correctly initiated and defer the full handshake checking to the testbench.
-    `ASSERT(PingHs_A, ##1 $changed(alert_rx_i.ping_p) && state_q == Idle |=>
-        $rose(alert_tx_o.alert_p), clk_i, !rst_ni || (alert_tx_o.alert_p == alert_tx_o.alert_n))
-  end
-
-  // Test the alert state output.
-  `ASSERT(AlertState0_A, alert_set_q === alert_state_o)
-
-  if (IsFatal) begin : gen_fatal_assert
-    `ASSERT(AlertState1_A, alert_req_i |=> alert_state_o)
-    `ASSERT(AlertState2_A, alert_state_o |=> $stable(alert_state_o))
-    `ASSERT(AlertState3_A, alert_ack_o |=> alert_state_o)
-  end else begin : gen_recov_assert
-    `ASSERT(AlertState1_A, alert_req_i && !alert_clr |=> alert_state_o)
-    `ASSERT(AlertState2_A, alert_req_i && alert_ack_o |=> !alert_state_o)
-  end
-
-  // The alert test input should not set the alert state register.
-  `ASSERT(AlertTest1_A, alert_test_i && !alert_req_i && !alert_state_o |=> $stable(alert_state_o))
-
-  // if alert_req_i is true, handshakes should be continuously repeated
-  `ASSERT(AlertHs_A, alert_req_i && state_q == Idle |=> $rose(alert_tx_o.alert_p),
-      clk_i, !rst_ni || (alert_tx_o.alert_p == alert_tx_o.alert_n))
-
-  // if alert_test_i is true, handshakes should be continuously repeated
-  `ASSERT(AlertTestHs_A, alert_test_i && state_q == Idle |=> $rose(alert_tx_o.alert_p),
-      clk_i, !rst_ni || (alert_tx_o.alert_p == alert_tx_o.alert_n))
-`endif
-
-`ifdef FPV_SEC_CM_ON
-  // Assumptions for FPV security countermeasures to ensure the alert protocol functions collectly.
-  `ASSUME_FPV(AckPFollowsAlertP_S, alert_rx_i.ack_p == $past(alert_tx_o.alert_p))
-  `ASSUME_FPV(AckNFollowsAlertN_S, alert_rx_i.ack_n == $past(alert_tx_o.alert_n))
-  `ASSUME_FPV(TriggerAlertInit_S, $stable(rst_ni) == 0 |=> alert_rx_i.ping_p == alert_rx_i.ping_n)
-  `ASSUME_FPV(PingDiffPair_S, ##2 alert_rx_i.ping_p != alert_rx_i.ping_n)
-`endif
-endmodule : prim_alert_sender
diff --git a/prim_arbiter_fixed.sv b/prim_arbiter_fixed.sv
deleted file mode 100644
index d9677dd2..00000000
--- a/prim_arbiter_fixed.sv
+++ /dev/null
@@ -1,170 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// N:1 fixed priority arbiter module (index 0 has highest prio)
-//
-// Verilog parameter
-//   N:           Number of request ports
-//   DW:          Data width
-//   DataPort:    Set to 1 to enable the data port. Otherwise that port will be ignored.
-//
-// See also: prim_arbiter_ppc, prim_arbiter_tree
-
-`include "prim_assert.sv"
-
-module prim_arbiter_fixed #(
-  parameter int N   = 8,
-  parameter int DW  = 32,
-
-  // Configurations
-  // EnDataPort: {0, 1}, if 0, input data will be ignored
-  parameter bit EnDataPort = 1,
-
-  // Derived parameters
-  localparam int IdxW = $clog2(N)
-) (
-  // used for assertions only
-  input clk_i,
-  input rst_ni,
-
-  input        [ N-1:0]    req_i,
-  input        [DW-1:0]    data_i [N],
-  output logic [ N-1:0]    gnt_o,
-  output logic [IdxW-1:0]  idx_o,
-
-  output logic             valid_o,
-  output logic [DW-1:0]    data_o,
-  input                    ready_i
-);
-
-  `ASSERT_INIT(CheckNGreaterZero_A, N > 0)
-
-  // this case is basically just a bypass
-  if (N == 1) begin : gen_degenerate_case
-
-    assign valid_o  = req_i[0];
-    assign data_o   = data_i[0];
-    assign gnt_o[0] = valid_o & ready_i;
-    assign idx_o    = '0;
-
-  end else begin : gen_normal_case
-
-    // align to powers of 2 for simplicity
-    // a full binary tree with N levels has 2**N + 2**N-1 nodes
-    logic [2**(IdxW+1)-2:0]           req_tree;
-    logic [2**(IdxW+1)-2:0]           gnt_tree;
-    logic [2**(IdxW+1)-2:0][IdxW-1:0] idx_tree;
-    logic [2**(IdxW+1)-2:0][DW-1:0]   data_tree;
-
-    for (genvar level = 0; level < IdxW+1; level++) begin : gen_tree
-      //
-      // level+1   C0   C1   <- "Base1" points to the first node on "level+1",
-      //            \  /         these nodes are the children of the nodes one level below
-      // level       Pa      <- "Base0", points to the first node on "level",
-      //                         these nodes are the parents of the nodes one level above
-      //
-      // hence we have the following indices for the Pa, C0, C1 nodes:
-      // Pa = 2**level     - 1 + offset       = Base0 + offset
-      // C0 = 2**(level+1) - 1 + 2*offset     = Base1 + 2*offset
-      // C1 = 2**(level+1) - 1 + 2*offset + 1 = Base1 + 2*offset + 1
-      //
-      localparam int Base0 = (2**level)-1;
-      localparam int Base1 = (2**(level+1))-1;
-
-      for (genvar offset = 0; offset < 2**level; offset++) begin : gen_level
-        localparam int Pa = Base0 + offset;
-        localparam int C0 = Base1 + 2*offset;
-        localparam int C1 = Base1 + 2*offset + 1;
-
-        // this assigns the gated interrupt source signals, their
-        // corresponding IDs and priorities to the tree leafs
-        if (level == IdxW) begin : gen_leafs
-          if (offset < N) begin : gen_assign
-            // forward path
-            assign req_tree[Pa]      = req_i[offset];
-            assign idx_tree[Pa]      = offset;
-            assign data_tree[Pa]     = data_i[offset];
-            // backward (grant) path
-            assign gnt_o[offset]     = gnt_tree[Pa];
-
-          end else begin : gen_tie_off
-            // forward path
-            assign req_tree[Pa]  = '0;
-            assign idx_tree[Pa]  = '0;
-            assign data_tree[Pa] = '0;
-            logic unused_sigs;
-            assign unused_sigs = gnt_tree[Pa];
-          end
-        // this creates the node assignments
-        end else begin : gen_nodes
-          // forward path
-          logic sel; // local helper variable
-          always_comb begin : p_node
-            // this always gives priority to the left child
-            sel = ~req_tree[C0];
-            // propagate requests
-            req_tree[Pa]  = req_tree[C0] | req_tree[C1];
-            // data and index muxes
-            idx_tree[Pa]  = (sel) ? idx_tree[C1]  : idx_tree[C0];
-            data_tree[Pa] = (sel) ? data_tree[C1] : data_tree[C0];
-            // propagate the grants back to the input
-            gnt_tree[C0] = gnt_tree[Pa] & ~sel;
-            gnt_tree[C1] = gnt_tree[Pa] &  sel;
-          end
-        end
-      end : gen_level
-    end : gen_tree
-
-    // the results can be found at the tree root
-    if (EnDataPort) begin : gen_data_port
-      assign data_o      = data_tree[0];
-    end else begin : gen_no_dataport
-      logic [DW-1:0] unused_data;
-      assign unused_data = data_tree[0];
-      assign data_o = '1;
-    end
-
-    assign idx_o       = idx_tree[0];
-    assign valid_o     = req_tree[0];
-
-    // this propagates a grant back to the input
-    assign gnt_tree[0] = valid_o & ready_i;
-  end
-
-  ////////////////
-  // assertions //
-  ////////////////
-
-  // KNOWN assertions on outputs, except for data as that may be partially X in simulation
-  // e.g. when used on a BUS
-  `ASSERT_KNOWN(ValidKnown_A, valid_o)
-  `ASSERT_KNOWN(GrantKnown_A, gnt_o)
-  `ASSERT_KNOWN(IdxKnown_A, idx_o)
-
-  // Make sure no higher prio req is asserted
-  `ASSERT(Priority_A, |req_i |-> req_i[idx_o] && (((N'(1'b1) << idx_o) - 1'b1) & req_i) == '0)
-
-  // we can only grant one requestor at a time
-  `ASSERT(CheckHotOne_A, $onehot0(gnt_o))
-  // A grant implies that the sink is ready
-  `ASSERT(GntImpliesReady_A, |gnt_o |-> ready_i)
-  // A grant implies that the arbiter asserts valid as well
-  `ASSERT(GntImpliesValid_A, |gnt_o |-> valid_o)
-  // A request and a sink that is ready imply a grant
-  `ASSERT(ReqAndReadyImplyGrant_A, |req_i && ready_i |-> |gnt_o)
-  // A request and a sink that is ready imply a grant
-  `ASSERT(ReqImpliesValid_A, |req_i |-> valid_o)
-  // Both conditions above combined and reversed
-  `ASSERT(ReadyAndValidImplyGrant_A, ready_i && valid_o |-> |gnt_o)
-  // Both conditions above combined and reversed
-  `ASSERT(NoReadyValidNoGrant_A, !(ready_i || valid_o) |-> gnt_o == 0)
-  // check index / grant correspond
-  `ASSERT(IndexIsCorrect_A, ready_i && valid_o |-> gnt_o[idx_o] && req_i[idx_o])
-
-if (EnDataPort) begin: gen_data_port_assertion
-  // data flow
-  `ASSERT(DataFlow_A, ready_i && valid_o |-> data_o == data_i[idx_o])
-end
-
-endmodule : prim_arbiter_fixed
diff --git a/prim_arbiter_ppc.sv b/prim_arbiter_ppc.sv
deleted file mode 100644
index 17f3e19a..00000000
--- a/prim_arbiter_ppc.sv
+++ /dev/null
@@ -1,225 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// N:1 arbiter module
-//
-// Verilog parameter
-//   N:           Number of request ports
-//   DW:          Data width
-//   DataPort:    Set to 1 to enable the data port. Otherwise that port will be ignored.
-//
-// This is the original implementation of the arbiter which relies on parallel prefix computing
-// optimization to optimize the request / arbiter tree. Not all synthesis tools may support this.
-//
-// Note that the currently winning request is held if the data sink is not ready. This behavior is
-// required by some interconnect protocols (AXI, TL). The module contains an assertion that checks
-// this behavior.
-//
-// Also, this module contains a request stability assertion that checks that requests stay asserted
-// until they have been served. This assertion can be gated by driving the req_chk_i low. This is
-// a non-functional input and does not affect the designs behavior.
-//
-// See also: prim_arbiter_tree
-
-`include "prim_assert.sv"
-
-module prim_arbiter_ppc #(
-  parameter int unsigned N  = 8,
-  parameter int unsigned DW = 32,
-
-  // Configurations
-  // EnDataPort: {0, 1}, if 0, input data will be ignored
-  parameter bit EnDataPort = 1,
-
-  // Derived parameters
-  localparam int IdxW = $clog2(N)
-) (
-  input clk_i,
-  input rst_ni,
-
-  input                    req_chk_i, // Used for gating assertions. Drive to 1 during normal
-                                      // operation.
-  input        [ N-1:0]    req_i,
-  input        [DW-1:0]    data_i [N],
-  output logic [ N-1:0]    gnt_o,
-  output logic [IdxW-1:0]  idx_o,
-
-  output logic             valid_o,
-  output logic [DW-1:0]    data_o,
-  input                    ready_i
-);
-
-  // req_chk_i is used for gating assertions only.
-  logic unused_req_chk;
-  assign unused_req_chk = req_chk_i;
-
-  `ASSERT_INIT(CheckNGreaterZero_A, N > 0)
-
-  // this case is basically just a bypass
-  if (N == 1) begin : gen_degenerate_case
-
-    assign valid_o  = req_i[0];
-    assign data_o   = data_i[0];
-    assign gnt_o[0] = valid_o & ready_i;
-    assign idx_o    = '0;
-
-  end else begin : gen_normal_case
-
-    logic [N-1:0] masked_req;
-    logic [N-1:0] ppc_out;
-    logic [N-1:0] arb_req;
-    logic [N-1:0] mask, mask_next;
-    logic [N-1:0] winner;
-
-    assign masked_req = mask & req_i;
-    assign arb_req = (|masked_req) ? masked_req : req_i;
-
-    // PPC
-    //   Even below code looks O(n) but DC optimizes it to O(log(N))
-    //   Using Parallel Prefix Computation
-    always_comb begin
-      ppc_out[0] = arb_req[0];
-      for (int i = 1 ; i < N ; i++) begin
-        ppc_out[i] = ppc_out[i-1] | arb_req[i];
-      end
-    end
-
-    // Grant Generation: Leading-One detector
-    assign winner = ppc_out ^ {ppc_out[N-2:0], 1'b0};
-    assign gnt_o    = (ready_i) ? winner : '0;
-
-    assign valid_o = |req_i;
-    // Mask Generation
-    assign mask_next = {ppc_out[N-2:0], 1'b0};
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-        mask <= '0;
-      end else if (valid_o && ready_i) begin
-        // Latch only when requests accepted
-        mask <= mask_next;
-      end else if (valid_o && !ready_i) begin
-        // Downstream isn't yet ready so, keep current request alive. (First come first serve)
-        mask <= ppc_out;
-      end
-    end
-
-    if (EnDataPort == 1) begin: gen_datapath
-      always_comb begin
-        data_o = '0;
-        for (int i = 0 ; i < N ; i++) begin
-          if (winner[i]) begin
-            data_o = data_i[i];
-          end
-        end
-      end
-    end else begin: gen_nodatapath
-      assign data_o = '1;
-      // The following signal is used to avoid possible lint errors.
-      logic [DW-1:0] unused_data [N];
-      assign unused_data = data_i;
-    end
-
-    always_comb begin
-      idx_o = '0;
-      for (int unsigned i = 0 ; i < N ; i++) begin
-        if (winner[i]) begin
-          idx_o = i[IdxW-1:0];
-        end
-      end
-    end
-  end
-
-  ////////////////
-  // assertions //
-  ////////////////
-
-  // KNOWN assertions on outputs, except for data as that may be partially X in simulation
-  // e.g. when used on a BUS
-  `ASSERT_KNOWN(ValidKnown_A, valid_o)
-  `ASSERT_KNOWN(GrantKnown_A, gnt_o)
-  `ASSERT_KNOWN(IdxKnown_A, idx_o)
-
-  // grant index shall be higher index than previous index, unless no higher requests exist.
-  `ASSERT(RoundRobin_A,
-      ##1 valid_o && ready_i && $past(ready_i) && $past(valid_o) &&
-      |(req_i & ~((N'(1) << $past(idx_o)+1) - 1)) |->
-      idx_o > $past(idx_o))
-  // we can only grant one requestor at a time
-  `ASSERT(CheckHotOne_A, $onehot0(gnt_o))
-  // A grant implies that the sink is ready
-  `ASSERT(GntImpliesReady_A, |gnt_o |-> ready_i)
-  // A grant implies that the arbiter asserts valid as well
-  `ASSERT(GntImpliesValid_A, |gnt_o |-> valid_o)
-  // A request and a sink that is ready imply a grant
-  `ASSERT(ReqAndReadyImplyGrant_A, |req_i && ready_i |-> |gnt_o)
-  // A request and a sink that is ready imply a grant
-  `ASSERT(ReqImpliesValid_A, |req_i |-> valid_o)
-  // Both conditions above combined and reversed
-  `ASSERT(ReadyAndValidImplyGrant_A, ready_i && valid_o |-> |gnt_o)
-  // Both conditions above combined and reversed
-  `ASSERT(NoReadyValidNoGrant_A, !(ready_i || valid_o) |-> gnt_o == 0)
-  // check index / grant correspond
-  `ASSERT(IndexIsCorrect_A, ready_i && valid_o |-> gnt_o[idx_o] && req_i[idx_o])
-
-if (EnDataPort) begin: gen_data_port_assertion
-  // data flow
-  `ASSERT(DataFlow_A, ready_i && valid_o |-> data_o == data_i[idx_o])
-end
-
-  // requests must stay asserted until they have been granted
-  `ASSUME(ReqStaysHighUntilGranted0_M, |req_i && !ready_i |=>
-      (req_i & $past(req_i)) == $past(req_i), clk_i, !rst_ni || !req_chk_i)
-  // check that the arbitration decision is held if the sink is not ready
-  `ASSERT(LockArbDecision_A, |req_i && !ready_i |=> idx_o == $past(idx_o),
-      clk_i, !rst_ni || !req_chk_i)
-
-// FPV-only assertions with symbolic variables
-`ifdef FPV_ON
-  // symbolic variables
-  int unsigned k;
-  bit ReadyIsStable;
-  bit ReqsAreStable;
-
-  // constraints for symbolic variables
-  `ASSUME(KStable_M, ##1 $stable(k))
-  `ASSUME(KRange_M, k < N)
-  // this is used enable checking for stable and unstable ready_i and req_i signals in the same run.
-  // the symbolic variables act like a switch that the solver can trun on and off.
-  `ASSUME(ReadyIsStable_M, ##1 $stable(ReadyIsStable))
-  `ASSUME(ReqsAreStable_M, ##1 $stable(ReqsAreStable))
-  `ASSUME(ReadyStable_M, ##1 !ReadyIsStable || $stable(ready_i))
-  `ASSUME(ReqsStable_M, ##1 !ReqsAreStable || $stable(req_i))
-
-  // A grant implies a request
-  `ASSERT(GntImpliesReq_A, gnt_o[k] |-> req_i[k])
-
-  // if request and ready are constantly held at 1, we should eventually get a grant
-  `ASSERT(NoStarvation_A,
-      ReqsAreStable && ReadyIsStable && ready_i && req_i[k] |->
-      strong(##[0:$] gnt_o[k]))
-
-  // if N requests are constantly asserted and ready is constant 1, each request must
-  // be granted exactly once over a time window of N cycles for the arbiter to be fair.
-  for (genvar n = 1; n <= N; n++) begin : gen_fairness
-    integer gnt_cnt;
-    `ASSERT(Fairness_A,
-        ReqsAreStable && ReadyIsStable && ready_i && req_i[k] &&
-        $countones(req_i) == n |->
-        ##n gnt_cnt == $past(gnt_cnt, n) + 1)
-
-    always_ff @(posedge clk_i or negedge rst_ni) begin : p_cnt
-      if (!rst_ni) begin
-        gnt_cnt <= 0;
-      end else begin
-        gnt_cnt <= gnt_cnt + gnt_o[k];
-      end
-    end
-  end
-
-  // requests must stay asserted until they have been granted
-  `ASSUME(ReqStaysHighUntilGranted1_M, req_i[k] && !gnt_o[k] |=>
-      req_i[k], clk_i, !rst_ni || !req_chk_i)
-`endif
-
-endmodule : prim_arbiter_ppc
diff --git a/prim_arbiter_tree.sv b/prim_arbiter_tree.sv
deleted file mode 100644
index 93d809e9..00000000
--- a/prim_arbiter_tree.sv
+++ /dev/null
@@ -1,291 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// N:1 arbiter module
-//
-// Verilog parameter
-//   N:           Number of request ports
-//   DW:          Data width
-//   DataPort:    Set to 1 to enable the data port. Otherwise that port will be ignored.
-//
-// This is a tree implementation of a round robin arbiter. It has the same behavior as the PPC
-// implementation in prim_arbiter_ppc, and also uses a prefix summing approach to determine the next
-// request to be granted. The main difference with respect to the PPC arbiter is that the leading 1
-// detection and the prefix summation are performed with a binary tree instead of a sequential loop.
-// Also, if the data port is enabled, the data is muxed based on the local arbitration decisions  at
-// each node of the arbiter tree. This means that the data can propagate through the tree
-// simultaneously with the requests, instead of waiting for the arbitration to determine the winner
-// index first. As a result, this design has a shorter critical path than other implementations,
-// leading to better ovberall timing.
-//
-// Note that the currently winning request is held if the data sink is not ready. This behavior is
-// required by some interconnect protocols (AXI, TL). The module contains an assertion that checks
-// this behavior.
-//
-// Also, this module contains a request stability assertion that checks that requests stay asserted
-// until they have been served. This assertion can be gated by driving the req_chk_i low. This is
-// a non-functional input and does not affect the designs behavior.
-//
-// See also: prim_arbiter_ppc
-
-`include "prim_assert.sv"
-
-module prim_arbiter_tree #(
-  parameter int N   = 8,
-  parameter int DW  = 32,
-
-  // Configurations
-  // EnDataPort: {0, 1}, if 0, input data will be ignored
-  parameter bit EnDataPort = 1,
-
-  // Derived parameters
-  localparam int IdxW = $clog2(N)
-) (
-  input clk_i,
-  input rst_ni,
-
-  input                    req_chk_i, // Used for gating assertions. Drive to 1 during normal
-                                      // operation.
-  input        [ N-1:0]    req_i,
-  input        [DW-1:0]    data_i [N],
-  output logic [ N-1:0]    gnt_o,
-  output logic [IdxW-1:0]  idx_o,
-
-  output logic             valid_o,
-  output logic [DW-1:0]    data_o,
-  input                    ready_i
-);
-
-  // req_chk_i is used for gating assertions only.
-  logic unused_req_chk;
-  assign unused_req_chk = req_chk_i;
-
-  `ASSERT_INIT(CheckNGreaterZero_A, N > 0)
-
-  // this case is basically just a bypass
-  if (N == 1) begin : gen_degenerate_case
-
-    assign valid_o  = req_i[0];
-    assign data_o   = data_i[0];
-    assign gnt_o[0] = valid_o & ready_i;
-    assign idx_o    = '0;
-
-  end else begin : gen_normal_case
-
-    // align to powers of 2 for simplicity
-    // a full binary tree with N levels has 2**N + 2**N-1 nodes
-    logic [2**(IdxW+1)-2:0]           req_tree;
-    logic [2**(IdxW+1)-2:0]           prio_tree;
-    logic [2**(IdxW+1)-2:0]           sel_tree;
-    logic [2**(IdxW+1)-2:0]           mask_tree;
-    logic [2**(IdxW+1)-2:0][IdxW-1:0] idx_tree;
-    logic [2**(IdxW+1)-2:0][DW-1:0]   data_tree;
-    logic [N-1:0]                     prio_mask_d, prio_mask_q;
-
-    for (genvar level = 0; level < IdxW+1; level++) begin : gen_tree
-      //
-      // level+1   C0   C1   <- "Base1" points to the first node on "level+1",
-      //            \  /         these nodes are the children of the nodes one level below
-      // level       Pa      <- "Base0", points to the first node on "level",
-      //                         these nodes are the parents of the nodes one level above
-      //
-      // hence we have the following indices for the Pa, C0, C1 nodes:
-      // Pa = 2**level     - 1 + offset       = Base0 + offset
-      // C0 = 2**(level+1) - 1 + 2*offset     = Base1 + 2*offset
-      // C1 = 2**(level+1) - 1 + 2*offset + 1 = Base1 + 2*offset + 1
-      //
-      localparam int Base0 = (2**level)-1;
-      localparam int Base1 = (2**(level+1))-1;
-
-      for (genvar offset = 0; offset < 2**level; offset++) begin : gen_level
-        localparam int Pa = Base0 + offset;
-        localparam int C0 = Base1 + 2*offset;
-        localparam int C1 = Base1 + 2*offset + 1;
-
-        // this assigns the gated interrupt source signals, their
-        // corresponding IDs and priorities to the tree leafs
-        if (level == IdxW) begin : gen_leafs
-          if (offset < N) begin : gen_assign
-            // forward path (requests and data)
-            // all requests inputs are assigned to the request tree
-            assign req_tree[Pa]      = req_i[offset];
-            // we basically split the incoming request vector into two halves with the following
-            // priority assignment. the prio_mask_q register contains a prefix sum that has been
-            // computed using the last winning index, and hence masks out all requests at offsets
-            // lower or equal the previously granted index. hence, all higher indices are considered
-            // first in the arbitration tree nodes below, before considering the lower indices.
-            assign prio_tree[Pa]     = req_i[offset] & prio_mask_q[offset];
-            // input for the index muxes (used to compute the winner index)
-            assign idx_tree[Pa]      = offset;
-            // input for the data muxes
-            assign data_tree[Pa]     = data_i[offset];
-
-            // backward path (grants and prefix sum)
-            // grant if selected, ready and request asserted
-            assign gnt_o[offset]       = req_i[offset] & sel_tree[Pa] & ready_i;
-            // only update mask if there is a valid request
-            assign prio_mask_d[offset] = (|req_i) ?
-                                         mask_tree[Pa] | sel_tree[Pa] & ~ready_i :
-                                         prio_mask_q[offset];
-          end else begin : gen_tie_off
-            // forward path
-            assign req_tree[Pa]  = '0;
-            assign prio_tree[Pa] = '0;
-            assign idx_tree[Pa]  = '0;
-            assign data_tree[Pa] = '0;
-            logic unused_sigs;
-            assign unused_sigs = ^{mask_tree[Pa],
-                                   sel_tree[Pa]};
-          end
-        // this creates the node assignments
-        end else begin : gen_nodes
-          // local helper variable
-          logic sel;
-
-          // forward path (requests and data)
-          // each node looks at its two children, and selects the one with higher priority
-          assign sel = ~req_tree[C0] | ~prio_tree[C0] & prio_tree[C1];
-          // propagate requests
-          assign req_tree[Pa]  = req_tree[C0] | req_tree[C1];
-          assign prio_tree[Pa] = prio_tree[C1] | prio_tree[C0];
-          // data and index muxes
-          // Note: these ternaries have triggered a synthesis bug in Vivado versions older
-          // than 2020.2. If the problem resurfaces again, have a look at issue #1408.
-          assign idx_tree[Pa]  = (sel) ? idx_tree[C1]  : idx_tree[C0];
-          assign data_tree[Pa] = (sel) ? data_tree[C1] : data_tree[C0];
-
-          // backward path (grants and prefix sum)
-          // this propagates the selction index back and computes a hot one mask
-          assign sel_tree[C0] = sel_tree[Pa] & ~sel;
-          assign sel_tree[C1] = sel_tree[Pa] &  sel;
-          // this performs a prefix sum for masking the input requests in the next cycle
-          assign mask_tree[C0] = mask_tree[Pa];
-          assign mask_tree[C1] = mask_tree[Pa] | sel_tree[C0];
-        end
-      end : gen_level
-    end : gen_tree
-
-    // the results can be found at the tree root
-    if (EnDataPort) begin : gen_data_port
-      assign data_o      = data_tree[0];
-    end else begin : gen_no_dataport
-      logic [DW-1:0] unused_data;
-      assign unused_data = data_tree[0];
-      assign data_o = '1;
-    end
-
-    // This index is unused.
-    logic unused_prio_tree;
-    assign unused_prio_tree = prio_tree[0];
-
-    assign idx_o       = idx_tree[0];
-    assign valid_o     = req_tree[0];
-
-    // the select tree computes a hot one signal that indicates which request is currently selected
-    assign sel_tree[0] = 1'b1;
-    // the mask tree is basically a prefix sum of the hot one select signal computed above
-    assign mask_tree[0] = 1'b0;
-
-    always_ff @(posedge clk_i or negedge rst_ni) begin : p_mask_reg
-      if (!rst_ni) begin
-        prio_mask_q <= '0;
-      end else begin
-        prio_mask_q <= prio_mask_d;
-      end
-    end
-  end
-
-  ////////////////
-  // assertions //
-  ////////////////
-
-  // KNOWN assertions on outputs, except for data as that may be partially X in simulation
-  // e.g. when used on a BUS
-  `ASSERT_KNOWN(ValidKnown_A, valid_o)
-  `ASSERT_KNOWN(GrantKnown_A, gnt_o)
-  `ASSERT_KNOWN(IdxKnown_A, idx_o)
-
-  // grant index shall be higher index than previous index, unless no higher requests exist.
-  `ASSERT(RoundRobin_A,
-      ##1 valid_o && ready_i && $past(ready_i) && $past(valid_o) &&
-      |(req_i & ~((N'(1) << $past(idx_o)+1) - 1)) |->
-      idx_o > $past(idx_o))
-  // we can only grant one requestor at a time
-  `ASSERT(CheckHotOne_A, $onehot0(gnt_o))
-  // A grant implies that the sink is ready
-  `ASSERT(GntImpliesReady_A, |gnt_o |-> ready_i)
-  // A grant implies that the arbiter asserts valid as well
-  `ASSERT(GntImpliesValid_A, |gnt_o |-> valid_o)
-  // A request and a sink that is ready imply a grant
-  `ASSERT(ReqAndReadyImplyGrant_A, |req_i && ready_i |-> |gnt_o)
-  // A request and a sink that is ready imply a grant
-  `ASSERT(ReqImpliesValid_A, |req_i |-> valid_o)
-  // Both conditions above combined and reversed
-  `ASSERT(ReadyAndValidImplyGrant_A, ready_i && valid_o |-> |gnt_o)
-  // Both conditions above combined and reversed
-  `ASSERT(NoReadyValidNoGrant_A, !(ready_i || valid_o) |-> gnt_o == 0)
-  // check index / grant correspond
-  `ASSERT(IndexIsCorrect_A, ready_i && valid_o |-> gnt_o[idx_o] && req_i[idx_o])
-
-if (EnDataPort) begin: gen_data_port_assertion
-  // data flow
-  `ASSERT(DataFlow_A, ready_i && valid_o |-> data_o == data_i[idx_o])
-end
-
-  // requests must stay asserted until they have been granted
-  `ASSUME(ReqStaysHighUntilGranted0_M, |req_i && !ready_i |=>
-      (req_i & $past(req_i)) == $past(req_i), clk_i, !rst_ni || !req_chk_i)
-  // check that the arbitration decision is held if the sink is not ready
-  `ASSERT(LockArbDecision_A, |req_i && !ready_i |=> idx_o == $past(idx_o),
-      clk_i, !rst_ni || !req_chk_i)
-
-// FPV-only assertions with symbolic variables
-`ifdef FPV_ON
-  // symbolic variables
-  int unsigned k;
-  bit ReadyIsStable;
-  bit ReqsAreStable;
-
-  // constraints for symbolic variables
-  `ASSUME(KStable_M, ##1 $stable(k))
-  `ASSUME(KRange_M, k < N)
-  // this is used enable checking for stable and unstable ready_i and req_i signals in the same run.
-  // the symbolic variables act like a switch that the solver can trun on and off.
-  `ASSUME(ReadyIsStable_M, ##1 $stable(ReadyIsStable))
-  `ASSUME(ReqsAreStable_M, ##1 $stable(ReqsAreStable))
-  `ASSUME(ReadyStable_M, ##1 !ReadyIsStable || $stable(ready_i))
-  `ASSUME(ReqsStable_M, ##1 !ReqsAreStable || $stable(req_i))
-
-  // A grant implies a request
-  `ASSERT(GntImpliesReq_A, gnt_o[k] |-> req_i[k])
-
-  // if request and ready are constantly held at 1, we should eventually get a grant
-  `ASSERT(NoStarvation_A,
-      ReqsAreStable && ReadyIsStable && ready_i && req_i[k] |->
-      strong(##[0:$] gnt_o[k]))
-
-  // if N requests are constantly asserted and ready is constant 1, each request must
-  // be granted exactly once over a time window of N cycles for the arbiter to be fair.
-  for (genvar n = 1; n <= N; n++) begin : gen_fairness
-    integer gnt_cnt;
-    `ASSERT(Fairness_A,
-        ReqsAreStable && ReadyIsStable && ready_i && req_i[k] &&
-        $countones(req_i) == n |->
-        ##n gnt_cnt == $past(gnt_cnt, n) + 1)
-
-    always_ff @(posedge clk_i or negedge rst_ni) begin : p_cnt
-      if (!rst_ni) begin
-        gnt_cnt <= 0;
-      end else begin
-        gnt_cnt <= gnt_cnt + gnt_o[k];
-      end
-    end
-  end
-
-  // requests must stay asserted until they have been granted
-  `ASSUME(ReqStaysHighUntilGranted1_M, req_i[k] && !gnt_o[k] |=>
-      req_i[k], clk_i, !rst_ni || !req_chk_i)
-`endif
-
-endmodule : prim_arbiter_tree
diff --git a/prim_cdc_rand_delay.sv b/prim_cdc_rand_delay.sv
deleted file mode 100644
index f8ddd92b..00000000
--- a/prim_cdc_rand_delay.sv
+++ /dev/null
@@ -1,204 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-
-// This module should be instantiated within flops of CDC synchronization primitives,
-// and allows DV to model real CDC delays within simulations, especially useful at the chip level
-// or in IPs that communicate across clock domains.
-//
-// If not, delay randomization is enabled - the faster of the two clocks is used to latch src_data,
-// dst_data is synchronously driven with a random combination of the current src_data and
-// the delayed version of src_data.
-//
-// If a source clock isn't used, the input src_data is latched after a parameterizable latency
-// as `src_data_with_latency`, and an internal version of the output data `src_data_delayed` is set
-// to this same value after a parameterizable jitter period.
-//
-// This is meant to model skew between synchronizer bits and wire delay between the src and dst
-// flops.
-//
-// Five (5) different random delay modes are available:
-//
-// - PrimCdcRandDelayDisable: If this delay mode is picked, this module acts as a simple
-//                            passthrough.
-//
-// - PrimCdcRandDelaySlow: If this delay mode is picked, the output to the dst domain is
-//                         continuously driven to `src_data_delayed`.
-//
-// - PrimCdcRandDelayOnce: If this delay mode is picked, the mask `out_data_mask` used to combine
-//                         `src_data_with_latency` and `src_data_delayed` is fully randomized
-//                         once at the beginning of the simulation.
-//
-// - PrimCdcRandDelayInterval: If this delay mode is picked, the mask `out_data_mask` used to
-//                            combine `src_data_with_latency` and `src_data_delayed` is fully
-//                            randomized every `prim_cdc_num_src_data_changes` times that
-//                            `src_data_with_latency` changes.
-//
-// - PrimCdcRandDelayFull: If this delay mode is picked, the mask `out_data_mask` used to combine
-//                         `src_data_with_latency` and `src_data_delayed` is fully randomized
-//                         any time `src_data_with_latency` changes.
-//
-// DV has control of the weights corresponding to each random delay mode when the delay mode is
-// randomized, but can also directly override the delay mode as desired.
-//
-// DV also has control over whether the source clock is used, the latency, and the jitter values -
-// these can be modified through the provided setter tasks.
-
-module prim_cdc_rand_delay #(
-    parameter int DataWidth = 1,
-    parameter bit UseSourceClock = 1,
-    parameter int LatencyPs = 500,
-    parameter int JitterPs = 500
-) (
-    input logic                 src_clk,
-    input logic [DataWidth-1:0] src_data,
-
-    input logic                   dst_clk,
-    output logic [DataWidth-1:0]  dst_data
-);
-
-  `ASSERT_INIT(LegalWidth_A, DataWidth > 0)
-
-  int prim_cdc_latency_ps = LatencyPs;
-  int prim_cdc_jitter_ps  = JitterPs;
-
-  // Only applies with using CdcRandDelayInterval randomization mode.
-  //
-  // This is the number of times that `src_data_with_latency` is allowed to change before
-  // we re-randomize `out_data_mask`.
-  int prim_cdc_num_src_data_changes = 10;
-  int counter = 0;
-
-  task automatic set_prim_cdc_latency_ps(int val);
-    prim_cdc_latency_ps = val;
-    `ASSERT_I(LegalLatency_A, prim_cdc_latency_ps > 0)
-  endtask
-
-  task automatic set_prim_cdc_jitter_ps(int val);
-    prim_cdc_jitter_ps = val;
-    `ASSERT_I(LegalJitter_A, prim_cdc_jitter_ps > 0)
-  endtask
-
-  task automatic set_prim_cdc_num_src_data_changes(int val);
-    prim_cdc_num_src_data_changes = val;
-  endtask
-
-  typedef enum bit [2:0] {
-    PrimCdcRandDelayDisable,
-    PrimCdcRandDelaySlow,
-    PrimCdcRandDelayOnce,
-    PrimCdcRandDelayInterval,
-    PrimCdcRandDelayFull
-  } prim_cdc_rand_delay_mode_e;
-
-  prim_cdc_rand_delay_mode_e prim_cdc_rand_mode;
-
-  logic [DataWidth-1:0] out_data_mask;
-
-  bit en_passthru = 1'b0;
-
-  bit out_randomize_en = 1'b0;
-
-  bit en_rand_interval_mask = 1'b0;
-
-  logic [DataWidth-1:0] src_data_with_latency;
-  logic [DataWidth-1:0] src_data_delayed;
-
-  int unsigned prim_cdc_rand_disable_weight  = 0;
-  int unsigned prim_cdc_rand_slow_weight     = 20;
-  int unsigned prim_cdc_rand_once_weight     = 50;
-  int unsigned prim_cdc_rand_interval_weight = 20;
-  int unsigned prim_cdc_rand_full_weight     = 10;
-
-  initial begin
-    // DV can override these from command line as desired.
-    void'($value$plusargs("prim_cdc_latency_ps=%0d",            prim_cdc_latency_ps));
-    void'($value$plusargs("prim_cdc_jitter_ps=%0d",             prim_cdc_jitter_ps));
-    void'($value$plusargs("prim_cdc_num_src_data_changes=%0d",  prim_cdc_num_src_data_changes));
-    void'($value$plusargs("prim_cdc_rand_disable_weight=%0d",   prim_cdc_rand_disable_weight));
-    void'($value$plusargs("prim_cdc_rand_slow_weight=%0d",      prim_cdc_rand_slow_weight));
-    void'($value$plusargs("prim_cdc_rand_once_weight=%0d",      prim_cdc_rand_once_weight));
-    void'($value$plusargs("prim_cdc_rand_interval_weight=%0d",  prim_cdc_rand_interval_weight));
-    void'($value$plusargs("prim_cdc_rand_full_weight=%0d",      prim_cdc_rand_full_weight));
-
-    if (!$value$plusargs("prim_cdc_rand_mode=%0d", prim_cdc_rand_mode)) begin
-      // By default pick the most performant(*) random delay mode for normal test
-      // development/simulation.
-      //
-      // (*): Need to do some performance experiments to check that the chosen mode is actually the
-      //      most performant.
-      prim_cdc_rand_mode = PrimCdcRandDelaySlow;
-    end
-
-    unique case (prim_cdc_rand_mode)
-      PrimCdcRandDelayDisable: begin
-        // If CDC randomization disabled, behave like a passthrough
-        en_passthru = 1'b1;
-      end
-      PrimCdcRandDelaySlow: begin
-        out_data_mask = '1;
-      end
-      PrimCdcRandDelayOnce: begin
-        void'(std::randomize(out_data_mask));
-      end
-      PrimCdcRandDelayInterval: begin
-        out_randomize_en = 1'b1;
-        en_rand_interval_mask = 1'b1;
-      end
-      PrimCdcRandDelayFull: begin
-        out_randomize_en = 1'b1;
-      end
-      default: begin
-        $fatal("%0d is an invalid randomization mode", prim_cdc_rand_mode);
-      end
-    endcase
-  end
-
-  // TODO: Run some performance experiments using this implementation versus an implementation that
-  //       primarily uses `forever` blocks rather than RTL constructs.
-  //       Need to also check if this alternate implementation is still valid when
-  //       compiling/simulating the design.
-  if (UseSourceClock) begin : gen_use_source_clock
-    // If relying on src_clk, insert a delay on the fastest clock
-    always_ff @(posedge src_clk or posedge dst_clk) begin
-      src_data_delayed <= src_data;
-    end
-    assign src_data_with_latency = src_data;
-  end else begin : gen_no_use_source_clock
-    // If not relying on src_clk, delay by a fixed number of ps determined by the module parameters
-    always_comb begin
-      src_data_with_latency <= #(prim_cdc_latency_ps * 1ps) src_data;
-    end
-
-    always_comb begin
-      src_data_delayed <= #(prim_cdc_jitter_ps * 1ps) src_data_with_latency;
-    end
-  end : gen_no_use_source_clock
-
-  // Randomize delayed random data selection only when input data changes
-  always @(src_data_with_latency) begin
-    if ((out_randomize_en && !en_rand_interval_mask) ||
-        (en_rand_interval_mask && counter == prim_cdc_num_src_data_changes) begin
-      for (int i = 0; i < DataWidth; i += 32) begin
-        // As of VCS 2017.12-SP2-6, it is slower to randomize for a DataWidth <= 32 with
-        // std::randomize() than using $urandom(), which may be more noticeable here as this module
-        // can potentially have a large number of instances.
-        //
-        // Whenever time permits, it will be interesting to run some perf tests with the current VCS
-        // version and see what updated performance looks like.
-        out_data_mask = (out_data_mask << 32) | $urandom();
-      end
-    end
-
-    if (en_rand_interval_mask) begin
-      counter <= (counter == prim_cdc_num_src_data_changes) ? 0 : counter + 1;
-    end
-  end
-
-  assign dst_data = (en_passthru) ?
-                    (src_data) :
-                    ((src_data_delayed & out_data_mask) | (src_data_with_latency & ~out_data_mask));
-
-  //TODO: coverage
-
-endmodule
diff --git a/prim_cipher_pkg.sv b/prim_cipher_pkg.sv
deleted file mode 100644
index 742c9253..00000000
--- a/prim_cipher_pkg.sv
+++ /dev/null
@@ -1,397 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// This package holds common constants and functions for PRESENT- and
-// PRINCE-based scrambling devices.
-//
-// See also: prim_present, prim_prince
-//
-// References: - https://en.wikipedia.org/wiki/PRESENT
-//             - https://en.wikipedia.org/wiki/Prince_(cipher)
-//             - http://www.lightweightcrypto.org/present/present_ches2007.pdf
-//             - https://eprint.iacr.org/2012/529.pdf
-//             - https://eprint.iacr.org/2015/372.pdf
-//             - https://eprint.iacr.org/2014/656.pdf
-
-package prim_cipher_pkg;
-
-  ///////////////////
-  // PRINCE Cipher //
-  ///////////////////
-
-  parameter logic [15:0][3:0] PRINCE_SBOX4 = {4'h4, 4'hD, 4'h5, 4'hE,
-                                              4'h0, 4'h8, 4'h7, 4'h6,
-                                              4'h1, 4'h9, 4'hC, 4'hA,
-                                              4'h2, 4'h3, 4'hF, 4'hB};
-
-  parameter logic [15:0][3:0] PRINCE_SBOX4_INV = {4'h1, 4'hC, 4'hE, 4'h5,
-                                                  4'h0, 4'h4, 4'h6, 4'hA,
-                                                  4'h9, 4'h8, 4'hD, 4'hF,
-                                                  4'h2, 4'h3, 4'h7, 4'hB};
-  // nibble permutations
-  parameter logic [15:0][3:0] PRINCE_SHIFT_ROWS64  = '{4'hF, 4'hA, 4'h5, 4'h0,
-                                                       4'hB, 4'h6, 4'h1, 4'hC,
-                                                       4'h7, 4'h2, 4'hD, 4'h8,
-                                                       4'h3, 4'hE, 4'h9, 4'h4};
-
-  parameter logic [15:0][3:0] PRINCE_SHIFT_ROWS64_INV = '{4'hF, 4'h2, 4'h5, 4'h8,
-                                                          4'hB, 4'hE, 4'h1, 4'h4,
-                                                          4'h7, 4'hA, 4'hD, 4'h0,
-                                                          4'h3, 4'h6, 4'h9, 4'hC};
-
-  // these are the round constants
-  parameter logic [11:0][63:0] PRINCE_ROUND_CONST = {64'hC0AC29B7C97C50DD,
-                                                     64'hD3B5A399CA0C2399,
-                                                     64'h64A51195E0E3610D,
-                                                     64'hC882D32F25323C54,
-                                                     64'h85840851F1AC43AA,
-                                                     64'h7EF84F78FD955CB1,
-                                                     64'hBE5466CF34E90C6C,
-                                                     64'h452821E638D01377,
-                                                     64'h082EFA98EC4E6C89,
-                                                     64'hA4093822299F31D0,
-                                                     64'h13198A2E03707344,
-                                                     64'h0000000000000000};
-
-  // tweak constant for key modification between enc/dec modes
-  parameter logic [63:0] PRINCE_ALPHA_CONST = 64'hC0AC29B7C97C50DD;
-
-  // masking constants for shift rows function below
-  parameter logic [15:0] PRINCE_SHIFT_ROWS_CONST0 = 16'h7BDE;
-  parameter logic [15:0] PRINCE_SHIFT_ROWS_CONST1 = 16'hBDE7;
-  parameter logic [15:0] PRINCE_SHIFT_ROWS_CONST2 = 16'hDE7B;
-  parameter logic [15:0] PRINCE_SHIFT_ROWS_CONST3 = 16'hE7BD;
-
-  // nibble shifts
-  function automatic logic [31:0] prince_shiftrows_32bit(logic [31:0]      state_in,
-                                                         logic [15:0][3:0] shifts );
-    logic [31:0] state_out;
-    // note that if simulation performance becomes an issue, this loop can be unrolled
-    for (int k = 0; k < 32/2; k++) begin
-      // operate on pairs of 2bit instead of nibbles
-      state_out[k*2  +: 2] = state_in[shifts[k]*2  +: 2];
-    end
-    return state_out;
-  endfunction : prince_shiftrows_32bit
-
-  function automatic logic [63:0] prince_shiftrows_64bit(logic [63:0]      state_in,
-                                                         logic [15:0][3:0] shifts );
-    logic [63:0] state_out;
-    // note that if simulation performance becomes an issue, this loop can be unrolled
-    for (int k = 0; k < 64/4; k++) begin
-      state_out[k*4  +: 4] = state_in[shifts[k]*4  +: 4];
-    end
-    return state_out;
-  endfunction : prince_shiftrows_64bit
-
-  // XOR reduction of four nibbles in a 16bit subvector
-  function automatic logic [3:0] prince_nibble_red16(logic [15:0] vect);
-    return vect[0 +: 4] ^ vect[4 +: 4] ^ vect[8 +: 4] ^ vect[12 +: 4];
-  endfunction : prince_nibble_red16
-
-  // M prime multiplication
-  function automatic logic [31:0] prince_mult_prime_32bit(logic [31:0] state_in);
-    logic [31:0] state_out;
-    // M0
-    state_out[0  +: 4] = prince_nibble_red16(state_in[ 0 +: 16] & PRINCE_SHIFT_ROWS_CONST3);
-    state_out[4  +: 4] = prince_nibble_red16(state_in[ 0 +: 16] & PRINCE_SHIFT_ROWS_CONST2);
-    state_out[8  +: 4] = prince_nibble_red16(state_in[ 0 +: 16] & PRINCE_SHIFT_ROWS_CONST1);
-    state_out[12 +: 4] = prince_nibble_red16(state_in[ 0 +: 16] & PRINCE_SHIFT_ROWS_CONST0);
-    // M1
-    state_out[16 +: 4] = prince_nibble_red16(state_in[16 +: 16] & PRINCE_SHIFT_ROWS_CONST0);
-    state_out[20 +: 4] = prince_nibble_red16(state_in[16 +: 16] & PRINCE_SHIFT_ROWS_CONST3);
-    state_out[24 +: 4] = prince_nibble_red16(state_in[16 +: 16] & PRINCE_SHIFT_ROWS_CONST2);
-    state_out[28 +: 4] = prince_nibble_red16(state_in[16 +: 16] & PRINCE_SHIFT_ROWS_CONST1);
-    return state_out;
-  endfunction : prince_mult_prime_32bit
-
-  // M prime multiplication
-  function automatic logic [63:0] prince_mult_prime_64bit(logic [63:0] state_in);
-    logic [63:0] state_out;
-    // M0
-    state_out[0  +: 4] = prince_nibble_red16(state_in[ 0 +: 16] & PRINCE_SHIFT_ROWS_CONST3);
-    state_out[4  +: 4] = prince_nibble_red16(state_in[ 0 +: 16] & PRINCE_SHIFT_ROWS_CONST2);
-    state_out[8  +: 4] = prince_nibble_red16(state_in[ 0 +: 16] & PRINCE_SHIFT_ROWS_CONST1);
-    state_out[12 +: 4] = prince_nibble_red16(state_in[ 0 +: 16] & PRINCE_SHIFT_ROWS_CONST0);
-    // M1
-    state_out[16 +: 4] = prince_nibble_red16(state_in[16 +: 16] & PRINCE_SHIFT_ROWS_CONST0);
-    state_out[20 +: 4] = prince_nibble_red16(state_in[16 +: 16] & PRINCE_SHIFT_ROWS_CONST3);
-    state_out[24 +: 4] = prince_nibble_red16(state_in[16 +: 16] & PRINCE_SHIFT_ROWS_CONST2);
-    state_out[28 +: 4] = prince_nibble_red16(state_in[16 +: 16] & PRINCE_SHIFT_ROWS_CONST1);
-    // M1
-    state_out[32 +: 4] = prince_nibble_red16(state_in[32 +: 16] & PRINCE_SHIFT_ROWS_CONST0);
-    state_out[36 +: 4] = prince_nibble_red16(state_in[32 +: 16] & PRINCE_SHIFT_ROWS_CONST3);
-    state_out[40 +: 4] = prince_nibble_red16(state_in[32 +: 16] & PRINCE_SHIFT_ROWS_CONST2);
-    state_out[44 +: 4] = prince_nibble_red16(state_in[32 +: 16] & PRINCE_SHIFT_ROWS_CONST1);
-    // M0
-    state_out[48 +: 4] = prince_nibble_red16(state_in[48 +: 16] & PRINCE_SHIFT_ROWS_CONST3);
-    state_out[52 +: 4] = prince_nibble_red16(state_in[48 +: 16] & PRINCE_SHIFT_ROWS_CONST2);
-    state_out[56 +: 4] = prince_nibble_red16(state_in[48 +: 16] & PRINCE_SHIFT_ROWS_CONST1);
-    state_out[60 +: 4] = prince_nibble_red16(state_in[48 +: 16] & PRINCE_SHIFT_ROWS_CONST0);
-    return state_out;
-  endfunction : prince_mult_prime_64bit
-
-
-  ////////////////////
-  // PRESENT Cipher //
-  ////////////////////
-
-  // this is the sbox from the present cipher
-  parameter logic [15:0][3:0] PRESENT_SBOX4 = {4'h2, 4'h1, 4'h7, 4'h4,
-                                               4'h8, 4'hF, 4'hE, 4'h3,
-                                               4'hD, 4'hA, 4'h0, 4'h9,
-                                               4'hB, 4'h6, 4'h5, 4'hC};
-
-  parameter logic [15:0][3:0] PRESENT_SBOX4_INV = {4'hA, 4'h9, 4'h7, 4'h0,
-                                                   4'h3, 4'h6, 4'h4, 4'hB,
-                                                   4'hD, 4'h2, 4'h1, 4'hC,
-                                                   4'h8, 4'hF, 4'hE, 4'h5};
-
-  // these are modified permutation indices for a 32bit version that
-  // follow the same pattern as for the 64bit version
-  parameter logic [31:0][4:0] PRESENT_PERM32 = {5'd31, 5'd23, 5'd15, 5'd07,
-                                                5'd30, 5'd22, 5'd14, 5'd06,
-                                                5'd29, 5'd21, 5'd13, 5'd05,
-                                                5'd28, 5'd20, 5'd12, 5'd04,
-                                                5'd27, 5'd19, 5'd11, 5'd03,
-                                                5'd26, 5'd18, 5'd10, 5'd02,
-                                                5'd25, 5'd17, 5'd09, 5'd01,
-                                                5'd24, 5'd16, 5'd08, 5'd00};
-
-  parameter logic [31:0][4:0] PRESENT_PERM32_INV = {5'd31, 5'd27, 5'd23, 5'd19,
-                                                    5'd15, 5'd11, 5'd07, 5'd03,
-                                                    5'd30, 5'd26, 5'd22, 5'd18,
-                                                    5'd14, 5'd10, 5'd06, 5'd02,
-                                                    5'd29, 5'd25, 5'd21, 5'd17,
-                                                    5'd13, 5'd09, 5'd05, 5'd01,
-                                                    5'd28, 5'd24, 5'd20, 5'd16,
-                                                    5'd12, 5'd08, 5'd04, 5'd00};
-
-  // these are the permutation indices of the present cipher
-  parameter logic [63:0][5:0] PRESENT_PERM64 = {6'd63, 6'd47, 6'd31, 6'd15,
-                                                6'd62, 6'd46, 6'd30, 6'd14,
-                                                6'd61, 6'd45, 6'd29, 6'd13,
-                                                6'd60, 6'd44, 6'd28, 6'd12,
-                                                6'd59, 6'd43, 6'd27, 6'd11,
-                                                6'd58, 6'd42, 6'd26, 6'd10,
-                                                6'd57, 6'd41, 6'd25, 6'd09,
-                                                6'd56, 6'd40, 6'd24, 6'd08,
-                                                6'd55, 6'd39, 6'd23, 6'd07,
-                                                6'd54, 6'd38, 6'd22, 6'd06,
-                                                6'd53, 6'd37, 6'd21, 6'd05,
-                                                6'd52, 6'd36, 6'd20, 6'd04,
-                                                6'd51, 6'd35, 6'd19, 6'd03,
-                                                6'd50, 6'd34, 6'd18, 6'd02,
-                                                6'd49, 6'd33, 6'd17, 6'd01,
-                                                6'd48, 6'd32, 6'd16, 6'd00};
-
-  parameter logic [63:0][5:0] PRESENT_PERM64_INV = {6'd63, 6'd59, 6'd55, 6'd51,
-                                                    6'd47, 6'd43, 6'd39, 6'd35,
-                                                    6'd31, 6'd27, 6'd23, 6'd19,
-                                                    6'd15, 6'd11, 6'd07, 6'd03,
-                                                    6'd62, 6'd58, 6'd54, 6'd50,
-                                                    6'd46, 6'd42, 6'd38, 6'd34,
-                                                    6'd30, 6'd26, 6'd22, 6'd18,
-                                                    6'd14, 6'd10, 6'd06, 6'd02,
-                                                    6'd61, 6'd57, 6'd53, 6'd49,
-                                                    6'd45, 6'd41, 6'd37, 6'd33,
-                                                    6'd29, 6'd25, 6'd21, 6'd17,
-                                                    6'd13, 6'd09, 6'd05, 6'd01,
-                                                    6'd60, 6'd56, 6'd52, 6'd48,
-                                                    6'd44, 6'd40, 6'd36, 6'd32,
-                                                    6'd28, 6'd24, 6'd20, 6'd16,
-                                                    6'd12, 6'd08, 6'd04, 6'd00};
-
-  // forward key schedule
-  function automatic logic [63:0] present_update_key64(logic [63:0] key_in,
-                                                       logic [4:0]  round_idx);
-    logic [63:0] key_out;
-    // rotate by 61 to the left
-    key_out = {key_in[63-61:0], key_in[63:64-61]};
-    // sbox on uppermost 4 bits
-    key_out[63 -: 4] = PRESENT_SBOX4[key_out[63 -: 4]];
-    // xor in round counter on bits 19 to 15
-    key_out[19:15] ^= round_idx;
-    return key_out;
-  endfunction : present_update_key64
-
-  function automatic logic [79:0] present_update_key80(logic [79:0] key_in,
-                                                       logic [4:0]  round_idx);
-    logic [79:0] key_out;
-    // rotate by 61 to the left
-    key_out = {key_in[79-61:0], key_in[79:80-61]};
-    // sbox on uppermost 4 bits
-    key_out[79 -: 4] = PRESENT_SBOX4[key_out[79 -: 4]];
-    // xor in round counter on bits 19 to 15
-    key_out[19:15] ^= round_idx;
-    return key_out;
-  endfunction : present_update_key80
-
-  function automatic logic [127:0] present_update_key128(logic [127:0] key_in,
-                                                         logic [4:0]   round_idx);
-    logic [127:0] key_out;
-    // rotate by 61 to the left
-    key_out = {key_in[127-61:0], key_in[127:128-61]};
-    // sbox on uppermost 4 bits
-    key_out[127 -: 4] = PRESENT_SBOX4[key_out[127 -: 4]];
-    // sbox on second nibble from top
-    key_out[123 -: 4] = PRESENT_SBOX4[key_out[123 -: 4]];
-    // xor in round counter on bits 66 to 62
-    key_out[66:62] ^= round_idx;
-    return key_out;
-  endfunction : present_update_key128
-
-
-  // inverse key schedule
-  function automatic logic [63:0] present_inv_update_key64(logic [63:0] key_in,
-                                                           logic [4:0]  round_idx);
-    logic [63:0] key_out = key_in;
-    // xor in round counter on bits 19 to 15
-    key_out[19:15] ^= round_idx;
-    // sbox on uppermost 4 bits
-    key_out[63 -: 4] = PRESENT_SBOX4_INV[key_out[63 -: 4]];
-    // rotate by 61 to the right
-    key_out = {key_out[60:0], key_out[63:61]};
-    return key_out;
-  endfunction : present_inv_update_key64
-
-  function automatic logic [79:0] present_inv_update_key80(logic [79:0] key_in,
-                                                           logic [4:0]  round_idx);
-    logic [79:0] key_out = key_in;
-    // xor in round counter on bits 19 to 15
-    key_out[19:15] ^= round_idx;
-    // sbox on uppermost 4 bits
-    key_out[79 -: 4] = PRESENT_SBOX4_INV[key_out[79 -: 4]];
-    // rotate by 61 to the right
-    key_out = {key_out[60:0], key_out[79:61]};
-    return key_out;
-  endfunction : present_inv_update_key80
-
-  function automatic logic [127:0] present_inv_update_key128(logic [127:0] key_in,
-                                                             logic [4:0]   round_idx);
-    logic [127:0] key_out = key_in;
-    // xor in round counter on bits 66 to 62
-    key_out[66:62] ^= round_idx;
-    // sbox on second highest nibble
-    key_out[123 -: 4] = PRESENT_SBOX4_INV[key_out[123 -: 4]];
-    // sbox on uppermost 4 bits
-    key_out[127 -: 4] = PRESENT_SBOX4_INV[key_out[127 -: 4]];
-    // rotate by 61 to the right
-    key_out = {key_out[60:0], key_out[127:61]};
-    return key_out;
-  endfunction : present_inv_update_key128
-
-
-  // these functions can be used to derive the DEC key from the ENC key by
-  // stepping the key by the correct number of rounds using the keyschedule functions above.
-  function automatic logic [63:0] present_get_dec_key64(logic [63:0] key_in,
-                                                        // total number of rounds employed
-                                                        logic [4:0]  round_cnt);
-    logic [63:0] key_out;
-    key_out = key_in;
-    for (int unsigned k = 0; k < round_cnt; k++) begin
-      key_out = present_update_key64(key_out, 5'(k + 1));
-    end
-    return key_out;
-  endfunction : present_get_dec_key64
-
-  function automatic logic [79:0] present_get_dec_key80(logic [79:0] key_in,
-                                                        // total number of rounds employed
-                                                        logic [4:0]  round_cnt);
-    logic [79:0] key_out;
-    key_out = key_in;
-    for (int unsigned k = 0; k < round_cnt; k++) begin
-      key_out = present_update_key80(key_out, 5'(k + 1));
-    end
-    return key_out;
-  endfunction : present_get_dec_key80
-
-  function automatic logic [127:0] present_get_dec_key128(logic [127:0] key_in,
-                                                          // total number of rounds employed
-                                                          logic [4:0]   round_cnt);
-    logic [127:0] key_out;
-    key_out = key_in;
-    for (int unsigned k = 0; k < round_cnt; k++) begin
-      key_out = present_update_key128(key_out, 5'(k + 1));
-    end
-    return key_out;
-  endfunction : present_get_dec_key128
-
-  /////////////////////////
-  // Common Subfunctions //
-  /////////////////////////
-
-  function automatic logic [7:0] sbox4_8bit(logic [7:0] state_in, logic [15:0][3:0] sbox4);
-    logic [7:0] state_out;
-    // note that if simulation performance becomes an issue, this loop can be unrolled
-    for (int k = 0; k < 8/4; k++) begin
-      state_out[k*4  +: 4] = sbox4[state_in[k*4  +: 4]];
-    end
-    return state_out;
-  endfunction : sbox4_8bit
-
-  function automatic logic [15:0] sbox4_16bit(logic [15:0] state_in, logic [15:0][3:0] sbox4);
-    logic [15:0] state_out;
-    // note that if simulation performance becomes an issue, this loop can be unrolled
-    for (int k = 0; k < 2; k++) begin
-      state_out[k*8  +: 8] = sbox4_8bit(state_in[k*8  +: 8], sbox4);
-    end
-    return state_out;
-  endfunction : sbox4_16bit
-
-  function automatic logic [31:0] sbox4_32bit(logic [31:0] state_in, logic [15:0][3:0] sbox4);
-    logic [31:0] state_out;
-    // note that if simulation performance becomes an issue, this loop can be unrolled
-    for (int k = 0; k < 4; k++) begin
-      state_out[k*8  +: 8] = sbox4_8bit(state_in[k*8  +: 8], sbox4);
-    end
-    return state_out;
-  endfunction : sbox4_32bit
-
-  function automatic logic [63:0] sbox4_64bit(logic [63:0] state_in, logic [15:0][3:0] sbox4);
-    logic [63:0] state_out;
-    // note that if simulation performance becomes an issue, this loop can be unrolled
-    for (int k = 0; k < 8; k++) begin
-      state_out[k*8  +: 8] = sbox4_8bit(state_in[k*8  +: 8], sbox4);
-    end
-    return state_out;
-  endfunction : sbox4_64bit
-
-  function automatic logic [7:0] perm_8bit(logic [7:0] state_in, logic [7:0][2:0] perm);
-    logic [7:0] state_out;
-    // note that if simulation performance becomes an issue, this loop can be unrolled
-    for (int k = 0; k < 8; k++) begin
-      state_out[perm[k]] = state_in[k];
-    end
-    return state_out;
-  endfunction : perm_8bit
-
-    function automatic logic [15:0] perm_16bit(logic [15:0] state_in, logic [15:0][3:0] perm);
-    logic [15:0] state_out;
-    // note that if simulation performance becomes an issue, this loop can be unrolled
-    for (int k = 0; k < 16; k++) begin
-      state_out[perm[k]] = state_in[k];
-    end
-    return state_out;
-  endfunction : perm_16bit
-
-  function automatic logic [31:0] perm_32bit(logic [31:0] state_in, logic [31:0][4:0] perm);
-    logic [31:0] state_out;
-    // note that if simulation performance becomes an issue, this loop can be unrolled
-    for (int k = 0; k < 32; k++) begin
-      state_out[perm[k]] = state_in[k];
-    end
-    return state_out;
-  endfunction : perm_32bit
-
-  function automatic logic [63:0] perm_64bit(logic [63:0] state_in, logic [63:0][5:0] perm);
-    logic [63:0] state_out;
-    // note that if simulation performance becomes an issue, this loop can be unrolled
-    for (int k = 0; k < 64; k++) begin
-      state_out[perm[k]] = state_in[k];
-    end
-    return state_out;
-  endfunction : perm_64bit
-
-endpackage : prim_cipher_pkg
diff --git a/prim_clock_div.sv b/prim_clock_div.sv
deleted file mode 100644
index 4c2dcb45..00000000
--- a/prim_clock_div.sv
+++ /dev/null
@@ -1,120 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-
-`include "prim_assert.sv"
-
-module prim_clock_div #(
-  parameter int Divisor = 2,
-  parameter logic ResetValue = 0
-) (
-  input clk_i,
-  input rst_ni,
-  input step_down_req_i, // step down divisor by 2x
-  output logic step_down_ack_o, // step down acknowledge
-  input test_en_i,
-  output logic clk_o
-);
-
-
-  // Only even divide is supported at the moment
-  // For odd divide we need to introduce more parameters to control duty cycle
-  `ASSERT_INIT(DivEven_A, (Divisor % 2) == 0)
-
-  // It is assumed the flops in this module are NOT on the scan-chain, as a result only
-  // the input values are guarded
-  logic step_down_req;
-  assign step_down_req = test_en_i ? '0 : step_down_req_i;
-
-  logic clk_int;
-
-  if (Divisor == 2) begin : gen_div2
-    logic q_p, q_n;
-
-    prim_flop # (
-      .Width(1),
-      .ResetValue(ResetValue)
-    ) u_div2 (
-      .clk_i,
-      .rst_ni,
-      .d_i(q_n),
-      .q_o(q_p)
-    );
-
-    prim_clock_inv # (
-      .HasScanMode(1'b0)
-    ) u_inv (
-      .clk_i(q_p),
-      .scanmode_i('0),
-      .clk_no(q_n)
-    );
-
-    logic step_down_nq;
-    always_ff @(negedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-        step_down_nq <= 1'b0;
-      end else begin
-        step_down_nq <= step_down_req;
-      end
-    end
-
-    // make sure selection point is away from both edges
-    prim_clock_mux2 #(
-      .NoFpgaBufG(1'b1)
-    ) u_step_down_mux (
-      .clk0_i(q_p),
-      .clk1_i(clk_i),
-      .sel_i(step_down_nq),
-      .clk_o(clk_int)
-    );
-
-  assign step_down_ack_o = step_down_nq;
-
-  end else begin : gen_div
-
-    localparam int ToggleCnt = Divisor / 2;
-    localparam int CntWidth = $clog2(ToggleCnt);
-    logic [CntWidth-1:0] cnt;
-    logic [CntWidth-1:0] limit;
-
-    assign limit = !step_down_req       ? CntWidth'(ToggleCnt - 1) :
-                   (ToggleCnt / 2) == 2 ? '0 : CntWidth'((ToggleCnt / 2) - 1);
-
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-        cnt <= '0;
-        clk_int <= ResetValue;
-      end else if (cnt >= limit) begin
-        cnt <= '0;
-        clk_int <= ~clk_o;
-      end else begin
-        cnt <= cnt + 1'b1;
-      end
-    end
-
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-        step_down_ack_o <= 1'b0;
-      end else begin
-        step_down_ack_o <= step_down_req;
-      end
-    end
-  end
-
-  // anchor points for constraints
-  logic clk_muxed;
-  prim_clock_mux2 #(
-    .NoFpgaBufG(1'b1)
-  ) u_clk_mux (
-    .clk0_i(clk_int),
-    .clk1_i(clk_i),
-    .sel_i('0),
-    .clk_o(clk_muxed)
-  );
-
-  prim_clock_buf u_clk_div_buf (
-    .clk_i(clk_muxed),
-    .clk_o
-  );
-
-endmodule
diff --git a/prim_clock_gating_sync.sv b/prim_clock_gating_sync.sv
deleted file mode 100644
index bcc8f75f..00000000
--- a/prim_clock_gating_sync.sv
+++ /dev/null
@@ -1,34 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Common Library: Clock Gating cell with synchronizer
-
-module prim_clock_gating_sync (
-  input        clk_i,
-  input        rst_ni,
-  input        test_en_i,
-  input        async_en_i,
-  output logic en_o,
-  output logic clk_o
-);
-
-
-  prim_flop_2sync #(
-    .Width(1)
-  ) i_sync (
-    .clk_i,
-    .rst_ni,
-    .d_i(async_en_i),
-    .q_o(en_o)
-  );
-
-  prim_clock_gating i_cg (
-    .clk_i,
-    .en_i(en_o),
-    .test_en_i,
-    .clk_o
-  );
-
-
-endmodule
diff --git a/prim_clock_meas.sv b/prim_clock_meas.sv
deleted file mode 100644
index 613f1738..00000000
--- a/prim_clock_meas.sv
+++ /dev/null
@@ -1,209 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// prim_clk_meas is a generic module that measures two clocks against each other.
-// One clock is the reference, and another is the input.
-// If the input clocks becomes too fast or too slow, an error condition is created.
-
-// The default parameters assume the reference clock is significantly slower than
-// the input clock
-
-
-`include "prim_assert.sv"
-
-module prim_clock_meas #(
-  // Maximum value of input clock counts over measurement period
-  parameter int Cnt = 16,
-  // Maximum value of reference clock counts over measurement period
-  parameter int RefCnt = 1,
-  parameter bit ClkTimeOutChkEn = 1,
-  parameter bit RefTimeOutChkEn = 1,
-  localparam int CntWidth = prim_util_pkg::vbits(Cnt),
-  localparam int RefCntWidth = prim_util_pkg::vbits(RefCnt)
-) (
-  input clk_i,
-  input rst_ni,
-  input clk_ref_i,
-  input rst_ref_ni,
-  input en_i,
-  input [CntWidth-1:0] max_cnt,
-  input [CntWidth-1:0] min_cnt,
-  // the output valid and fast/slow indications are all on the
-  // input clock domain
-  output logic valid_o,
-  output logic fast_o,
-  output logic slow_o,
-
-  // signal on clk_i domain that indicates clk_ref has timed out
-  output logic timeout_clk_ref_o,
-
-  // signal on clk_ref_i domain that indicates clk has timed out
-  output logic ref_timeout_clk_o
-);
-
-  //////////////////////////
-  // Reference clock logic
-  //////////////////////////
-
-  logic ref_en;
-  prim_flop_2sync #(
-    .Width(1)
-  ) u_ref_meas_en_sync (
-    .d_i(en_i),
-    .clk_i(clk_ref_i),
-    .rst_ni(rst_ref_ni),
-    .q_o(ref_en)
-  );
-
-  logic ref_valid;
-  logic [RefCntWidth-1:0] ref_cnt;
-  always_ff @(posedge clk_ref_i or negedge rst_ref_ni) begin
-    if (!rst_ref_ni) begin
-      ref_cnt <= '0;
-      ref_valid <= '0;
-    end else if (!ref_en && |ref_cnt) begin
-      ref_cnt <= '0;
-      ref_valid <= '0;
-    end else if (ref_en && (ref_cnt == RefCnt - 1)) begin
-      // restart count and measure
-      ref_cnt <= '0;
-      ref_valid <= 1'b1;
-    end else if (ref_en) begin
-      ref_cnt <= ref_cnt + 1'b1;
-      ref_valid <= 1'b0;
-    end
-  end
-
-
-  //////////////////////////
-  // Input Clock Logic
-  //////////////////////////
-
-
-  logic valid;
-
-  // The valid pulse causes the count to reset and start counting again
-  // for each reference cycle.
-  // The count obtained during the the last refernece cycle is then used
-  // to measure how fast/slow the input clock is.
-  prim_pulse_sync u_sync_ref (
-    .clk_src_i(clk_ref_i),
-    .rst_src_ni(rst_ref_ni),
-    .src_pulse_i(ref_valid),
-    .clk_dst_i(clk_i),
-    .rst_dst_ni(rst_ni),
-    .dst_pulse_o(valid)
-  );
-
-  logic cnt_en;
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      cnt_en <= '0;
-    end else if (!en_i) begin
-      cnt_en <= '0;
-    end else if (en_i && valid) begin
-      cnt_en <= 1'b1;
-    end
-  end
-
-  logic cnt_ovfl;
-  logic [CntWidth-1:0] cnt;
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      cnt <= '0;
-      cnt_ovfl <= '0;
-    end else if (!cnt_en && |cnt) begin
-      cnt <= '0;
-      cnt_ovfl <= '0;
-    end else if (valid_o) begin
-      cnt <= '0;
-      cnt_ovfl <= '0;
-    end else if (cnt_en && cnt_ovfl) begin
-      cnt <= '{default: '1};
-    end else if (cnt_en) begin
-      {cnt_ovfl, cnt} <= cnt + 1'b1;
-    end
-  end
-
-  assign valid_o = en_i & valid & |cnt;
-  assign fast_o = valid_o & ((cnt > max_cnt) | cnt_ovfl);
-  assign slow_o = valid_o & (cnt < min_cnt);
-
-  //////////////////////////
-  // Timeout Handling
-  //////////////////////////
-
-  localparam bit TimeOutChkEn = ClkTimeOutChkEn | RefTimeOutChkEn;
-
-  // determine ratio between
-  localparam int ClkRatio = Cnt / RefCnt;
-
-  // maximum cdc latency from the perspective of the measured clock
-  // 1 cycle to output request
-  // 2 ref cycles for synchronization
-  // 1 ref cycle to send ack
-  // 2 cycles to sync ack
-  // Double for margin
-  localparam int MaxClkCdcLatency = (1 + 2*ClkRatio + 1*ClkRatio + 2)*2;
-
-  // maximum cdc latency from the perspective of the reference clock
-  // 1 ref cycle to output request
-  // 2 cycles to sync + 1 cycle to ack are less than 1 cycle of ref based on assertion requirement
-  // 2 ref cycles to sync ack
-  // 2 extra ref cycles for margin
-  localparam int MaxRefCdcLatency = 1 + 1 + 2 + 2;
-
-  if (RefTimeOutChkEn) begin : gen_ref_timeout_chk
-    // check whether reference clock has timed out
-    prim_clock_timeout #(
-      .TimeOutCnt(MaxClkCdcLatency)
-    ) u_timeout_clk_to_ref (
-      .clk_chk_i(clk_ref_i),
-      .rst_chk_ni(rst_ref_ni),
-      .clk_i,
-      .rst_ni,
-      .en_i,
-      .timeout_o(timeout_clk_ref_o)
-    );
-  end else begin : gen_unused_ref_timeout
-    assign timeout_clk_ref_o = 1'b0;
-  end
-
-  if (ClkTimeOutChkEn) begin : gen_clk_timeout_chk
-    // check whether clock has timed out
-    prim_clock_timeout #(
-      .TimeOutCnt(MaxRefCdcLatency)
-    ) u_timeout_ref_to_clk (
-      .clk_chk_i(clk_i),
-      .rst_chk_ni(rst_ni),
-      .clk_i(clk_ref_i),
-      .rst_ni(rst_ref_ni),
-      .en_i(ref_en),
-      .timeout_o(ref_timeout_clk_o)
-    );
-  end else begin : gen_unused_clk_timeout
-    assign ref_timeout_clk_o = 1'b0;
-  end
-
-
-  //////////////////////////
-  // Assertions
-  //////////////////////////
-
-  if (TimeOutChkEn) begin : gen_timeout_assert
-    // the measured clock must be faster than the reference clock
-    `ASSERT_INIT(ClkRatios_A, ClkRatio > 2)
-  end
-
-  // reference count has to be at least 1
-  `ASSERT_INIT(RefCntVal_A, RefCnt >= 1)
-
-  // if we've reached the max count, enable must be 0 next.
-  // Otherwise the width of the counter is too small to accommodate the usecase
-  `ASSERT(MaxWidth_A, (cnt == Cnt-1) |=> !cnt_en )
-
-
-
-
-endmodule // prim_clk_meas
diff --git a/prim_clock_timeout.sv b/prim_clock_timeout.sv
deleted file mode 100644
index df3b3ace..00000000
--- a/prim_clock_timeout.sv
+++ /dev/null
@@ -1,65 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// prim_clk_timeout is a simple module that assesses whether the input clock
-// has stopped ticking as measured by the reference clock.
-//
-// If both clocks are stopped for whatever reason, this module is effectively dead.
-
-`include "prim_assert.sv"
-
-module prim_clock_timeout #(
-  parameter int TimeOutCnt = 16,
-  localparam int CntWidth = prim_util_pkg::vbits(TimeOutCnt+1)
-) (
-  // clock to be checked
-  input clk_chk_i,
-  input rst_chk_ni,
-
-  // clock used to measure whether clk_chk has stopped ticking
-  input clk_i,
-  input rst_ni,
-  input en_i,
-  output logic timeout_o
-);
-
-  logic [CntWidth-1:0] cnt;
-  logic ack;
-  logic timeout;
-  assign timeout = cnt >= TimeOutCnt;
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      cnt <= '0;
-    end else if (ack || !en_i) begin
-      cnt <= '0;
-    end else if (timeout) begin
-      cnt <= '{default: '1};
-    end else if (en_i) begin
-      cnt <= cnt + 1'b1;
-    end
-  end
-
-  logic chk_req;
-  prim_sync_reqack u_ref_timeout (
-    .clk_src_i(clk_i),
-    .rst_src_ni(rst_ni),
-    .clk_dst_i(clk_chk_i),
-    .rst_dst_ni(rst_chk_ni),
-    .req_chk_i('0),
-    .src_req_i(1'b1),
-    .src_ack_o(ack),
-    .dst_req_o(chk_req),
-    .dst_ack_i(chk_req)
-  );
-
-  prim_flop #(
-    .ResetValue('0)
-  ) u_out (
-    .clk_i,
-    .rst_ni,
-    .d_i(timeout),
-    .q_o(timeout_o)
-  );
-
-endmodule // prim_clk_timeout
diff --git a/prim_count.sv b/prim_count.sv
deleted file mode 100644
index 79888991..00000000
--- a/prim_count.sv
+++ /dev/null
@@ -1,212 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Primitive hardened counter module
-//
-// This module implements two styles of hardened counting
-// 1. Duplicate count
-//    There are two copies of the relevant counter and they are constantly compared.
-// 2. Cross count
-//    There is an up count and a down count, and the combined value must always
-//    combine to the same value.
-//
-// This counter supports a generic clr / set / en interface, where
-// clr_i and set_i MUST NOT be set at the same time!
-//
-// In duplicate count mode
-//    - clr_i sets all (internal) counters to 0.
-//    - set_i sets the up_count's starting value to set_cnt_i.
-//      Note: the max_val is just the max possible value given by the counter's width.
-//    - en_i increments the counter by step_i, if neither of the above is set.
-//
-// In cross count mode
-//    - clr_i sets
-//      -- the down_count to 0.
-//      -- the up_count's max_val to the max possible value given by the counter's width.
-//    - set_i sets
-//      -- the up_count to 0 and the down_count to set_cnt_i,
-//      -- the up_count's max_val to set_cnt_i.
-//    - en_i increments/decrements the up_count/down_count by step_i, if neither of the above is
-//      set.
-
-module prim_count import prim_count_pkg::*; #(
-  parameter int Width = 2,
-  parameter bit OutSelDnCnt = 1, // 0 selects up count
-  parameter prim_count_style_e CntStyle = CrossCnt, // DupCnt or CrossCnt
-  // This should only be disabled in special circumstances, for example
-  // in non-comportable IPs where an error does not trigger an alert.
-  parameter bit EnableAlertTriggerSVA = 1
-) (
-  input clk_i,
-  input rst_ni,
-  input clr_i,
-  input set_i,
-  input [Width-1:0] set_cnt_i,
-  input en_i,
-  input [Width-1:0] step_i, // increment/decrement step when enabled
-  output logic [Width-1:0] cnt_o,
-  output logic err_o
-);
-
-  // if output selects down count, it MUST be the cross count style
-  `ASSERT_INIT(CntStyleMatch_A, OutSelDnCnt ? CntStyle == CrossCnt : 1'b1)
-
-  localparam int CntCopies = (CntStyle == DupCnt) ? 2 : 1;
-
-  // clear up count whenever there is an explicit clear, or
-  // when the max value is re-set during cross count.
-  logic clr_up_cnt;
-  assign clr_up_cnt = clr_i |
-                      (set_i & (CntStyle == CrossCnt));
-
-  // set up count to desired value only during duplicate counts.
-  logic set_up_cnt;
-  assign set_up_cnt = set_i & (CntStyle == DupCnt);
-
-  logic [CntCopies-1:0][Width-1:0] up_cnt_d, up_cnt_d_buf;
-  logic [CntCopies-1:0][Width-1:0] up_cnt_q;
-  logic [Width-1:0] max_val;
-  logic err;
-
-  if (CntStyle == CrossCnt) begin : gen_crosscnt_max_val
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-        max_val <= '1;
-      end else if (clr_i) begin
-        max_val <= '1;
-      end else if (set_i) begin
-        max_val <= set_cnt_i;
-      end
-    end
-  end else begin : gen_dupcnt_max_val
-     assign max_val = '1;
-  end
-
-  for (genvar i = 0; i < CntCopies; i++) begin : gen_cnts
-    // up-count
-    assign up_cnt_d[i] = (clr_up_cnt)                     ? '0 :
-                         (set_up_cnt)                     ? set_cnt_i :
-                         (en_i & (up_cnt_q[i] < max_val)) ? up_cnt_q[i] + step_i :
-                                                          up_cnt_q[i];
-
-    prim_buf #(
-      .Width(Width)
-    ) u_buf (
-      .in_i(up_cnt_d[i]),
-      .out_o(up_cnt_d_buf[i])
-    );
-
-    prim_flop #(
-      .Width(Width),
-      .ResetValue('0)
-    ) u_cnt_flop (
-      .clk_i,
-      .rst_ni,
-      .d_i(up_cnt_d_buf[i]),
-      .q_o(up_cnt_q[i])
-    );
-  end
-
-  if (CntStyle == CrossCnt) begin : gen_cross_cnt_hardening
-    logic [Width-1:0] down_cnt;
-    logic [Width-1:0] sum;
-
-    // down-count
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-        down_cnt <= '{default: '1};
-      end else if (clr_i) begin
-        down_cnt <= '{default: '1};
-      end else if (set_i) begin
-        down_cnt <= set_cnt_i;
-      end else if (en_i && (down_cnt > '0)) begin
-        down_cnt <= down_cnt - step_i;
-      end
-    end
-
-    logic msb;
-    assign {msb, sum} = down_cnt + up_cnt_q[0];
-    assign cnt_o = OutSelDnCnt ? down_cnt : up_cnt_q[0];
-    assign err   = (max_val != sum) | msb;
-
-    `ASSERT(CrossCntErrForward_A,
-            ((down_cnt + up_cnt_q[0]) != {1'b0, max_val}) |-> err_o)
-    `ASSERT(CrossCntErrBackward_A, err_o |->
-            ((down_cnt + up_cnt_q[0]) != {1'b0, max_val}))
-
-    // Down counter assumption to control underflow
-    // We can also constrain the down counter underflow via `down_cnt % step_i == 0`.
-    // However, modulo operation can be very complex for formal analysis.
-    `ASSUME(DownCntStepInt_A, down_cnt == 0 || down_cnt >= step_i)
-
-    // Up counter assumption to control overflow
-      logic [Width:0] unused_cnt;
-      assign unused_cnt = up_cnt_q[0] + step_i;
-      logic unused_incr_cnt;
-      assign unused_incr_cnt = !clr_i & !set_i & en_i;
-
-      `ASSUME(UpCntOverFlow_A, unused_incr_cnt && !err |-> ~unused_cnt[Width])
-
-  end else if (CntStyle == DupCnt) begin : gen_dup_cnt_hardening
-    // duplicate count compare is always valid
-    assign cnt_o = up_cnt_q[0];
-    assign err   = (up_cnt_q[0] != up_cnt_q[1]);
-
-    `ASSERT(DupCntErrForward_A,  up_cnt_q[0] != up_cnt_q[1] |-> err_o)
-    `ASSERT(DupCntErrBackward_A, err_o |-> up_cnt_q[0] != up_cnt_q[1])
-  end
-
-  assign err_o = err;
-
-  // ASSERTIONS AND ASSUMPTIONS
-  `ifdef INC_ASSERT
-  // Helper variables to hold the previous valid `cnt_o` and `step_i` when `en_i` is set.
-  logic [Width-1:0] past_cnt_o, past_step_i;
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      past_cnt_o  <= cnt_o;
-      past_step_i <= step_i;
-    end else if (en_i) begin
-      past_cnt_o  <= cnt_o;
-      past_step_i <= step_i;
-    end
-  end
-  `endif
-
-  // Clear and set should not be seen at the same time
-  `ASSUME(SimulClrSet_A, clr_i || set_i |-> clr_i != set_i)
-
-  // when the counter is forced by TB, it can be any value, but we should see err_o is set.
-  `ASSERT(OutClr_A, clr_i |=> (OutSelDnCnt ? &cnt_o : cnt_o == 0) || err_o)
-
-  // When `en_i` is set without `clr_i` and `set_i`, and counter does not reach max/min value,
-  // we expect `cnt_o` to increment or decrement base on `step_i`, or error occurs
-  `ASSERT(OutStep_A,
-          !(clr_i ||set_i) throughout en_i ##[1:$] en_i && max_val > cnt_o && cnt_o > 0 |->
-          ((CntStyle == DupCnt || !OutSelDnCnt) ? cnt_o - past_cnt_o == past_step_i :
-           past_cnt_o - cnt_o == past_step_i) || err_o)
-
-  // When `set_i` is set, at next clock cycle:
-  // 1). For duplicate counter, sets the `cnt_o` to `set_cnt_i`.
-  // 2). For cross up counter, sets the `max_value` to `set_cnt_i`.
-  // 3). For cross down counter, sets the `cnt_o` and `max_value` to `set_cnt_i`.
-  // 4). error occurs due to a fault injection
-  `ASSERT(OutSet_A, ##1 set_i |=>
-          ((CntStyle == DupCnt || OutSelDnCnt) ? cnt_o == $past(set_cnt_i) : cnt_o == 0) || err_o)
-
-  // If the up counter reaches its max value, the value won't increment or change, unless there is
-  // a fault injection
-  `ASSERT(MaxUpCntStable_A, up_cnt_q[0] == max_val && !clr_i && !set_i |=>
-          $stable(up_cnt_q[0]) || err_o || $past(err_o))
-
-  // This logic that will be assign to one, when user adds macro
-  // ASSERT_PRIM_COUNT_ERROR_TRIGGER_ALERT to check the error with alert, in case that prim_count
-  // is used in design without adding this assertion check.
-  `ifdef INC_ASSERT
-  logic unused_assert_connected;
-
-  `ASSERT_INIT_NET(AssertConnected_A, unused_assert_connected === 1'b1 || !EnableAlertTriggerSVA)
-  `endif
-endmodule // prim_count
-
diff --git a/prim_count_pkg.sv b/prim_count_pkg.sv
deleted file mode 100644
index f49a270c..00000000
--- a/prim_count_pkg.sv
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Package for primitive hardened counter module
-//
-
-package prim_count_pkg;
-
-  // Enumeration for hardened count style
-  typedef enum logic {
-    CrossCnt, // up count and down count
-    DupCnt    // duplicate counters
-  } prim_count_style_e;
-
-  // Enumeration for differential valid
-  typedef enum logic [1:0] {
-    CmpInvalid = 2'b01,
-    CmpValid   = 2'b10
-  } cmp_valid_e;
-
-endpackage //
diff --git a/prim_crc32.sv b/prim_crc32.sv
deleted file mode 100644
index 762fd48c..00000000
--- a/prim_crc32.sv
+++ /dev/null
@@ -1,324 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// CRC32 calculator
-//
-// This module takes in n-bits data words (n defined by BytePerWord parameter) and updates an
-// internally stored CRC with each valid data word. The polynomial used is the standard CRC32 IEEE
-// one. An interface is provided to set the internal CRC to an arbitrary value. The output CRC is an
-// inverted version of the internally stored CRC and the input CRC is inverted before being stored.
-// This is done so results match existing widely used software libraries (e.g. the crc32
-// functionality available in Python). Note that a initial CRC of 0x0 (corresponding to an internal
-// CRC of 0xffffffff) must be used to match results generated elsewhere.
-
-
-module prim_crc32 #(
-  parameter int unsigned BytesPerWord = 4
-) (
-  input  logic                      clk_i,
-  input  logic                      rst_ni,
-
-  input  logic                      set_crc_i,
-  input  logic [31:0]               crc_in_i,
-
-  input  logic                      data_valid_i,
-  input  logic [BytesPerWord*8-1:0] data_i,
-
-  output logic [31:0]               crc_out_o
-);
-  // Generated using hw/ip/prim/util/prim_crc32_table_gen.py
-  function automatic logic [31:0] crc32_byte_calc(logic [7:0] b);
-    unique case (b)
-      8'hff:   crc32_byte_calc = 32'h2d02ef8d;
-      8'hfe:   crc32_byte_calc = 32'h5a05df1b;
-      8'hfd:   crc32_byte_calc = 32'hc30c8ea1;
-      8'hfc:   crc32_byte_calc = 32'hb40bbe37;
-      8'hfb:   crc32_byte_calc = 32'h2a6f2b94;
-      8'hfa:   crc32_byte_calc = 32'h5d681b02;
-      8'hf9:   crc32_byte_calc = 32'hc4614ab8;
-      8'hf8:   crc32_byte_calc = 32'hb3667a2e;
-      8'hf7:   crc32_byte_calc = 32'h23d967bf;
-      8'hf6:   crc32_byte_calc = 32'h54de5729;
-      8'hf5:   crc32_byte_calc = 32'hcdd70693;
-      8'hf4:   crc32_byte_calc = 32'hbad03605;
-      8'hf3:   crc32_byte_calc = 32'h24b4a3a6;
-      8'hf2:   crc32_byte_calc = 32'h53b39330;
-      8'hf1:   crc32_byte_calc = 32'hcabac28a;
-      8'hf0:   crc32_byte_calc = 32'hbdbdf21c;
-      8'hef:   crc32_byte_calc = 32'h30b5ffe9;
-      8'hee:   crc32_byte_calc = 32'h47b2cf7f;
-      8'hed:   crc32_byte_calc = 32'hdebb9ec5;
-      8'hec:   crc32_byte_calc = 32'ha9bcae53;
-      8'heb:   crc32_byte_calc = 32'h37d83bf0;
-      8'hea:   crc32_byte_calc = 32'h40df0b66;
-      8'he9:   crc32_byte_calc = 32'hd9d65adc;
-      8'he8:   crc32_byte_calc = 32'haed16a4a;
-      8'he7:   crc32_byte_calc = 32'h3e6e77db;
-      8'he6:   crc32_byte_calc = 32'h4969474d;
-      8'he5:   crc32_byte_calc = 32'hd06016f7;
-      8'he4:   crc32_byte_calc = 32'ha7672661;
-      8'he3:   crc32_byte_calc = 32'h3903b3c2;
-      8'he2:   crc32_byte_calc = 32'h4e048354;
-      8'he1:   crc32_byte_calc = 32'hd70dd2ee;
-      8'he0:   crc32_byte_calc = 32'ha00ae278;
-      8'hdf:   crc32_byte_calc = 32'h166ccf45;
-      8'hde:   crc32_byte_calc = 32'h616bffd3;
-      8'hdd:   crc32_byte_calc = 32'hf862ae69;
-      8'hdc:   crc32_byte_calc = 32'h8f659eff;
-      8'hdb:   crc32_byte_calc = 32'h11010b5c;
-      8'hda:   crc32_byte_calc = 32'h66063bca;
-      8'hd9:   crc32_byte_calc = 32'hff0f6a70;
-      8'hd8:   crc32_byte_calc = 32'h88085ae6;
-      8'hd7:   crc32_byte_calc = 32'h18b74777;
-      8'hd6:   crc32_byte_calc = 32'h6fb077e1;
-      8'hd5:   crc32_byte_calc = 32'hf6b9265b;
-      8'hd4:   crc32_byte_calc = 32'h81be16cd;
-      8'hd3:   crc32_byte_calc = 32'h1fda836e;
-      8'hd2:   crc32_byte_calc = 32'h68ddb3f8;
-      8'hd1:   crc32_byte_calc = 32'hf1d4e242;
-      8'hd0:   crc32_byte_calc = 32'h86d3d2d4;
-      8'hcf:   crc32_byte_calc = 32'h0bdbdf21;
-      8'hce:   crc32_byte_calc = 32'h7cdcefb7;
-      8'hcd:   crc32_byte_calc = 32'he5d5be0d;
-      8'hcc:   crc32_byte_calc = 32'h92d28e9b;
-      8'hcb:   crc32_byte_calc = 32'h0cb61b38;
-      8'hca:   crc32_byte_calc = 32'h7bb12bae;
-      8'hc9:   crc32_byte_calc = 32'he2b87a14;
-      8'hc8:   crc32_byte_calc = 32'h95bf4a82;
-      8'hc7:   crc32_byte_calc = 32'h05005713;
-      8'hc6:   crc32_byte_calc = 32'h72076785;
-      8'hc5:   crc32_byte_calc = 32'heb0e363f;
-      8'hc4:   crc32_byte_calc = 32'h9c0906a9;
-      8'hc3:   crc32_byte_calc = 32'h026d930a;
-      8'hc2:   crc32_byte_calc = 32'h756aa39c;
-      8'hc1:   crc32_byte_calc = 32'hec63f226;
-      8'hc0:   crc32_byte_calc = 32'h9b64c2b0;
-      8'hbf:   crc32_byte_calc = 32'h5bdeae1d;
-      8'hbe:   crc32_byte_calc = 32'h2cd99e8b;
-      8'hbd:   crc32_byte_calc = 32'hb5d0cf31;
-      8'hbc:   crc32_byte_calc = 32'hc2d7ffa7;
-      8'hbb:   crc32_byte_calc = 32'h5cb36a04;
-      8'hba:   crc32_byte_calc = 32'h2bb45a92;
-      8'hb9:   crc32_byte_calc = 32'hb2bd0b28;
-      8'hb8:   crc32_byte_calc = 32'hc5ba3bbe;
-      8'hb7:   crc32_byte_calc = 32'h5505262f;
-      8'hb6:   crc32_byte_calc = 32'h220216b9;
-      8'hb5:   crc32_byte_calc = 32'hbb0b4703;
-      8'hb4:   crc32_byte_calc = 32'hcc0c7795;
-      8'hb3:   crc32_byte_calc = 32'h5268e236;
-      8'hb2:   crc32_byte_calc = 32'h256fd2a0;
-      8'hb1:   crc32_byte_calc = 32'hbc66831a;
-      8'hb0:   crc32_byte_calc = 32'hcb61b38c;
-      8'haf:   crc32_byte_calc = 32'h4669be79;
-      8'hae:   crc32_byte_calc = 32'h316e8eef;
-      8'had:   crc32_byte_calc = 32'ha867df55;
-      8'hac:   crc32_byte_calc = 32'hdf60efc3;
-      8'hab:   crc32_byte_calc = 32'h41047a60;
-      8'haa:   crc32_byte_calc = 32'h36034af6;
-      8'ha9:   crc32_byte_calc = 32'haf0a1b4c;
-      8'ha8:   crc32_byte_calc = 32'hd80d2bda;
-      8'ha7:   crc32_byte_calc = 32'h48b2364b;
-      8'ha6:   crc32_byte_calc = 32'h3fb506dd;
-      8'ha5:   crc32_byte_calc = 32'ha6bc5767;
-      8'ha4:   crc32_byte_calc = 32'hd1bb67f1;
-      8'ha3:   crc32_byte_calc = 32'h4fdff252;
-      8'ha2:   crc32_byte_calc = 32'h38d8c2c4;
-      8'ha1:   crc32_byte_calc = 32'ha1d1937e;
-      8'ha0:   crc32_byte_calc = 32'hd6d6a3e8;
-      8'h9f:   crc32_byte_calc = 32'h60b08ed5;
-      8'h9e:   crc32_byte_calc = 32'h17b7be43;
-      8'h9d:   crc32_byte_calc = 32'h8ebeeff9;
-      8'h9c:   crc32_byte_calc = 32'hf9b9df6f;
-      8'h9b:   crc32_byte_calc = 32'h67dd4acc;
-      8'h9a:   crc32_byte_calc = 32'h10da7a5a;
-      8'h99:   crc32_byte_calc = 32'h89d32be0;
-      8'h98:   crc32_byte_calc = 32'hfed41b76;
-      8'h97:   crc32_byte_calc = 32'h6e6b06e7;
-      8'h96:   crc32_byte_calc = 32'h196c3671;
-      8'h95:   crc32_byte_calc = 32'h806567cb;
-      8'h94:   crc32_byte_calc = 32'hf762575d;
-      8'h93:   crc32_byte_calc = 32'h6906c2fe;
-      8'h92:   crc32_byte_calc = 32'h1e01f268;
-      8'h91:   crc32_byte_calc = 32'h8708a3d2;
-      8'h90:   crc32_byte_calc = 32'hf00f9344;
-      8'h8f:   crc32_byte_calc = 32'h7d079eb1;
-      8'h8e:   crc32_byte_calc = 32'h0a00ae27;
-      8'h8d:   crc32_byte_calc = 32'h9309ff9d;
-      8'h8c:   crc32_byte_calc = 32'he40ecf0b;
-      8'h8b:   crc32_byte_calc = 32'h7a6a5aa8;
-      8'h8a:   crc32_byte_calc = 32'h0d6d6a3e;
-      8'h89:   crc32_byte_calc = 32'h94643b84;
-      8'h88:   crc32_byte_calc = 32'he3630b12;
-      8'h87:   crc32_byte_calc = 32'h73dc1683;
-      8'h86:   crc32_byte_calc = 32'h04db2615;
-      8'h85:   crc32_byte_calc = 32'h9dd277af;
-      8'h84:   crc32_byte_calc = 32'head54739;
-      8'h83:   crc32_byte_calc = 32'h74b1d29a;
-      8'h82:   crc32_byte_calc = 32'h03b6e20c;
-      8'h81:   crc32_byte_calc = 32'h9abfb3b6;
-      8'h80:   crc32_byte_calc = 32'hedb88320;
-      8'h7f:   crc32_byte_calc = 32'hc0ba6cad;
-      8'h7e:   crc32_byte_calc = 32'hb7bd5c3b;
-      8'h7d:   crc32_byte_calc = 32'h2eb40d81;
-      8'h7c:   crc32_byte_calc = 32'h59b33d17;
-      8'h7b:   crc32_byte_calc = 32'hc7d7a8b4;
-      8'h7a:   crc32_byte_calc = 32'hb0d09822;
-      8'h79:   crc32_byte_calc = 32'h29d9c998;
-      8'h78:   crc32_byte_calc = 32'h5edef90e;
-      8'h77:   crc32_byte_calc = 32'hce61e49f;
-      8'h76:   crc32_byte_calc = 32'hb966d409;
-      8'h75:   crc32_byte_calc = 32'h206f85b3;
-      8'h74:   crc32_byte_calc = 32'h5768b525;
-      8'h73:   crc32_byte_calc = 32'hc90c2086;
-      8'h72:   crc32_byte_calc = 32'hbe0b1010;
-      8'h71:   crc32_byte_calc = 32'h270241aa;
-      8'h70:   crc32_byte_calc = 32'h5005713c;
-      8'h6f:   crc32_byte_calc = 32'hdd0d7cc9;
-      8'h6e:   crc32_byte_calc = 32'haa0a4c5f;
-      8'h6d:   crc32_byte_calc = 32'h33031de5;
-      8'h6c:   crc32_byte_calc = 32'h44042d73;
-      8'h6b:   crc32_byte_calc = 32'hda60b8d0;
-      8'h6a:   crc32_byte_calc = 32'had678846;
-      8'h69:   crc32_byte_calc = 32'h346ed9fc;
-      8'h68:   crc32_byte_calc = 32'h4369e96a;
-      8'h67:   crc32_byte_calc = 32'hd3d6f4fb;
-      8'h66:   crc32_byte_calc = 32'ha4d1c46d;
-      8'h65:   crc32_byte_calc = 32'h3dd895d7;
-      8'h64:   crc32_byte_calc = 32'h4adfa541;
-      8'h63:   crc32_byte_calc = 32'hd4bb30e2;
-      8'h62:   crc32_byte_calc = 32'ha3bc0074;
-      8'h61:   crc32_byte_calc = 32'h3ab551ce;
-      8'h60:   crc32_byte_calc = 32'h4db26158;
-      8'h5f:   crc32_byte_calc = 32'hfbd44c65;
-      8'h5e:   crc32_byte_calc = 32'h8cd37cf3;
-      8'h5d:   crc32_byte_calc = 32'h15da2d49;
-      8'h5c:   crc32_byte_calc = 32'h62dd1ddf;
-      8'h5b:   crc32_byte_calc = 32'hfcb9887c;
-      8'h5a:   crc32_byte_calc = 32'h8bbeb8ea;
-      8'h59:   crc32_byte_calc = 32'h12b7e950;
-      8'h58:   crc32_byte_calc = 32'h65b0d9c6;
-      8'h57:   crc32_byte_calc = 32'hf50fc457;
-      8'h56:   crc32_byte_calc = 32'h8208f4c1;
-      8'h55:   crc32_byte_calc = 32'h1b01a57b;
-      8'h54:   crc32_byte_calc = 32'h6c0695ed;
-      8'h53:   crc32_byte_calc = 32'hf262004e;
-      8'h52:   crc32_byte_calc = 32'h856530d8;
-      8'h51:   crc32_byte_calc = 32'h1c6c6162;
-      8'h50:   crc32_byte_calc = 32'h6b6b51f4;
-      8'h4f:   crc32_byte_calc = 32'he6635c01;
-      8'h4e:   crc32_byte_calc = 32'h91646c97;
-      8'h4d:   crc32_byte_calc = 32'h086d3d2d;
-      8'h4c:   crc32_byte_calc = 32'h7f6a0dbb;
-      8'h4b:   crc32_byte_calc = 32'he10e9818;
-      8'h4a:   crc32_byte_calc = 32'h9609a88e;
-      8'h49:   crc32_byte_calc = 32'h0f00f934;
-      8'h48:   crc32_byte_calc = 32'h7807c9a2;
-      8'h47:   crc32_byte_calc = 32'he8b8d433;
-      8'h46:   crc32_byte_calc = 32'h9fbfe4a5;
-      8'h45:   crc32_byte_calc = 32'h06b6b51f;
-      8'h44:   crc32_byte_calc = 32'h71b18589;
-      8'h43:   crc32_byte_calc = 32'hefd5102a;
-      8'h42:   crc32_byte_calc = 32'h98d220bc;
-      8'h41:   crc32_byte_calc = 32'h01db7106;
-      8'h40:   crc32_byte_calc = 32'h76dc4190;
-      8'h3f:   crc32_byte_calc = 32'hb6662d3d;
-      8'h3e:   crc32_byte_calc = 32'hc1611dab;
-      8'h3d:   crc32_byte_calc = 32'h58684c11;
-      8'h3c:   crc32_byte_calc = 32'h2f6f7c87;
-      8'h3b:   crc32_byte_calc = 32'hb10be924;
-      8'h3a:   crc32_byte_calc = 32'hc60cd9b2;
-      8'h39:   crc32_byte_calc = 32'h5f058808;
-      8'h38:   crc32_byte_calc = 32'h2802b89e;
-      8'h37:   crc32_byte_calc = 32'hb8bda50f;
-      8'h36:   crc32_byte_calc = 32'hcfba9599;
-      8'h35:   crc32_byte_calc = 32'h56b3c423;
-      8'h34:   crc32_byte_calc = 32'h21b4f4b5;
-      8'h33:   crc32_byte_calc = 32'hbfd06116;
-      8'h32:   crc32_byte_calc = 32'hc8d75180;
-      8'h31:   crc32_byte_calc = 32'h51de003a;
-      8'h30:   crc32_byte_calc = 32'h26d930ac;
-      8'h2f:   crc32_byte_calc = 32'habd13d59;
-      8'h2e:   crc32_byte_calc = 32'hdcd60dcf;
-      8'h2d:   crc32_byte_calc = 32'h45df5c75;
-      8'h2c:   crc32_byte_calc = 32'h32d86ce3;
-      8'h2b:   crc32_byte_calc = 32'hacbcf940;
-      8'h2a:   crc32_byte_calc = 32'hdbbbc9d6;
-      8'h29:   crc32_byte_calc = 32'h42b2986c;
-      8'h28:   crc32_byte_calc = 32'h35b5a8fa;
-      8'h27:   crc32_byte_calc = 32'ha50ab56b;
-      8'h26:   crc32_byte_calc = 32'hd20d85fd;
-      8'h25:   crc32_byte_calc = 32'h4b04d447;
-      8'h24:   crc32_byte_calc = 32'h3c03e4d1;
-      8'h23:   crc32_byte_calc = 32'ha2677172;
-      8'h22:   crc32_byte_calc = 32'hd56041e4;
-      8'h21:   crc32_byte_calc = 32'h4c69105e;
-      8'h20:   crc32_byte_calc = 32'h3b6e20c8;
-      8'h1f:   crc32_byte_calc = 32'h8d080df5;
-      8'h1e:   crc32_byte_calc = 32'hfa0f3d63;
-      8'h1d:   crc32_byte_calc = 32'h63066cd9;
-      8'h1c:   crc32_byte_calc = 32'h14015c4f;
-      8'h1b:   crc32_byte_calc = 32'h8a65c9ec;
-      8'h1a:   crc32_byte_calc = 32'hfd62f97a;
-      8'h19:   crc32_byte_calc = 32'h646ba8c0;
-      8'h18:   crc32_byte_calc = 32'h136c9856;
-      8'h17:   crc32_byte_calc = 32'h83d385c7;
-      8'h16:   crc32_byte_calc = 32'hf4d4b551;
-      8'h15:   crc32_byte_calc = 32'h6ddde4eb;
-      8'h14:   crc32_byte_calc = 32'h1adad47d;
-      8'h13:   crc32_byte_calc = 32'h84be41de;
-      8'h12:   crc32_byte_calc = 32'hf3b97148;
-      8'h11:   crc32_byte_calc = 32'h6ab020f2;
-      8'h10:   crc32_byte_calc = 32'h1db71064;
-      8'h0f:   crc32_byte_calc = 32'h90bf1d91;
-      8'h0e:   crc32_byte_calc = 32'he7b82d07;
-      8'h0d:   crc32_byte_calc = 32'h7eb17cbd;
-      8'h0c:   crc32_byte_calc = 32'h09b64c2b;
-      8'h0b:   crc32_byte_calc = 32'h97d2d988;
-      8'h0a:   crc32_byte_calc = 32'he0d5e91e;
-      8'h09:   crc32_byte_calc = 32'h79dcb8a4;
-      8'h08:   crc32_byte_calc = 32'h0edb8832;
-      8'h07:   crc32_byte_calc = 32'h9e6495a3;
-      8'h06:   crc32_byte_calc = 32'he963a535;
-      8'h05:   crc32_byte_calc = 32'h706af48f;
-      8'h04:   crc32_byte_calc = 32'h076dc419;
-      8'h03:   crc32_byte_calc = 32'h990951ba;
-      8'h02:   crc32_byte_calc = 32'hee0e612c;
-      8'h01:   crc32_byte_calc = 32'h77073096;
-      8'h00:   crc32_byte_calc = 32'h00000000;
-      default: crc32_byte_calc = '0;
-    endcase
-  endfunction
-
-  logic [31:0] crc_d, crc_q;
-  logic        crc_en;
-  logic [31:0] crc_stages[BytesPerWord + 1];
-
-  assign crc_en = set_crc_i | data_valid_i;
-
-  assign crc_stages[0] = crc_q;
-
-  for (genvar i = 0;i < BytesPerWord; ++i) begin : g_crc_stages
-    assign crc_stages[i + 1] =
-      {8'h00, crc_stages[i][31:8]} ^
-      crc32_byte_calc(crc_stages[i][7:0] ^ data_i[i * 8 +: 8]);
-  end
-
-  always_comb begin
-    if (set_crc_i) begin
-      crc_d = ~crc_in_i;
-    end else begin
-      crc_d = crc_stages[BytesPerWord];
-    end
-  end
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      crc_q <= 32'hFFFFFFFF;
-    end else if (crc_en) begin
-      crc_q <= crc_d;
-    end
-  end
-
-  assign crc_out_o = ~crc_q;
-endmodule
diff --git a/prim_diff_decode.sv b/prim_diff_decode.sv
deleted file mode 100644
index ca040157..00000000
--- a/prim_diff_decode.sv
+++ /dev/null
@@ -1,283 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// This module decodes a differentially encoded signal and detects
-// incorrectly encoded differential states.
-//
-// In case the differential pair crosses an asynchronous boundary, it has
-// to be re-synchronized to the local clock. This can be achieved by
-// setting the AsyncOn parameter to 1'b1. In that case, two additional
-// input registers are added (to counteract metastability), and
-// a pattern detector is instantiated that detects skewed level changes on
-// the differential pair (i.e., when level changes on the diff pair are
-// sampled one cycle apart due to a timing skew between the two wires).
-//
-// See also: prim_alert_sender, prim_alert_receiver, alert_handler
-
-`include "prim_assert.sv"
-
-module prim_diff_decode #(
-  // enables additional synchronization logic
-  parameter bit AsyncOn = 1'b0
-) (
-  input        clk_i,
-  input        rst_ni,
-  // input diff pair
-  input        diff_pi,
-  input        diff_ni,
-  // logical level and
-  // detected edges
-  output logic level_o,
-  output logic rise_o,
-  output logic fall_o,
-  // either rise or fall
-  output logic event_o,
-  //signal integrity issue detected
-  output logic sigint_o
-);
-
-  logic level_d, level_q;
-
-  ///////////////////////////////////////////////////////////////
-  // synchronization regs for incoming diff pair (if required) //
-  ///////////////////////////////////////////////////////////////
-  if (AsyncOn) begin : gen_async
-
-    typedef enum logic [1:0] {IsStd, IsSkewed, SigInt} state_e;
-    state_e state_d, state_q;
-    logic diff_p_edge, diff_n_edge, diff_check_ok, level;
-
-    // 2 sync regs, one reg for edge detection
-    logic diff_pq, diff_nq, diff_pd, diff_nd;
-
-    prim_flop_2sync #(
-      .Width(1),
-      .ResetValue('0)
-    ) i_sync_p (
-      .clk_i,
-      .rst_ni,
-      .d_i(diff_pi),
-      .q_o(diff_pd)
-    );
-
-    prim_flop_2sync #(
-      .Width(1),
-      .ResetValue(1'b1)
-    ) i_sync_n (
-      .clk_i,
-      .rst_ni,
-      .d_i(diff_ni),
-      .q_o(diff_nd)
-    );
-
-    // detect level transitions
-    assign diff_p_edge   = diff_pq ^ diff_pd;
-    assign diff_n_edge   = diff_nq ^ diff_nd;
-
-    // detect sigint issue
-    assign diff_check_ok = diff_pd ^ diff_nd;
-
-    // this is the current logical level
-    assign level         = diff_pd;
-
-    // outputs
-    assign level_o  = level_d;
-    assign event_o = rise_o | fall_o;
-
-    // sigint detection is a bit more involved in async case since
-    // we might have skew on the diff pair, which can result in a
-    // one cycle sampling delay between the two wires
-    // so we need a simple pattern matcher
-    // the following waves are legal
-    // clk    |   |   |   |   |   |   |   |
-    //           _______     _______
-    // p _______/        ...        \________
-    //   _______                     ________
-    // n        \_______ ... _______/
-    //              ____     ___
-    // p __________/     ...    \________
-    //   _______                     ________
-    // n        \_______ ... _______/
-    //
-    // i.e., level changes may be off by one cycle - which is permissible
-    // as long as this condition is only one cycle long.
-
-
-    always_comb begin : p_diff_fsm
-      // default
-      state_d  = state_q;
-      level_d  = level_q;
-      rise_o   = 1'b0;
-      fall_o   = 1'b0;
-      sigint_o = 1'b0;
-
-      unique case (state_q)
-        // we remain here as long as
-        // the diff pair is correctly encoded
-        IsStd: begin
-          if (diff_check_ok) begin
-            level_d = level;
-            if (diff_p_edge && diff_n_edge) begin
-              if (level) begin
-                rise_o = 1'b1;
-              end else begin
-                fall_o = 1'b1;
-              end
-            end
-          end else begin
-            if (diff_p_edge || diff_n_edge) begin
-              state_d = IsSkewed;
-            end else begin
-              state_d = SigInt;
-              sigint_o = 1'b1;
-            end
-          end
-        end
-        // diff pair must be correctly encoded, otherwise we got a sigint
-        IsSkewed: begin
-          if (diff_check_ok) begin
-            state_d = IsStd;
-            level_d = level;
-            if (level) rise_o = 1'b1;
-            else       fall_o = 1'b1;
-          end else begin
-            state_d  = SigInt;
-            sigint_o = 1'b1;
-          end
-        end
-        // Signal integrity issue detected, remain here
-        // until resolved
-        SigInt: begin
-          sigint_o = 1'b1;
-          if (diff_check_ok) begin
-            state_d  = IsStd;
-            sigint_o = 1'b0;
-          end
-        end
-        default : ;
-      endcase
-    end
-
-    always_ff @(posedge clk_i or negedge rst_ni) begin : p_sync_reg
-      if (!rst_ni) begin
-        state_q  <= IsStd;
-        diff_pq  <= 1'b0;
-        diff_nq  <= 1'b1;
-        level_q  <= 1'b0;
-      end else begin
-        state_q  <= state_d;
-        diff_pq  <= diff_pd;
-        diff_nq  <= diff_nd;
-        level_q  <= level_d;
-      end
-    end
-
-  //////////////////////////////////////////////////////////
-  // fully synchronous case, no skew present in this case //
-  //////////////////////////////////////////////////////////
-  end else begin : gen_no_async
-    logic diff_pq, diff_pd;
-
-    // one reg for edge detection
-    assign diff_pd = diff_pi;
-
-    // incorrect encoding -> signal integrity issue
-    assign sigint_o = ~(diff_pi ^ diff_ni);
-
-    assign level_o = (sigint_o) ? level_q : diff_pi;
-    assign level_d = level_o;
-
-    // detect level transitions
-    assign rise_o  = (~diff_pq &  diff_pi) & ~sigint_o;
-    assign fall_o  = ( diff_pq & ~diff_pi) & ~sigint_o;
-    assign event_o = rise_o | fall_o;
-
-    always_ff @(posedge clk_i or negedge rst_ni) begin : p_edge_reg
-      if (!rst_ni) begin
-        diff_pq  <= 1'b0;
-        level_q  <= 1'b0;
-      end else begin
-        diff_pq  <= diff_pd;
-        level_q  <= level_d;
-      end
-    end
-  end
-
-  ////////////////
-  // assertions //
-  ////////////////
-
-  // shared assertions
-  // sigint -> level stays the same during sigint
-  // $isunknown is needed to avoid false assertion in first clock cycle
-  `ASSERT(SigintLevelCheck_A, ##1 sigint_o |-> $stable(level_o))
-  // sigint -> no additional events asserted at output
-  `ASSERT(SigintEventCheck_A, sigint_o |-> !event_o)
-  `ASSERT(SigintRiseCheck_A,  sigint_o |-> !rise_o)
-  `ASSERT(SigintFallCheck_A,  sigint_o |-> !fall_o)
-
-  if (AsyncOn) begin : gen_async_assert
-`ifdef INC_ASSERT
-    // assertions for asynchronous case
-    // in this case we need to sample the input signals onto the local clock to avoid race
-    // conditions between the RTL and assertion sampling in simulation.
-    logic hlp_diff_pq, hlp_diff_nq;
-    always_ff @(posedge clk_i or negedge rst_ni) begin : p_edge_reg
-      if (!rst_ni) begin
-        hlp_diff_pq  <= 1'b0;
-        hlp_diff_nq  <= 1'b1;
-      end else begin
-        hlp_diff_pq  <= diff_pi;
-        hlp_diff_nq  <= diff_ni;
-      end
-    end
-
-    // correctly detect sigint issue (only one transition cycle of permissible due to skew)
-    `ASSERT(SigintCheck0_A, hlp_diff_pq == hlp_diff_nq [*2] |-> ##[0:1] sigint_o)
-    // the synchronizer adds 2 cycles of latency with respect to input signals.
-    `ASSERT(SigintCheck1_A,
-        ##1 (hlp_diff_pq ^ hlp_diff_nq) && $stable(hlp_diff_pq) && $stable(hlp_diff_nq) ##1
-        $rose(hlp_diff_pq) && $stable(hlp_diff_nq) ##1 $stable(hlp_diff_pq) && $fell(hlp_diff_nq)
-        |->
-        ##1 rise_o)
-    `ASSERT(SigintCheck2_A,
-        ##1 (hlp_diff_pq ^ hlp_diff_nq) && $stable(hlp_diff_pq) && $stable(hlp_diff_nq) ##1
-        $fell(hlp_diff_pq) && $stable(hlp_diff_nq) ##1 $stable(hlp_diff_pq) && $rose(hlp_diff_nq)
-        |->
-        ##1 fall_o)
-    `ASSERT(SigintCheck3_A,
-        ##1 (hlp_diff_pq ^ hlp_diff_nq) && $stable(hlp_diff_pq) && $stable(hlp_diff_nq) ##1
-        $rose(hlp_diff_nq) && $stable(hlp_diff_pq) ##1 $stable(hlp_diff_nq) && $fell(hlp_diff_pq)
-        |->
-        ##1 fall_o)
-    `ASSERT(SigintCheck4_A,
-        ##1 (hlp_diff_pq ^ hlp_diff_nq) && $stable(hlp_diff_pq) && $stable(hlp_diff_nq) ##1
-        $fell(hlp_diff_nq) && $stable(hlp_diff_pq) ##1 $stable(hlp_diff_nq) && $rose(hlp_diff_pq)
-        |->
-        ##1 rise_o)
-    // correctly detect edges
-    `ASSERT(RiseCheck_A,  ##1 $rose(hlp_diff_pq)     && (hlp_diff_pq ^ hlp_diff_nq) |->
-        ##[1:2] rise_o,  clk_i, !rst_ni || sigint_o)
-    `ASSERT(FallCheck_A,  ##1 $fell(hlp_diff_pq)     && (hlp_diff_pq ^ hlp_diff_nq) |->
-        ##[1:2] fall_o,  clk_i, !rst_ni || sigint_o)
-    `ASSERT(EventCheck_A, ##1 $changed(hlp_diff_pq)  && (hlp_diff_pq ^ hlp_diff_nq) |->
-        ##[1:2] event_o, clk_i, !rst_ni || sigint_o)
-    // correctly detect level
-    `ASSERT(LevelCheck0_A, !sigint_o && (hlp_diff_pq ^ hlp_diff_nq) [*3] |=>
-        $past(hlp_diff_pq, 1) == level_o,
-        clk_i, !rst_ni || sigint_o)
-`endif
-  end else begin : gen_sync_assert
-    // assertions for synchronous case
-    // correctly detect sigint issue
-    `ASSERT(SigintCheck_A, diff_pi == diff_ni |-> sigint_o)
-    // correctly detect edges
-    `ASSERT(RiseCheck_A,  ##1 $rose(diff_pi)    && (diff_pi ^ diff_ni) |->  rise_o)
-    `ASSERT(FallCheck_A,  ##1 $fell(diff_pi)    && (diff_pi ^ diff_ni) |->  fall_o)
-    `ASSERT(EventCheck_A, ##1 $changed(diff_pi) && (diff_pi ^ diff_ni) |-> event_o)
-    // correctly detect level
-    `ASSERT(LevelCheck_A, (diff_pi ^ diff_ni) |-> diff_pi == level_o)
-  end
-
-endmodule : prim_diff_decode
diff --git a/prim_dom_and_2share.sv b/prim_dom_and_2share.sv
deleted file mode 100644
index e9b9f9f2..00000000
--- a/prim_dom_and_2share.sv
+++ /dev/null
@@ -1,120 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Domain-Oriented Masking GF(2) Multiplier with 2-shares
-// ref: Higher-Order Side-Channel Protected Implementations of Keccak
-//     https://eprint.iacr.org/2017/395.pdf
-//
-// q0 = a0 & b0 + (a0 & b1 + z)
-// q1 = a1 & b1 + (a1 & b0 + z)
-// () ==> registered
-//
-// all input should be stable for two clocks
-// as the output is valid after a clock
-// For z, it can use other slice from the state
-// as it is fairly random w.r.t the current inputs.
-
-// General formula of Q in the paper
-// Qi = t{i,i} + Sig(j>i,d)(t{i,j}+Z{i+j*(j-1)/2}) + Sig(j<i,d)(t{i,j}+Z{j+i*(i-1)/2})
-// for d=1 (NumShare 2 for first order protection)
-// Q0 = t{0,0} + Sig(j>0,1)(t{0,j}+Z{j(j-1)/2}) + Sig(j<0,d)(..)
-//    = a0&b0  + (a0&b1 + z0                    + 0)
-// Q1 = t{1,1} + sig(j>1,1)(...) + sig(j<1,1)(t{1,j} + Z{j})
-//    = a1&b1  + (0              + a1&b0 + z0)
-
-`include "prim_assert.sv"
-
-module prim_dom_and_2share #(
-  parameter int DW = 64 // Input width
-) (
-  input clk_i,
-  input rst_ni,
-
-  input [DW-1:0] a0_i, // share0 of a
-  input [DW-1:0] a1_i, // share1 of a
-  input [DW-1:0] b0_i, // share0 of b
-  input [DW-1:0] b1_i, // share1 of b
-  input          z_valid_i, // random number input validity
-  input [DW-1:0] z_i,  // random number
-
-  output logic [DW-1:0] q0_o, // share0 of q
-  output logic [DW-1:0] q1_o  // share1 of q
-);
-
-  logic [DW-1:0] t0_d, t0_q, t1_d, t1_q;
-  logic [DW-1:0] t_a0b1, t_a1b0, t_a0b0, t_a1b1;
-
-  /////////////////
-  // Calculation //
-  /////////////////
-  // Inner-domain terms
-  assign t_a0b0 = a0_i & b0_i;
-  assign t_a1b1 = a1_i & b1_i;
-
-  // Cross-domain terms
-  assign t_a0b1 = a0_i & b1_i;
-  assign t_a1b0 = a1_i & b0_i;
-
-  ///////////////
-  // Resharing //
-  ///////////////
-  // Resharing of cross-domain terms
-
-  // Preserve the logic sequence for XOR not to proceed cross-domain AND.
-  prim_xor2 #(
-    .Width ( DW*2 )
-  ) u_prim_xor_t01 (
-    .in0_i ( {t_a0b1, t_a1b0} ),
-    .in1_i ( {z_i,    z_i}    ),
-    .out_o ( {t0_d,   t1_d}   )
-  );
-
-  // Register stage
-  prim_flop_en #(
-    .Width      ( DW*2 ),
-    .ResetValue ( '0   )
-  ) u_prim_flop_t01 (
-    .clk_i  ( clk_i        ),
-    .rst_ni ( rst_ni       ),
-    .en_i   ( z_valid_i    ),
-    .d_i    ( {t0_d, t1_d} ),
-    .q_o    ( {t0_q, t1_q} )
-  );
-
-  /////////////////
-  // Integration //
-  /////////////////
-
-  // Preserve the logic sequence for XOR not to proceed the inner-domain AND.
-  prim_xor2 #(
-    .Width ( DW*2 )
-  ) u_prim_xor_q01 (
-    .in0_i ( {t_a0b0, t_a1b1} ),
-    .in1_i ( {t0_q,   t1_q}   ),
-    .out_o ( {q0_o,   q1_o}   )
-  );
-
-  // DOM AND should be same as unmasked computation
-  // TODO: Put assumption that input need to be stable for at least two cycles
-  // The correct test sequence will be:
-  //   1. inputs are changed
-  //   2. check if z_valid_i,
-  //   3. at the next cycle, inputs are still stable (assumption)
-  //   4. and results Q == A & B (assertion)
-
-  // To speed up the FPV process, random value is ready in less than or
-  // equal to two cycles.
-  `ASSUME_FPV(RandomReadyInShortTime_A,
-    $changed(a0_i) || $changed(a1_i) || $changed(b0_i) || $changed(b1_i)
-      |-> ##[0:2] z_valid_i,
-    clk_i, !rst_ni)
-  `ASSERT(UnmaskedAndMatched_A,
-    $changed(a0_i) || $changed(a1_i) || $changed(b0_i) || $changed(b1_i)
-      |-> ##[0:$] z_valid_i
-      |=> $stable(a0_i) && $stable(a1_i) && $stable(b0_i) && $stable(b1_i)
-      |-> (q0_o ^ q1_o) == ((a0_i ^ a1_i) & (b0_i ^ b1_i)),
-    clk_i, !rst_ni)
-
-endmodule
-
diff --git a/prim_double_lfsr.sv b/prim_double_lfsr.sv
deleted file mode 100644
index f03cb4e2..00000000
--- a/prim_double_lfsr.sv
+++ /dev/null
@@ -1,99 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Hardened LFSR module that instantiates two LFSRs of the same type.
-// The state vector of both LFSRs is constantly checked and an error is asserted if the
-// two states are inconsistent.
-
-module prim_double_lfsr #(
-  // prim_lfsr parameters - refer to prim_lfsr for their meaning/
-  parameter                    LfsrType     = "GAL_XOR",
-  parameter int unsigned       LfsrDw       = 32,
-  localparam int unsigned      LfsrIdxDw    = $clog2(LfsrDw),
-  parameter int unsigned       EntropyDw    =  8,
-  parameter int unsigned       StateOutDw   =  8,
-  parameter logic [LfsrDw-1:0] DefaultSeed  = LfsrDw'(1),
-  parameter logic [LfsrDw-1:0] CustomCoeffs = '0,
-  parameter bit                StatePermEn  = 1'b0,
-  parameter logic [LfsrDw-1:0][LfsrIdxDw-1:0] StatePerm = '0,
-  parameter bit                MaxLenSVA    = 1'b1,
-  parameter bit                LockupSVA    = 1'b1,
-  parameter bit                ExtSeedSVA   = 1'b1,
-  parameter bit                NonLinearOut = 1'b0,
-  // This should only be disabled in special circumstances, for example
-  // in non-comportable IPs where an error does not trigger an alert.
-  parameter bit                EnableAlertTriggerSVA = 1
-) (
-  input                         clk_i,
-  input                         rst_ni,
-  input                         seed_en_i,
-  input        [LfsrDw-1:0]     seed_i,
-  input                         lfsr_en_i,
-  input        [EntropyDw-1:0]  entropy_i,
-  output logic [StateOutDw-1:0] state_o,
-  // Asserted if the parallel LFSR states are inconsistent.
-  output logic                  err_o
-);
-
-
-  logic [1:0][LfsrDw-1:0] lfsr_state;
-  // We employ redundant LFSRs to guard against FI attacks.
-  for (genvar k = 0; k < 2; k++) begin : gen_double_lfsr
-    // Instantiate size_only buffers to prevent
-    // optimization / merging of redundant logic.
-    logic lfsr_en_buf, seed_en_buf;
-    logic [EntropyDw-1:0] entropy_buf;
-    logic [LfsrDw-1:0] seed_buf, lfsr_state_unbuf;
-    prim_buf #(
-      .Width(EntropyDw + LfsrDw + 2)
-    ) u_prim_buf_input (
-      .in_i({seed_en_i, seed_i, lfsr_en_i, entropy_i}),
-      .out_o({seed_en_buf, seed_buf, lfsr_en_buf, entropy_buf})
-    );
-
-    prim_lfsr #(
-      .LfsrType(LfsrType),
-      .LfsrDw(LfsrDw),
-      .EntropyDw(EntropyDw),
-      // output the full width so that the states can be cross checked.
-      .StateOutDw(LfsrDw),
-      .DefaultSeed(DefaultSeed),
-      .CustomCoeffs(CustomCoeffs),
-      .StatePermEn(StatePermEn),
-      .StatePerm(StatePerm),
-      .MaxLenSVA(MaxLenSVA),
-      .LockupSVA(LockupSVA),
-      .ExtSeedSVA(ExtSeedSVA),
-      .NonLinearOut(NonLinearOut)
-    ) u_prim_lfsr (
-      .clk_i,
-      .rst_ni,
-      .seed_en_i  ( seed_en_buf      ),
-      .seed_i     ( seed_buf         ),
-      .lfsr_en_i  ( lfsr_en_buf      ),
-      .entropy_i  ( entropy_buf      ),
-      .state_o    ( lfsr_state_unbuf )
-    );
-
-    prim_buf #(
-      .Width(LfsrDw)
-    ) u_prim_buf_output (
-      .in_i(lfsr_state_unbuf),
-      .out_o(lfsr_state[k])
-    );
-  end
-
-  // Output the state from the first LFSR
-  assign state_o = lfsr_state[0][StateOutDw-1:0];
-  assign err_o = lfsr_state[0] != lfsr_state[1];
-
-  // This logic that will be assign to one, when user adds macro
-  // ASSERT_PRIM_DOUBLE_LFSR_ERROR_TRIGGER_ALERT to check the error with alert, in case that
-  // prim_double_lfsr is used in design without adding this assertion check.
-  `ifdef INC_ASSERT
-  logic unused_assert_connected;
-
-  `ASSERT_INIT_NET(AssertConnected_A, unused_assert_connected === 1'b1 || !EnableAlertTriggerSVA)
-  `endif
-endmodule : prim_double_lfsr
diff --git a/prim_edge_detector.sv b/prim_edge_detector.sv
deleted file mode 100644
index 2b0a92fb..00000000
--- a/prim_edge_detector.sv
+++ /dev/null
@@ -1,55 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Edge Detector
-
-module prim_edge_detector #(
-  parameter int unsigned Width = 1,
-
-  parameter logic [Width-1:0] ResetValue = '0,
-
-  // EnSync
-  //
-  // Enable Synchronizer to the input signal.
-  // It is assumed that the input signal is glitch free (registered input).
-  parameter bit EnSync  = 1'b 1
-) (
-  input clk_i,
-  input rst_ni,
-
-  input        [Width-1:0] d_i,
-  output logic [Width-1:0] q_sync_o,
-
-  output logic [Width-1:0] q_posedge_pulse_o,
-  output logic [Width-1:0] q_negedge_pulse_o
-);
-
-  logic [Width-1:0] q_sync_d, q_sync_q;
-
-  if (EnSync) begin : g_sync
-    prim_flop_2sync #(
-      .Width (Width),
-      .ResetValue (ResetValue)
-    ) u_sync (
-      .clk_i,
-      .rst_ni,
-      .d_i,
-      .q_o (q_sync_d)
-    );
-  end : g_sync
-  else begin : g_nosync
-    assign q_sync_d = d_i;
-  end : g_nosync
-
-  assign q_sync_o = q_sync_d;
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) q_sync_q <= ResetValue;
-    else         q_sync_q <= q_sync_d;
-  end
-
-  assign q_posedge_pulse_o = q_sync_d & ~q_sync_q;
-  assign q_negedge_pulse_o = ~q_sync_d & q_sync_q;
-
-endmodule : prim_edge_detector
diff --git a/prim_edn_req.sv b/prim_edn_req.sv
deleted file mode 100644
index 430594fd..00000000
--- a/prim_edn_req.sv
+++ /dev/null
@@ -1,145 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// This module can be used as a "gadget" to adapt the native 32bit width of the EDN network
-// locally to the width needed by the consuming logic. For example, if the local consumer
-// needs 128bit, this module would request four 32 bit words from EDN and stack them accordingly.
-//
-// The module also uses a req/ack synchronizer to synchronize the EDN data over to the local
-// clock domain. Note that this assumes that the EDN data bus remains stable between subsequent
-// requests.
-//
-
-`include "prim_assert.sv"
-
-module prim_edn_req
-  import prim_alert_pkg::*;
-#(
-  parameter int OutWidth = 32,
-
-  // EDN Request latency checker
-  //
-  //  Each consumer IP may have the maximum expected latency. MaxLatency
-  //  parameter describes the expected latency in terms of the consumer clock
-  //  cycles. If the edn request comes later than that, the assertion will be
-  //  fired.
-  //
-  //  The default value is 0, which disables the assertion.
-  parameter int unsigned MaxLatency = 0
-) (
-  // Design side
-  input                       clk_i,
-  input                       rst_ni,
-  input                       req_chk_i, // Used for gating assertions. Drive to 1 during normal
-                                         // operation.
-  input                       req_i,
-  output logic                ack_o,
-  output logic [OutWidth-1:0] data_o,
-  output logic                fips_o,
-  // EDN side
-  input                       clk_edn_i,
-  input                       rst_edn_ni,
-  output edn_pkg::edn_req_t   edn_o,
-  input  edn_pkg::edn_rsp_t   edn_i
-);
-
-  // Stop requesting words from EDN once desired amount of data is available.
-  logic word_req, word_ack;
-  assign word_req = req_i & ~ack_o;
-
-  logic [edn_pkg::ENDPOINT_BUS_WIDTH-1:0] word_data;
-  logic word_fips;
-  localparam int SyncWidth = $bits({edn_i.edn_fips, edn_i.edn_bus});
-  prim_sync_reqack_data #(
-    .Width(SyncWidth),
-    .DataSrc2Dst(1'b0),
-    .DataReg(1'b0)
-  ) u_prim_sync_reqack_data (
-    .clk_src_i  ( clk_i                           ),
-    .rst_src_ni ( rst_ni                          ),
-    .clk_dst_i  ( clk_edn_i                       ),
-    .rst_dst_ni ( rst_edn_ni                      ),
-    .req_chk_i  ( req_chk_i                       ),
-    .src_req_i  ( word_req                        ),
-    .src_ack_o  ( word_ack                        ),
-    .dst_req_o  ( edn_o.edn_req                   ),
-    .dst_ack_i  ( edn_i.edn_ack                   ),
-    .data_i     ( {edn_i.edn_fips, edn_i.edn_bus} ),
-    .data_o     ( {word_fips,      word_data}     )
-  );
-
-  prim_packer_fifo #(
-    .InW(edn_pkg::ENDPOINT_BUS_WIDTH),
-    .OutW(OutWidth),
-    .ClearOnRead(1'b0)
-  ) u_prim_packer_fifo (
-    .clk_i,
-    .rst_ni,
-    .clr_i    ( 1'b0          ), // not needed
-    .wvalid_i ( word_ack      ),
-    .wdata_i  ( word_data     ),
-    // no need for backpressure since we're always ready to
-    // sink data at this point.
-    .wready_o (               ),
-    .rvalid_o ( ack_o         ),
-    .rdata_o  ( data_o        ),
-    // we're always ready to receive the packed output word
-    // at this point.
-    .rready_i ( 1'b1          ),
-    .depth_o  (               )
-  );
-
-  // Need to track if any of the packed words has been generated with a pre-FIPS seed, i.e., has
-  // fips == 1'b0.
-  logic fips_d, fips_q;
-  assign fips_d = (req_i && ack_o) ? 1'b1               : // clear
-                  (word_ack)       ? fips_q & word_fips : // accumulate
-                                     fips_q;              // keep
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      fips_q <= 1'b1;
-    end else begin
-      fips_q <= fips_d;
-    end
-  end
-  assign fips_o = fips_q;
-
-  ////////////////
-  // Assertions //
-  ////////////////
-
-  // EDN Max Latency Checker
-`ifndef SYNTHESIS
-  if (MaxLatency != 0) begin: g_maxlatency_assertion
-    localparam int unsigned LatencyW = $clog2(MaxLatency+1);
-    logic [LatencyW-1:0] latency_counter;
-    logic reset_counter;
-    logic enable_counter;
-
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) latency_counter <= '0;
-      else if (reset_counter) latency_counter <= '0;
-      else if (enable_counter) latency_counter <= latency_counter + 1'b1;
-    end
-
-    assign reset_counter  = ack_o;
-    assign enable_counter = req_i;
-
-    `ASSERT(MaxLatency_A, latency_counter <= MaxLatency)
-
-    // TODO: Is it worth to check req & ack pair?
-    //         _________________________________
-    // req  __/                                 \______
-    //                                           ____
-    // ack  ____________________________________/    \_
-    //
-    //                                          | error
-
-  end // g_maxlatency_assertion
-`else // SYNTHESIS
-  logic unused_param_maxlatency;
-  assign unused_param_maxlatency = ^MaxLatency;
-`endif // SYNTHESIS
-
-endmodule : prim_edn_req
diff --git a/prim_esc_pkg.sv b/prim_esc_pkg.sv
deleted file mode 100644
index 8cd9c4ec..00000000
--- a/prim_esc_pkg.sv
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-
-package prim_esc_pkg;
-
-  typedef struct packed {
-    logic esc_p;
-    logic esc_n;
-  } esc_tx_t;
-
-  typedef struct packed {
-    logic resp_p;
-    logic resp_n;
-  } esc_rx_t;
-
-  parameter esc_tx_t ESC_TX_DEFAULT = '{esc_p:  1'b0,
-                                        esc_n:  1'b1};
-
-  parameter esc_rx_t ESC_RX_DEFAULT = '{resp_p: 1'b0,
-                                        resp_n: 1'b1};
-
-endpackage : prim_esc_pkg
diff --git a/prim_esc_receiver.sv b/prim_esc_receiver.sv
deleted file mode 100644
index 3e6c683e..00000000
--- a/prim_esc_receiver.sv
+++ /dev/null
@@ -1,277 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// This module decodes escalation enable pulses that have been encoded using
-// the prim_esc_sender module.
-//
-// The module supports in-band ping testing of the escalation
-// wires. This is accomplished by the sender module that places a single-cycle,
-// differentially encoded pulse on esc_p/n which will be interpreted as a ping
-// request by the receiver module. The receiver module responds by sending back
-// the response pattern "1010".
-//
-// Native escalation enable pulses are differentiated from ping
-// requests by making sure that these pulses are always longer than 1 cycle.
-//
-// See also: prim_esc_sender, prim_diff_decode, alert_handler
-
-`include "prim_assert.sv"
-
-module prim_esc_receiver
-  import prim_esc_pkg::*;
-#(
-  // The number of escalation severities. Should be set to the Alert Handler's N_ESC_SEV when this
-  // primitive is instantiated.
-  parameter int N_ESC_SEV = 4,
-
-  // The width of the Alert Handler's ping counter. Should be set to the Alert Handler's PING_CNT_DW
-  // when this primitive is instantiated.
-  parameter int PING_CNT_DW = 16,
-
-  // This counter monitors incoming ping requests and auto-escalates if the alert handler
-  // ceases to send them regularly. The maximum number of cycles between subsequent ping requests
-  // is N_ESC_SEV x (2 x 2 x 2**PING_CNT_DW), see also implementation of the ping timer
-  // (alert_handler_ping_timer.sv). The timeout counter below uses a timeout that is 4x larger than
-  // that in order to incorporate some margin.
-  //
-  // Do NOT modify this counter value, when instantiating it in the design. It is only exposed to
-  // reduce the state space in the FPV testbench.
-  localparam int MarginFactor = 4,
-  localparam int NumWaitCounts = 2,
-  localparam int NumTimeoutCounts = 2,
-  parameter int TimeoutCntDw = $clog2(MarginFactor) +
-                               $clog2(N_ESC_SEV) +
-                               $clog2(NumWaitCounts) +
-                               $clog2(NumTimeoutCounts) +
-                               PING_CNT_DW
-) (
-  input           clk_i,
-  input           rst_ni,
-  // escalation enable
-  output logic    esc_req_o,
-  // escalation / ping response
-  output esc_rx_t esc_rx_o,
-  // escalation output diff pair
-  input esc_tx_t  esc_tx_i
-);
-
-  /////////////////////////////////
-  // decode differential signals //
-  /////////////////////////////////
-
-  logic esc_level, esc_p, esc_n, sigint_detected;
-
-  // This prevents further tool optimizations of the differential signal.
-  prim_buf #(
-    .Width(2)
-  ) u_prim_buf_esc (
-    .in_i({esc_tx_i.esc_n,
-           esc_tx_i.esc_p}),
-    .out_o({esc_n,
-            esc_p})
-  );
-
-  prim_diff_decode #(
-    .AsyncOn(1'b0)
-  ) u_decode_esc (
-    .clk_i,
-    .rst_ni,
-    .diff_pi  ( esc_p           ),
-    .diff_ni  ( esc_n           ),
-    .level_o  ( esc_level       ),
-    .rise_o   (                 ),
-    .fall_o   (                 ),
-    .event_o  (                 ),
-    .sigint_o ( sigint_detected )
-  );
-
-  ////////////////////////////////////////////
-  // Ping Monitor Counter / Auto Escalation //
-  ////////////////////////////////////////////
-
-  // The timeout counter is kicked off when the first ping occurs, and subsequent pings reset
-  // the counter to 1. The counter keeps on counting when it is nonzero, and saturates when it
-  // has reached its maximum (this state is terminal).
-  logic ping_en, timeout_cnt_error;
-  logic timeout_cnt_set, timeout_cnt_en;
-  logic [TimeoutCntDw-1:0] timeout_cnt;
-  assign timeout_cnt_set = (ping_en && !(&timeout_cnt));
-  assign timeout_cnt_en = ((timeout_cnt > '0) && !(&timeout_cnt));
-
-  prim_count #(
-    .Width(TimeoutCntDw),
-    .OutSelDnCnt(0), // count up
-    .CntStyle(prim_count_pkg::DupCnt),
-    // The escalation receiver behaves differently than other comportable IP. I.e., instead of
-    // sending out an alert signal, this condition is handled internally in the alert handler.
-    .EnableAlertTriggerSVA(0)
-  ) u_prim_count (
-    .clk_i,
-    .rst_ni,
-    .clr_i(1'b0),
-    .set_i(timeout_cnt_set),
-    .set_cnt_i(TimeoutCntDw'(1)),
-    .en_i(timeout_cnt_en),
-    .step_i(TimeoutCntDw'(1)),
-    .cnt_o(timeout_cnt),
-    .err_o(timeout_cnt_error)
-  );
-
-  // Escalation is asserted if
-  // - requested via the escalation sender/receiver path,
-  // - the ping monitor timeout is reached,
-  // - the two ping monitor counters are in an inconsistent state.
-  logic esc_req;
-  prim_sec_anchor_buf #(
-    .Width(1)
-  ) u_prim_buf_esc_req (
-    .in_i(esc_req || (&timeout_cnt) || timeout_cnt_error),
-    .out_o(esc_req_o)
-  );
-
-  /////////////////
-  // RX/TX Logic //
-  /////////////////
-
-  typedef enum logic [2:0] {Idle, Check, PingResp, EscResp, SigInt} state_e;
-  state_e state_d, state_q;
-  logic resp_pd, resp_pq;
-  logic resp_nd, resp_nq;
-
-  // This prevents further tool optimizations of the differential signal.
-  prim_sec_anchor_flop #(
-    .Width(2),
-    .ResetValue(2'b10)
-  ) u_prim_flop_esc (
-    .clk_i,
-    .rst_ni,
-    .d_i({resp_nd, resp_pd}),
-    .q_o({resp_nq, resp_pq})
-  );
-
-  assign esc_rx_o.resp_p = resp_pq;
-  assign esc_rx_o.resp_n = resp_nq;
-
-  always_comb begin : p_fsm
-    // default
-    state_d  = state_q;
-    resp_pd  = 1'b0;
-    resp_nd  = 1'b1;
-    esc_req  = 1'b0;
-    ping_en  = 1'b0;
-
-    unique case (state_q)
-      // wait for the esc_p/n diff pair
-      Idle: begin
-        if (esc_level) begin
-          state_d = Check;
-          resp_pd = ~resp_pq;
-          resp_nd = resp_pq;
-        end
-      end
-      // we decide here whether this is only a ping request or
-      // whether this is an escalation enable
-      Check: begin
-        state_d = PingResp;
-        resp_pd = ~resp_pq;
-        resp_nd = resp_pq;
-        if (esc_level) begin
-          state_d  = EscResp;
-          esc_req  = 1'b1;
-        end
-      end
-      // finish ping response. in case esc_level is again asserted,
-      // we got an escalation signal (pings cannot occur back to back)
-      PingResp: begin
-        state_d = Idle;
-        resp_pd = ~resp_pq;
-        resp_nd = resp_pq;
-        ping_en = 1'b1;
-        if (esc_level) begin
-          state_d  = EscResp;
-          esc_req  = 1'b1;
-        end
-      end
-      // we have got an escalation enable pulse,
-      // keep on toggling the outputs
-      EscResp: begin
-        state_d = Idle;
-        if (esc_level) begin
-          state_d  = EscResp;
-          resp_pd  = ~resp_pq;
-          resp_nd  = resp_pq;
-          esc_req  = 1'b1;
-        end
-      end
-      // we have a signal integrity issue at one of
-      // the incoming diff pairs. this condition is
-      // signalled to the sender by setting the resp
-      // diffpair to the same value and continuously
-      // toggling them.
-      SigInt: begin
-        state_d = Idle;
-        esc_req = 1'b1;
-        if (sigint_detected) begin
-          state_d = SigInt;
-          resp_pd = ~resp_pq;
-          resp_nd = ~resp_pq;
-        end
-      end
-      default : state_d = Idle;
-    endcase
-
-    // bail out if a signal integrity issue has been detected
-    if (sigint_detected && (state_q != SigInt)) begin
-      state_d  = SigInt;
-      resp_pd  = 1'b0;
-      resp_nd  = 1'b0;
-    end
-  end
-
-
-  ///////////////
-  // Registers //
-  ///////////////
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
-    if (!rst_ni) begin
-      state_q <= Idle;
-    end else begin
-      state_q <= state_d;
-    end
-  end
-
-  ////////////////
-  // assertions //
-  ////////////////
-
-  // check whether all outputs have a good known state after reset
-  `ASSERT_KNOWN(EscEnKnownO_A, esc_req_o)
-  `ASSERT_KNOWN(RespPKnownO_A, esc_rx_o)
-
-  `ASSERT(SigIntCheck0_A, esc_tx_i.esc_p == esc_tx_i.esc_n |=>
-      esc_rx_o.resp_p == esc_rx_o.resp_n)
-  `ASSERT(SigIntCheck1_A, esc_tx_i.esc_p == esc_tx_i.esc_n |=> state_q == SigInt)
-  // auto-escalate in case of signal integrity issue
-  `ASSERT(SigIntCheck2_A, esc_tx_i.esc_p == esc_tx_i.esc_n |=> esc_req_o)
-  // correct diff encoding
-  `ASSERT(DiffEncCheck_A, esc_tx_i.esc_p ^ esc_tx_i.esc_n |=>
-      esc_rx_o.resp_p ^ esc_rx_o.resp_n)
-  // disable in case of signal integrity issue
-  `ASSERT(PingRespCheck_A, state_q == Idle ##1 $rose(esc_tx_i.esc_p) ##1 $fell(esc_tx_i.esc_p) |->
-      $rose(esc_rx_o.resp_p) ##1 $fell(esc_rx_o.resp_p),
-      clk_i, !rst_ni || (esc_tx_i.esc_p == esc_tx_i.esc_n))
-  // escalation response needs to continuously toggle
-  `ASSERT(EscRespCheck_A, esc_tx_i.esc_p && $past(esc_tx_i.esc_p) &&
-      (esc_tx_i.esc_p ^ esc_tx_i.esc_n) && $past(esc_tx_i.esc_p ^ esc_tx_i.esc_n)
-      |=> esc_rx_o.resp_p != $past(esc_rx_o.resp_p))
-  // detect escalation pulse
-  `ASSERT(EscEnCheck_A, esc_tx_i.esc_p && (esc_tx_i.esc_p ^ esc_tx_i.esc_n) && state_q != SigInt
-      ##1 esc_tx_i.esc_p && (esc_tx_i.esc_p ^ esc_tx_i.esc_n) |-> esc_req_o)
-  // make sure the counter does not wrap around
-  `ASSERT(EscCntWrap_A, &timeout_cnt |=> timeout_cnt != 0)
-  // if the counter expires, escalation should be asserted
-  `ASSERT(EscCntEsc_A, &timeout_cnt |-> esc_req_o)
-
-endmodule : prim_esc_receiver
diff --git a/prim_esc_sender.sv b/prim_esc_sender.sv
deleted file mode 100644
index 7987e6cc..00000000
--- a/prim_esc_sender.sv
+++ /dev/null
@@ -1,272 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// This module differentially encodes an escalation enable pulse
-// of arbitrary width.
-//
-// The module supports in-band ping testing of the escalation
-// wires. This is accomplished by sending out a single, differentially
-// encoded pulse on esc_p/n which will be interpreted as a ping
-// request by the escalation receiver. Note that ping_req_i shall
-// be held high until either ping_ok_o or integ_fail_o is asserted.
-//
-// Native escalation enable pulses are differentiated from ping
-// requests by making sure that these pulses are always longer than 1 cycle.
-//
-// If there is a differential encoding error, integ_fail_o
-// will be asserted.
-//
-// See also: prim_esc_receiver, prim_diff_decode, alert_handler
-
-`include "prim_assert.sv"
-
-module prim_esc_sender
-  import prim_esc_pkg::*;
-(
-  input           clk_i,
-  input           rst_ni,
-  // this triggers a ping test. keep asserted until ping_ok_o is pulsed high.
-  input           ping_req_i,
-  output logic    ping_ok_o,
-  // asserted if signal integrity issue detected
-  output logic    integ_fail_o,
-  // escalation request signal
-  input           esc_req_i,
-  // escalation / ping response
-  input esc_rx_t  esc_rx_i,
-  // escalation output diff pair
-  output esc_tx_t esc_tx_o
-);
-
-  /////////////////////////////////
-  // decode differential signals //
-  /////////////////////////////////
-
-  logic resp, resp_n, resp_p, sigint_detected;
-
-  // This prevents further tool optimizations of the differential signal.
-  prim_sec_anchor_buf #(
-    .Width(2)
-  ) u_prim_buf_resp (
-    .in_i({esc_rx_i.resp_n,
-           esc_rx_i.resp_p}),
-    .out_o({resp_n,
-            resp_p})
-  );
-
-  prim_diff_decode #(
-    .AsyncOn(1'b0)
-  ) u_decode_resp (
-    .clk_i,
-    .rst_ni,
-    .diff_pi  ( resp_p          ),
-    .diff_ni  ( resp_n          ),
-    .level_o  ( resp            ),
-    .rise_o   (                 ),
-    .fall_o   (                 ),
-    .event_o  (                 ),
-    .sigint_o ( sigint_detected )
-  );
-
-  //////////////
-  // TX Logic //
-  //////////////
-
-  logic ping_req_d, ping_req_q;
-  logic esc_req_d, esc_req_q, esc_req_q1;
-
-  assign ping_req_d = ping_req_i;
-  assign esc_req_d  = esc_req_i;
-
-  // ping enable is 1 cycle pulse
-  // escalation pulse is always longer than 2 cycles
-  logic esc_p;
-  assign esc_p = esc_req_i | esc_req_q | (ping_req_d & ~ping_req_q);
-
-  // This prevents further tool optimizations of the differential signal.
-  prim_sec_anchor_buf #(
-    .Width(2)
-  ) u_prim_buf_esc (
-    .in_i({~esc_p,
-           esc_p}),
-    .out_o({esc_tx_o.esc_n,
-            esc_tx_o.esc_p})
-  );
-
-  //////////////
-  // RX Logic //
-  //////////////
-
-  typedef enum logic [2:0] {Idle, CheckEscRespLo, CheckEscRespHi,
-    CheckPingResp0, CheckPingResp1, CheckPingResp2, CheckPingResp3} fsm_e;
-
-  fsm_e state_d, state_q;
-
-  always_comb begin : p_fsm
-    // default
-    state_d      = state_q;
-    ping_ok_o    = 1'b0;
-    integ_fail_o = sigint_detected;
-
-    unique case (state_q)
-      // wait for ping or escalation enable
-      Idle: begin
-        if (esc_req_i) begin
-          state_d = CheckEscRespHi;
-        end else if (ping_req_d & ~ping_req_q) begin
-          state_d = CheckPingResp0;
-        end
-        // any assertion of the response signal
-        // signal here will trigger a sigint error
-        if (resp) begin
-          integ_fail_o = 1'b1;
-        end
-      end
-      // check whether response is 0
-      CheckEscRespLo: begin
-        state_d      = CheckEscRespHi;
-        if (!esc_tx_o.esc_p || resp) begin
-          state_d = Idle;
-          integ_fail_o = sigint_detected | resp;
-        end
-      end
-      // check whether response is 1
-      CheckEscRespHi: begin
-        state_d = CheckEscRespLo;
-        if (!esc_tx_o.esc_p || !resp) begin
-          state_d = Idle;
-          integ_fail_o = sigint_detected | ~resp;
-        end
-      end
-      // start of ping response sequence
-      // we expect the sequence "1010"
-      CheckPingResp0: begin
-        state_d = CheckPingResp1;
-        // abort sequence immediately if escalation is signalled,
-        // jump to escalation response checking (lo state)
-        if (esc_req_i) begin
-          state_d = CheckEscRespLo;
-        // abort if response is wrong
-        end else if (!resp) begin
-          state_d = Idle;
-          integ_fail_o = 1'b1;
-        end
-      end
-      CheckPingResp1: begin
-        state_d = CheckPingResp2;
-        // abort sequence immediately if escalation is signalled,
-        // jump to escalation response checking (hi state)
-        if (esc_req_i) begin
-          state_d = CheckEscRespHi;
-        // abort if response is wrong
-        end else if (resp) begin
-          state_d = Idle;
-          integ_fail_o = 1'b1;
-        end
-      end
-      CheckPingResp2: begin
-        state_d = CheckPingResp3;
-        // abort sequence immediately if escalation is signalled,
-        // jump to escalation response checking (lo state)
-        if (esc_req_i) begin
-          state_d = CheckEscRespLo;
-        // abort if response is wrong
-        end else if (!resp) begin
-          state_d = Idle;
-          integ_fail_o = 1'b1;
-        end
-      end
-      CheckPingResp3: begin
-        state_d = Idle;
-        // abort sequence immediately if escalation is signalled,
-        // jump to escalation response checking (hi state)
-        if (esc_req_i) begin
-          state_d = CheckEscRespHi;
-        // abort if response is wrong
-        end else if (resp) begin
-          integ_fail_o = 1'b1;
-        end else begin
-          ping_ok_o = ping_req_i;
-        end
-      end
-      default : state_d = Idle;
-    endcase
-
-    // a sigint error will reset the state machine
-    // and have it pause for two cycles to let the
-    // receiver recover
-    if (sigint_detected) begin
-      ping_ok_o = 1'b0;
-      state_d = Idle;
-    end
-
-    // escalation takes precedence,
-    // immediately return ok in that case
-    if ((esc_req_i || esc_req_q || esc_req_q1) && ping_req_i) begin
-      ping_ok_o = 1'b1;
-    end
-  end
-
-  ///////////////
-  // Registers //
-  ///////////////
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
-    if (!rst_ni) begin
-      state_q   <= Idle;
-      esc_req_q  <= 1'b0;
-      esc_req_q1 <= 1'b0;
-      ping_req_q <= 1'b0;
-    end else begin
-      state_q   <= state_d;
-      esc_req_q  <= esc_req_d;
-      esc_req_q1 <= esc_req_q;
-      ping_req_q <= ping_req_d;
-    end
-  end
-
-  ////////////////
-  // assertions //
-  ////////////////
-
-  // check whether all outputs have a good known state after reset
-  `ASSERT_KNOWN(PingOkKnownO_A, ping_ok_o)
-  `ASSERT_KNOWN(IntegFailKnownO_A, integ_fail_o)
-  `ASSERT_KNOWN(EscPKnownO_A, esc_tx_o)
-
-  // diff encoding of output
-  `ASSERT(DiffEncCheck_A, esc_tx_o.esc_p ^ esc_tx_o.esc_n)
-  // signal integrity check propagation
-  `ASSERT(SigIntCheck0_A, esc_rx_i.resp_p == esc_rx_i.resp_n  |-> integ_fail_o)
-  // this happens in case we did not get a correct escalation response
-  `ASSERT(SigIntCheck1_A, ##1 $rose(esc_req_i) &&
-      state_q inside {Idle, CheckPingResp1, CheckPingResp3} ##1 !esc_rx_i.resp_p |->
-      integ_fail_o, clk_i, !rst_ni || (esc_rx_i.resp_p == esc_rx_i.resp_n) ||
-      (state_q == Idle && resp))
-  `ASSERT(SigIntCheck2_A, ##1 $rose(esc_req_i) &&
-      state_q inside {CheckPingResp0, CheckPingResp2} ##1 esc_rx_i.resp_p |->
-      integ_fail_o, clk_i, !rst_ni || (esc_rx_i.resp_p == esc_rx_i.resp_n) ||
-      (state_q == Idle && resp))
-  // unexpected response
-  `ASSERT(SigIntCheck3_A, state_q == Idle && resp |-> integ_fail_o)
-  // signal_int_backward_check
-  `ASSERT(SigIntBackCheck_A, integ_fail_o |-> (esc_rx_i.resp_p == esc_rx_i.resp_n) ||
-      (esc_rx_i.resp_p && !(state_q == CheckEscRespHi)) ||
-      (!esc_rx_i.resp_p && !(state_q == CheckEscRespLo)))
-  // state machine CheckEscRespLo and Hi as they are ideal resp signals
-  `ASSERT(StateEscRespHiCheck_A, state_q == CheckEscRespLo && esc_tx_o.esc_p && !integ_fail_o |=>
-      state_q == CheckEscRespHi)
-  `ASSERT(StateEscRespLoCheck_A, state_q == CheckEscRespHi && esc_tx_o.esc_p && !integ_fail_o |=>
-      state_q == CheckEscRespLo)
-  `ASSERT(StateEscRespHiBackCheck_A, state_q == CheckEscRespHi |-> $past(esc_tx_o.esc_p))
-  `ASSERT(StateEscRespLoBackCheck_A, state_q == CheckEscRespLo |-> $past(esc_tx_o.esc_p))
-  // check that escalation signal is at least 2 cycles high
-  `ASSERT(EscCheck_A, esc_req_i |-> esc_tx_o.esc_p [*2] )
-  // escalation / ping collision
-  `ASSERT(EscPingCheck_A, esc_req_i && ping_req_i |-> ping_ok_o)
-  // check that ping request results in only a single cycle pulse
-  `ASSERT(PingCheck_A, ##1 $rose(ping_req_i) |-> esc_tx_o.esc_p ##1 !esc_tx_o.esc_p , clk_i,
-      !rst_ni || esc_req_i || integ_fail_o)
-
-endmodule : prim_esc_sender
diff --git a/prim_fifo_async.sv b/prim_fifo_async.sv
deleted file mode 100644
index e2f2d07a..00000000
--- a/prim_fifo_async.sv
+++ /dev/null
@@ -1,286 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Generic asynchronous fifo for use in a variety of devices.
-
-`include "prim_assert.sv"
-
-module prim_fifo_async #(
-  parameter  int unsigned Width  = 16,
-  parameter  int unsigned Depth  = 4,
-  parameter  bit OutputZeroIfEmpty = 1'b0, // if == 1 always output 0 when FIFO is empty
-  localparam int unsigned DepthW = $clog2(Depth+1) // derived parameter representing [0..Depth]
-) (
-  // write port
-  input  logic              clk_wr_i,
-  input  logic              rst_wr_ni,
-  input  logic              wvalid_i,
-  output logic              wready_o,
-  input  logic [Width-1:0]  wdata_i,
-  output logic [DepthW-1:0] wdepth_o,
-
-  // read port
-  input  logic              clk_rd_i,
-  input  logic              rst_rd_ni,
-  output logic              rvalid_o,
-  input  logic              rready_i,
-  output logic [Width-1:0]  rdata_o,
-  output logic [DepthW-1:0] rdepth_o
-);
-
-  // Depth must be a power of 2 for the gray code pointers to work
-  `ASSERT_INIT(ParamCheckDepth_A, (Depth == 2**$clog2(Depth)))
-
-  localparam int unsigned PTRV_W    = (Depth == 1) ? 1 : $clog2(Depth);
-  localparam int unsigned PTR_WIDTH = (Depth == 1) ? 1 : PTRV_W+1;
-
-  logic [PTR_WIDTH-1:0] fifo_wptr_q, fifo_wptr_d;
-  logic [PTR_WIDTH-1:0] fifo_rptr_q, fifo_rptr_d;
-  logic [PTR_WIDTH-1:0] fifo_wptr_sync_combi, fifo_rptr_sync_combi;
-  logic [PTR_WIDTH-1:0] fifo_wptr_gray_sync, fifo_rptr_gray_sync, fifo_rptr_sync_q;
-  logic [PTR_WIDTH-1:0] fifo_wptr_gray_q, fifo_wptr_gray_d;
-  logic [PTR_WIDTH-1:0] fifo_rptr_gray_q, fifo_rptr_gray_d;
-  logic                 fifo_incr_wptr, fifo_incr_rptr;
-  logic                 full_wclk, full_rclk, empty_rclk;
-  logic [Width-1:0]     storage [Depth];
-
-  ///////////////////
-  // Write Pointer //
-  ///////////////////
-
-  assign fifo_incr_wptr = wvalid_i & wready_o;
-
-  // decimal version
-  assign fifo_wptr_d = fifo_wptr_q + PTR_WIDTH'(1'b1);
-
-  always_ff @(posedge clk_wr_i or negedge rst_wr_ni) begin
-    if (!rst_wr_ni) begin
-      fifo_wptr_q <= '0;
-    end else if (fifo_incr_wptr) begin
-      fifo_wptr_q <= fifo_wptr_d;
-    end
-  end
-
-  // gray-coded version
-  always_ff @(posedge clk_wr_i or negedge rst_wr_ni) begin
-    if (!rst_wr_ni) begin
-      fifo_wptr_gray_q <= '0;
-    end else if (fifo_incr_wptr) begin
-      fifo_wptr_gray_q <= fifo_wptr_gray_d;
-    end
-  end
-
-  // sync gray-coded pointer to read clk
-  prim_flop_2sync #(.Width(PTR_WIDTH)) sync_wptr (
-    .clk_i    (clk_rd_i),
-    .rst_ni   (rst_rd_ni),
-    .d_i      (fifo_wptr_gray_q),
-    .q_o      (fifo_wptr_gray_sync));
-
-  //////////////////
-  // Read Pointer //
-  //////////////////
-
-  assign fifo_incr_rptr = rvalid_o & rready_i;
-
-  // decimal version
-  assign fifo_rptr_d = fifo_rptr_q + PTR_WIDTH'(1'b1);
-
-  always_ff @(posedge clk_rd_i or negedge rst_rd_ni) begin
-    if (!rst_rd_ni) begin
-      fifo_rptr_q <= '0;
-    end else if (fifo_incr_rptr) begin
-      fifo_rptr_q <= fifo_rptr_d;
-    end
-  end
-
-  // gray-coded version
-  always_ff @(posedge clk_rd_i or negedge rst_rd_ni) begin
-    if (!rst_rd_ni) begin
-      fifo_rptr_gray_q <= '0;
-    end else if (fifo_incr_rptr) begin
-      fifo_rptr_gray_q <= fifo_rptr_gray_d;
-    end
-  end
-
-  // sync gray-coded pointer to write clk
-  prim_flop_2sync #(.Width(PTR_WIDTH)) sync_rptr (
-    .clk_i    (clk_wr_i),
-    .rst_ni   (rst_wr_ni),
-    .d_i      (fifo_rptr_gray_q),
-    .q_o      (fifo_rptr_gray_sync));
-
-  // Registered version of synced read pointer
-  always_ff @(posedge clk_wr_i or negedge rst_wr_ni) begin
-    if (!rst_wr_ni) begin
-      fifo_rptr_sync_q <= '0;
-    end else begin
-      fifo_rptr_sync_q <= fifo_rptr_sync_combi;
-    end
-  end
-
-  //////////////////
-  // Empty / Full //
-  //////////////////
-
-  logic [PTR_WIDTH-1:0] xor_mask;
-  assign xor_mask   =  PTR_WIDTH'(1'b1) << (PTR_WIDTH-1);
-  assign full_wclk  = (fifo_wptr_q == (fifo_rptr_sync_q ^ xor_mask));
-  assign full_rclk  = (fifo_wptr_sync_combi == (fifo_rptr_q ^ xor_mask));
-  assign empty_rclk = (fifo_wptr_sync_combi ==  fifo_rptr_q);
-
-  if (Depth > 1) begin : g_depth_calc
-
-    // Current depth in the write clock side
-    logic               wptr_msb;
-    logic               rptr_sync_msb;
-    logic  [PTRV_W-1:0] wptr_value;
-    logic  [PTRV_W-1:0] rptr_sync_value;
-
-    assign wptr_msb        = fifo_wptr_q[PTR_WIDTH-1];
-    assign rptr_sync_msb   = fifo_rptr_sync_q[PTR_WIDTH-1];
-    assign wptr_value      = fifo_wptr_q[0+:PTRV_W];
-    assign rptr_sync_value = fifo_rptr_sync_q[0+:PTRV_W];
-    assign wdepth_o = (full_wclk) ? DepthW'(Depth) :
-                      (wptr_msb == rptr_sync_msb) ? DepthW'(wptr_value) - DepthW'(rptr_sync_value) :
-                      (DepthW'(Depth) - DepthW'(rptr_sync_value) + DepthW'(wptr_value)) ;
-
-    // Current depth in the read clock side
-    logic               rptr_msb;
-    logic               wptr_sync_msb;
-    logic  [PTRV_W-1:0] rptr_value;
-    logic  [PTRV_W-1:0] wptr_sync_value;
-
-    assign wptr_sync_msb   = fifo_wptr_sync_combi[PTR_WIDTH-1];
-    assign rptr_msb        = fifo_rptr_q[PTR_WIDTH-1];
-    assign wptr_sync_value = fifo_wptr_sync_combi[0+:PTRV_W];
-    assign rptr_value      = fifo_rptr_q[0+:PTRV_W];
-    assign rdepth_o = (full_rclk) ? DepthW'(Depth) :
-                      (wptr_sync_msb == rptr_msb) ? DepthW'(wptr_sync_value) - DepthW'(rptr_value) :
-                      (DepthW'(Depth) - DepthW'(rptr_value) + DepthW'(wptr_sync_value)) ;
-
-  end else begin : g_no_depth_calc
-
-    assign rdepth_o = full_rclk;
-    assign wdepth_o = full_wclk;
-
-  end
-
-  assign wready_o = ~full_wclk;
-  assign rvalid_o = ~empty_rclk;
-
-  /////////////
-  // Storage //
-  /////////////
-
-  logic [Width-1:0] rdata_int;
-  if (Depth > 1) begin : g_storage_mux
-
-    always_ff @(posedge clk_wr_i) begin
-      if (fifo_incr_wptr) begin
-        storage[fifo_wptr_q[PTRV_W-1:0]] <= wdata_i;
-      end
-    end
-
-    assign rdata_int = storage[fifo_rptr_q[PTRV_W-1:0]];
-
-  end else begin : g_storage_simple
-
-    always_ff @(posedge clk_wr_i) begin
-      if (fifo_incr_wptr) begin
-        storage[0] <= wdata_i;
-      end
-    end
-
-    assign rdata_int = storage[0];
-
-  end
-
-  if (OutputZeroIfEmpty == 1'b1) begin : gen_output_zero
-    assign rdata_o = empty_rclk ? '0 : rdata_int;
-  end else begin : gen_no_output_zero
-    assign rdata_o = rdata_int;
-  end
-
-  //////////////////////////////////////
-  // Decimal <-> Gray-code Conversion //
-  //////////////////////////////////////
-
-  // This code is all in a generate context to avoid lint errors when Depth <= 2
-  if (Depth > 2) begin : g_full_gray_conversion
-
-    function automatic [PTR_WIDTH-1:0] dec2gray(input logic [PTR_WIDTH-1:0] decval);
-      logic [PTR_WIDTH-1:0] decval_sub;
-      logic [PTR_WIDTH-1:0] decval_in;
-      logic                 unused_decval_msb;
-
-      decval_sub = (PTR_WIDTH)'(Depth) - {1'b0, decval[PTR_WIDTH-2:0]} - 1'b1;
-
-      decval_in = decval[PTR_WIDTH-1] ? decval_sub : decval;
-
-      // We do not care about the MSB, hence we mask it out
-      unused_decval_msb = decval_in[PTR_WIDTH-1];
-      decval_in[PTR_WIDTH-1] = 1'b0;
-
-      // Perform the XOR conversion
-      dec2gray = decval_in;
-      dec2gray ^= (decval_in >> 1);
-
-      // Override the MSB
-      dec2gray[PTR_WIDTH-1] = decval[PTR_WIDTH-1];
-    endfunction
-
-    // Algorithm walks up from 0..N-1 then flips the upper bit and walks down from N-1 to 0.
-    function automatic [PTR_WIDTH-1:0] gray2dec(input logic [PTR_WIDTH-1:0] grayval);
-      logic [PTR_WIDTH-1:0] dec_tmp, dec_tmp_sub;
-      logic                 unused_decsub_msb;
-
-      dec_tmp = '0;
-      for (int i = PTR_WIDTH-2; i >= 0; i--) begin
-        dec_tmp[i] = dec_tmp[i+1] ^ grayval[i];
-      end
-      dec_tmp_sub = (PTR_WIDTH)'(Depth) - dec_tmp - 1'b1;
-      if (grayval[PTR_WIDTH-1]) begin
-        gray2dec = dec_tmp_sub;
-        // Override MSB
-        gray2dec[PTR_WIDTH-1] = 1'b1;
-        unused_decsub_msb = dec_tmp_sub[PTR_WIDTH-1];
-      end else begin
-        gray2dec = dec_tmp;
-      end
-    endfunction
-
-    // decimal version of read pointer in write domain
-    assign fifo_rptr_sync_combi = gray2dec(fifo_rptr_gray_sync);
-    // decimal version of write pointer in read domain
-    assign fifo_wptr_sync_combi = gray2dec(fifo_wptr_gray_sync);
-
-    assign fifo_rptr_gray_d = dec2gray(fifo_rptr_d);
-    assign fifo_wptr_gray_d = dec2gray(fifo_wptr_d);
-
-  end else if (Depth == 2) begin : g_simple_gray_conversion
-
-    assign fifo_rptr_sync_combi = {fifo_rptr_gray_sync[PTR_WIDTH-1], ^fifo_rptr_gray_sync};
-    assign fifo_wptr_sync_combi = {fifo_wptr_gray_sync[PTR_WIDTH-1], ^fifo_wptr_gray_sync};
-
-    assign fifo_rptr_gray_d = {fifo_rptr_d[PTR_WIDTH-1], ^fifo_rptr_d};
-    assign fifo_wptr_gray_d = {fifo_wptr_d[PTR_WIDTH-1], ^fifo_wptr_d};
-
-  end else begin : g_no_gray_conversion
-
-    assign fifo_rptr_sync_combi = fifo_rptr_gray_sync;
-    assign fifo_wptr_sync_combi = fifo_wptr_gray_sync;
-
-    assign fifo_rptr_gray_d = fifo_rptr_d;
-    assign fifo_wptr_gray_d = fifo_wptr_d;
-
-  end
-
-  // TODO: assertions on full, empty
-  `ASSERT(GrayWptr_A, ##1 $countones(fifo_wptr_gray_q ^ $past(fifo_wptr_gray_q)) <= 1,
-          clk_wr_i, !rst_wr_ni)
-  `ASSERT(GrayRptr_A, ##1 $countones(fifo_rptr_gray_q ^ $past(fifo_rptr_gray_q)) <= 1,
-          clk_rd_i, !rst_rd_ni)
-
-endmodule
diff --git a/prim_fifo_async_sram_adapter.sv b/prim_fifo_async_sram_adapter.sv
deleted file mode 100644
index 590ecd14..00000000
--- a/prim_fifo_async_sram_adapter.sv
+++ /dev/null
@@ -1,439 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Generic Asynchronous SRAM FIFO (Dual port SRAM)
-
-`include "prim_assert.sv"
-
-module prim_fifo_async_sram_adapter #(
-  parameter int unsigned Width = 32,
-  parameter int unsigned Depth = 16,
-
-  // SRAM parameters
-  parameter int unsigned       SramAw = 16,
-
-  // If SramDw > Width, upper data bits are 0.
-  parameter int unsigned       SramDw = 32,
-  parameter logic [SramAw-1:0] SramBaseAddr = 'h 0,
-
-  // derived
-  localparam int unsigned DepthW = $clog2(Depth+1)
-) (
-  // Write port
-  input                     clk_wr_i,
-  input                     rst_wr_ni,
-  input                     wvalid_i,
-  output logic              wready_o,
-  input        [Width-1:0]  wdata_i,
-  output logic [DepthW-1:0] wdepth_o,
-
-  // Read port
-  input                     clk_rd_i,
-  input                     rst_rd_ni,
-  output logic              rvalid_o,
-  input                     rready_i,
-  output logic [Width-1:0]  rdata_o,
-  output logic [DepthW-1:0] rdepth_o,
-
-  output logic r_full_o,
-  output logic r_notempty_o,
-
-  output logic w_full_o,
-
-  // TODO: watermark(threshold) ?
-
-  // SRAM interface
-  // Write SRAM port
-  output logic              w_sram_req_o,
-  input                     w_sram_gnt_i,
-  output logic              w_sram_write_o,
-  output logic [SramAw-1:0] w_sram_addr_o,
-  output logic [SramDw-1:0] w_sram_wdata_o,
-  output logic [SramDw-1:0] w_sram_wmask_o,
-  input                     w_sram_rvalid_i, // not used
-  input        [SramDw-1:0] w_sram_rdata_i,  // not used
-  input        [1:0]        w_sram_rerror_i, // not used
-
-  // Read SRAM port
-  output logic              r_sram_req_o,
-  input                     r_sram_gnt_i,
-  output logic              r_sram_write_o,
-  output logic [SramAw-1:0] r_sram_addr_o,
-  output logic [SramDw-1:0] r_sram_wdata_o, // not used
-  output logic [SramDw-1:0] r_sram_wmask_o, // not used
-  input                     r_sram_rvalid_i,
-  input        [SramDw-1:0] r_sram_rdata_i,
-  input        [1:0]        r_sram_rerror_i
-);
-
-  ////////////////
-  // Definition //
-  ////////////////
-  // w_: write clock domain signals
-  // r_: read clock domain signals
-
-  // PtrVW: Pointer Value (without msb, flip) width
-  localparam int unsigned PtrVW = $clog2(Depth);
-  // PtrW: Read/Write pointer with flip bit
-  localparam int unsigned PtrW  = PtrVW+1;
-
-  ////////////
-  // Signal //
-  ////////////
-
-  logic [PtrW-1:0]  w_wptr_q, w_wptr_d, w_wptr_gray_d, w_wptr_gray_q;
-  logic [PtrW-1:0]  r_wptr_gray, r_wptr;
-  logic [PtrVW-1:0] w_wptr_v, r_wptr_v;
-  logic             w_wptr_p, r_wptr_p; // phase
-
-  logic [PtrW-1:0]  r_rptr_q, r_rptr_d, r_rptr_gray_d, r_rptr_gray_q;
-  logic [PtrW-1:0]  w_rptr_gray, w_rptr;
-  logic [PtrVW-1:0] r_rptr_v, w_rptr_v;
-  logic             r_rptr_p, w_rptr_p; // phase
-
-  logic w_wptr_inc, r_rptr_inc;
-
-  logic w_full, r_full, r_empty;
-
-  // SRAM response one clock delayed. So store the value into read clock
-  // domain
-  logic             stored;
-  logic [Width-1:0] rdata_q, rdata_d;
-
-  // SRAM has another read pointer (for address of SRAM req)
-  // It is -1 of r_rptr if stored, else same to r_rptr
-  logic            r_sram_rptr_inc;
-  logic [PtrW-1:0] r_sram_rptr;
-
-  // r_sram_rptr == r_wptr
-  // Used to determine r_sram_req
-  logic r_sramrptr_empty;
-
-  logic rfifo_ack; // Used to check if FIFO read interface consumes a data
-  logic rsram_ack;
-
-  //////////////
-  // Datapath //
-  //////////////
-
-  // Begin: Write pointer sync to read clock ========================
-  assign w_wptr_inc = wvalid_i & wready_o;
-
-  assign w_wptr_d = w_wptr_q + PtrW'(1);
-
-  always_ff @(posedge clk_wr_i or negedge rst_wr_ni) begin
-    if (!rst_wr_ni) begin
-      w_wptr_q      <= PtrW'(0);
-      w_wptr_gray_q <= PtrW'(0);
-    end else if (w_wptr_inc) begin
-      w_wptr_q      <= w_wptr_d;
-      w_wptr_gray_q <= w_wptr_gray_d;
-    end
-  end
-
-  assign w_wptr_v = w_wptr_q[0+:PtrVW];
-  assign w_wptr_p = w_wptr_q[PtrW-1];
-
-  assign w_wptr_gray_d = dec2gray(w_wptr_d);
-
-  prim_flop_2sync #(
-    .Width (PtrW)
-  ) u_sync_wptr_gray (
-    .clk_i  (clk_rd_i),
-    .rst_ni (rst_rd_ni),
-    .d_i    (w_wptr_gray_q),
-    .q_o    (r_wptr_gray)
-  );
-
-  assign r_wptr   = gray2dec(r_wptr_gray);
-  assign r_wptr_p = r_wptr[PtrW-1];
-  assign r_wptr_v = r_wptr[0+:PtrVW];
-
-  assign wdepth_o = (w_wptr_p == w_rptr_p)
-                  ? DepthW'(w_wptr_v - w_rptr_v)
-                  : DepthW'({1'b1, w_wptr_v} - {1'b 0, w_rptr_v});
-  // End:   Write pointer sync to read clock ------------------------
-
-  // Begin: Read pointer sync to write clock ========================
-  //assign r_rptr_inc = rvalid_o & rready_i;
-  //assign r_rptr_inc = r_sram_req_o && r_sram_gnt_i;
-  // Increase the read pointer (crossing the clock domain) only when the
-  // reader acked.
-  assign r_rptr_inc = rfifo_ack;
-
-  assign r_rptr_d = r_rptr_q + PtrW'(1);
-
-  always_ff @(posedge clk_rd_i or negedge rst_rd_ni) begin
-    if (!rst_rd_ni) begin
-      r_rptr_q      <= PtrW'(0);
-      r_rptr_gray_q <= PtrW'(0);
-    end else if (r_rptr_inc) begin
-      r_rptr_q      <= r_rptr_d;
-      r_rptr_gray_q <= r_rptr_gray_d;
-    end
-  end
-
-  assign r_rptr_v = r_rptr_q[0+:PtrVW];
-  assign r_rptr_p = r_rptr_q[PtrW-1];
-
-  assign r_rptr_gray_d = dec2gray(r_rptr_d);
-
-  prim_flop_2sync #(
-    .Width (PtrW)
-  ) u_sync_rptr_gray (
-    .clk_i  (clk_wr_i),
-    .rst_ni (rst_wr_ni),
-    .d_i    (r_rptr_gray_q),
-    .q_o    (w_rptr_gray)
-  );
-
-  assign w_rptr = gray2dec(w_rptr_gray);
-  assign w_rptr_p = w_rptr[PtrW-1];
-  assign w_rptr_v = w_rptr[0+:PtrVW];
-
-  assign rdepth_o = (r_wptr_p == r_rptr_p)
-                  ? DepthW'(r_wptr_v - r_rptr_v)
-                  : DepthW'({1'b1, r_wptr_v} - {1'b 0, r_rptr_v});
-  // End:   Read pointer sync to write clock ------------------------
-
-  // Begin: SRAM Read pointer
-  assign r_sram_rptr_inc = rsram_ack;
-
-  always_ff @(posedge clk_rd_i or negedge rst_rd_ni) begin
-    if (!rst_rd_ni) begin
-      r_sram_rptr <= PtrW'(0);
-    end else if (r_sram_rptr_inc) begin
-      r_sram_rptr <= r_sram_rptr + PtrW'(1);
-    end
-  end
-
-  assign r_sramrptr_empty = (r_wptr == r_sram_rptr);
-  // End:   SRAM Read pointer
-
-  // Full/ Empty
-  // Lint complains PtrW'(1) << (PtrW-1). So changed as below
-  localparam logic [PtrW-1:0] XorMask = {1'b 1, {PtrW-1{1'b0}}};
-  assign w_full  = (w_wptr_q == (w_rptr   ^ XorMask));
-  assign r_full  = (r_wptr   == (r_rptr_q ^ XorMask));
-  assign r_empty = (r_wptr   == r_rptr_q);
-
-  logic  unused_r_empty;
-  assign unused_r_empty = r_empty;
-
-  assign r_full_o     = r_full;
-  assign w_full_o     = w_full;
-
-  // The notempty status !(wptr == rptr) assert one clock earlier than the
-  // actual `rvalid` signals.
-  //
-  // The reason is due to the SRAM read latency. The module uses SRAM FIFO
-  // interface. When the logic in producer domain pushes entries, the pointer
-  // is increased. This triggers the FIFO logic in the consumer clock domain
-  // fetches data from SRAM.
-  //
-  // The pointer crosses the clock boundary. It takes usually two cycles (in
-  // the consumer side). Then, as the read and write pointer in the read clock
-  // domain has a gap by 1, the FIFO not empty status is raised.
-  //
-  // At this time, the logic just sent the read request to the SRAM. The data
-  // is not yet read. The `rvalid` asserts when it receives data from the
-  // SRAM.
-  //
-  // So, if the consumer reads data at the same cycle when notempty status is
-  // raised, it reads incorrect data.
-  assign r_notempty_o = rvalid_o;
-
-  assign rsram_ack = r_sram_req_o && r_sram_gnt_i;
-  assign rfifo_ack = rvalid_o     && rready_i;
-
-  // SRAM Write Request
-  assign w_sram_req_o   = wvalid_i && !w_full;
-  assign wready_o       = !w_full && w_sram_gnt_i;
-  assign w_sram_write_o = 1'b 1; // Always write
-  assign w_sram_addr_o  = SramBaseAddr + SramAw'(w_wptr_v);
-
-  assign w_sram_wdata_o = SramDw'(wdata_i);
-  assign w_sram_wmask_o = SramDw'({Width{1'b1}});
-
-  logic unused_w_sram;
-  assign unused_w_sram = ^{w_sram_rvalid_i, w_sram_rdata_i, w_sram_rerror_i};
-
-  // SRAM Read Request
-  // Request Scenario (!r_empty):
-  //  - storage empty: Send request if
-  //               !r_sram_rvalid_i || (rfifo_ack && r_sram_rvalid_i);
-  //  - storage !empty: depends on the rfifo_ack:
-  //    - r_rptr_inc: Can request more
-  //    - !r_rptr_inc: Can't request
-  always_comb begin : r_sram_req
-    r_sram_req_o = 1'b 0;
-    // Karnough Map (!empty): sram_req
-    // {sram_rv, rfifo_ack} | 00 | 01          | 11 | 10
-    // ----------------------------------------------------------
-    // stored          | 0  |  1 |  impossible |  1 |  0
-    //                 | 1  |  0 |  1          |  X |  impossible
-    //
-    // req_o = r_ptr_inc || (!stored && !r_sram_rvalid_i)
-
-    if (stored) begin
-      // storage has data. depends on rfifo_ack
-      // rfifo_ack can be replaced to rready_i as `rvalid_o` is 1
-      r_sram_req_o = !r_sramrptr_empty && rfifo_ack;
-    end else begin
-      // storage has no data.
-      // Can send request only when the reader accept the request or no
-      // previous request sent out.
-      r_sram_req_o = !r_sramrptr_empty && !(r_sram_rvalid_i ^ rfifo_ack);
-    end
-  end : r_sram_req
-
-  assign rvalid_o       = stored || r_sram_rvalid_i;
-  assign r_sram_write_o = 1'b 0; // always read
-  assign r_sram_wdata_o = '0;
-  assign r_sram_wmask_o = '0;
-
-  // Send SRAM request with sram read pointer.
-  assign r_sram_addr_o  = SramBaseAddr + SramAw'(r_sram_rptr[0+:PtrVW]);
-
-  assign rdata_d = (r_sram_rvalid_i) ? r_sram_rdata_i[0+:Width] : Width'(0);
-
-  assign rdata_o = (stored) ? rdata_q : rdata_d;
-
-  logic unused_rsram;
-  assign unused_rsram = ^{r_sram_rerror_i};
-
-  if (Width < SramDw) begin : g_unused_rdata
-    logic unused_rdata;
-    assign unused_rdata = ^r_sram_rdata_i[SramDw-1:Width];
-  end : g_unused_rdata
-
-  // read clock domain rdata storage
-  logic store;
-
-  // Karnough Map (r_sram_rvalid_i):
-  // rfifo_ack   | 0 | 1 |
-  // ---------------------
-  // stored    0 | 1 | 0 |
-  //           1 | 0 | 1 |
-  //
-  // stored = s.r.v && XNOR(stored, rptr_inc)
-  assign store = r_sram_rvalid_i && !(stored ^ rfifo_ack);
-
-  always_ff @(posedge clk_rd_i or negedge rst_rd_ni) begin
-    if (!rst_rd_ni) begin
-      stored <= 1'b 0;
-      rdata_q <= Width'(0);
-    end else if (store) begin
-      stored <= 1'b 1;
-      rdata_q <= rdata_d;
-    end else if (!r_sram_rvalid_i && rfifo_ack) begin
-      // No request sent, host reads the data
-      stored <= 1'b 0;
-      rdata_q <= Width'(0);
-    end
-  end
-
-  //////////////
-  // Function //
-  //////////////
-
-  // dec2gray / gray2dec copied from prim_fifo_async.sv
-  function automatic [PtrW-1:0] dec2gray(input logic [PtrW-1:0] decval);
-    logic [PtrW-1:0] decval_sub;
-    logic [PtrW-1:0] decval_in;
-    logic            unused_decval_msb;
-
-    decval_sub = (PtrW)'(Depth) - {1'b0, decval[PtrW-2:0]} - 1'b1;
-
-    decval_in = decval[PtrW-1] ? decval_sub : decval;
-
-    // We do not care about the MSB, hence we mask it out
-    unused_decval_msb = decval_in[PtrW-1];
-    decval_in[PtrW-1] = 1'b0;
-
-    // Perform the XOR conversion
-    dec2gray = decval_in;
-    dec2gray ^= (decval_in >> 1);
-
-    // Override the MSB
-    dec2gray[PtrW-1] = decval[PtrW-1];
-  endfunction
-
-  // Algorithm walks up from 0..N-1 then flips the upper bit and walks down from N-1 to 0.
-  function automatic [PtrW-1:0] gray2dec(input logic [PtrW-1:0] grayval);
-    logic [PtrW-1:0] dec_tmp, dec_tmp_sub;
-    logic            unused_decsub_msb;
-
-    dec_tmp = '0;
-    for (int i = PtrW-2; i >= 0; i--) begin
-      dec_tmp[i] = dec_tmp[i+1] ^ grayval[i];
-    end
-    dec_tmp_sub = (PtrW)'(Depth) - dec_tmp - 1'b1;
-    if (grayval[PtrW-1]) begin
-      gray2dec = dec_tmp_sub;
-      // Override MSB
-      gray2dec[PtrW-1] = 1'b1;
-      unused_decsub_msb = dec_tmp_sub[PtrW-1];
-    end else begin
-      gray2dec = dec_tmp;
-    end
-  endfunction
-
-  ///////////////
-  // Assertion //
-  ///////////////
-
-  `ASSERT_INIT(ParamCheckDepth_A, (Depth == 2**$clog2(Depth)))
-
-  // Use FF if less than 4.
-  `ASSERT_INIT(MinDepth_A, Depth >= 4)
-
-  // SramDw greather than or equal to Width
-  `ASSERT_INIT(WidthMatch_A, SramDw >= Width)
-
-  // Not stored, Not read valid, but rptr_inc case is impossible
-  `ASSERT(RptrIncDataValid_A,
-          r_rptr_inc |-> stored || r_sram_rvalid_i,
-          clk_rd_i, !rst_rd_ni)
-  `ASSERT(SramRvalid_A,
-          r_sram_rvalid_i |-> !stored || r_rptr_inc,
-          clk_rd_i, !rst_rd_ni)
-
-  // FIFO interface
-  `ASSERT(NoWAckInFull_A, w_wptr_inc |-> !w_full,
-          clk_wr_i, !rst_wr_ni)
-
-  `ASSERT(WptrIncrease_A,
-          w_wptr_inc |=> w_wptr_v == PtrVW'($past(w_wptr_v,2) + 1),
-          clk_wr_i, !rst_wr_ni)
-  `ASSERT(WptrGrayOneBitAtATime_A,
-          w_wptr_inc |=> $countones(w_wptr_gray_q ^ $past(w_wptr_gray_q,2)) == 1,
-          clk_wr_i, !rst_wr_ni)
-
-  `ASSERT(NoRAckInEmpty_A, r_rptr_inc |-> !r_empty,
-          clk_rd_i, !rst_rd_ni)
-
-  `ASSERT(RptrIncrease_A,
-          r_rptr_inc |=> PtrVW'($past(r_rptr_v) + 1) == r_rptr_v,
-          clk_rd_i, !rst_rd_ni)
-  `ASSERT(RptrGrayOneBitAtATime_A,
-          r_rptr_inc |=> $countones(r_rptr_gray_q ^ $past(r_rptr_gray_q)) == 1,
-          clk_rd_i, !rst_rd_ni)
-
-  // SRAM interface
-  `ASSERT(WSramRvalid_A, !w_sram_rvalid_i, clk_wr_i, !rst_wr_ni)
-  `ASSUME_FPV(WSramRdataError_M, w_sram_rdata_i == '0 && w_sram_rerror_i == '0,
-              clk_wr_i, !rst_wr_ni)
-
-  `ASSUME(RSramRvalidOneCycle_M,
-          r_sram_req_o && r_sram_gnt_i |=> r_sram_rvalid_i,
-          clk_rd_i, !rst_rd_ni)
-  `ASSUME_FPV(RErrorTied_M, r_sram_rerror_i == '0,
-              clk_rd_i, !rst_rd_ni)
-
-
-  // FPV coverage
-  `COVER_FPV(WFull_C, w_full, clk_wr_i, !rst_wr_ni)
-
-endmodule : prim_fifo_async_sram_adapter
diff --git a/prim_fifo_sync.sv b/prim_fifo_sync.sv
deleted file mode 100644
index 77b8230f..00000000
--- a/prim_fifo_sync.sv
+++ /dev/null
@@ -1,178 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Generic synchronous fifo for use in a variety of devices.
-
-`include "prim_assert.sv"
-
-module prim_fifo_sync #(
-  parameter int unsigned Width       = 16,
-  parameter bit Pass                 = 1'b1, // if == 1 allow requests to pass through empty FIFO
-  parameter int unsigned Depth       = 4,
-  parameter bit OutputZeroIfEmpty    = 1'b1, // if == 1 always output 0 when FIFO is empty
-  // derived parameter
-  localparam int          DepthW     = prim_util_pkg::vbits(Depth+1)
-) (
-  input                   clk_i,
-  input                   rst_ni,
-  // synchronous clear / flush port
-  input                   clr_i,
-  // write port
-  input                   wvalid_i,
-  output                  wready_o,
-  input   [Width-1:0]     wdata_i,
-  // read port
-  output                  rvalid_o,
-  input                   rready_i,
-  output  [Width-1:0]     rdata_o,
-  // occupancy
-  output                  full_o,
-  output  [DepthW-1:0]    depth_o
-);
-
-
-  // FIFO is in complete passthrough mode
-  if (Depth == 0) begin : gen_passthru_fifo
-    `ASSERT_INIT(paramCheckPass, Pass == 1)
-
-    assign depth_o = 1'b0; //output is meaningless
-
-    // devie facing
-    assign rvalid_o = wvalid_i;
-    assign rdata_o = wdata_i;
-
-    // host facing
-    assign wready_o = rready_i;
-    assign full_o = rready_i;
-
-    // this avoids lint warnings
-    logic unused_clr;
-    assign unused_clr = clr_i;
-
-  // Normal FIFO construction
-  end else begin : gen_normal_fifo
-
-    localparam int unsigned PTRV_W    = prim_util_pkg::vbits(Depth);
-    localparam int unsigned PTR_WIDTH = PTRV_W+1;
-
-    logic [PTR_WIDTH-1:0] fifo_wptr, fifo_rptr;
-    logic                 fifo_incr_wptr, fifo_incr_rptr, fifo_empty;
-
-    // module under reset flag
-    logic under_rst;
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-        under_rst <= 1'b1;
-      end else if (under_rst) begin
-        under_rst <= ~under_rst;
-      end
-    end
-
-    // create the write and read pointers
-    logic  full, empty;
-    logic  wptr_msb;
-    logic  rptr_msb;
-    logic  [PTRV_W-1:0] wptr_value;
-    logic  [PTRV_W-1:0] rptr_value;
-
-    assign wptr_msb = fifo_wptr[PTR_WIDTH-1];
-    assign rptr_msb = fifo_rptr[PTR_WIDTH-1];
-    assign wptr_value = fifo_wptr[0+:PTRV_W];
-    assign rptr_value = fifo_rptr[0+:PTRV_W];
-    assign depth_o = (full)                 ? DepthW'(Depth) :
-                     (wptr_msb == rptr_msb) ? DepthW'(wptr_value) - DepthW'(rptr_value) :
-                     (DepthW'(Depth) - DepthW'(rptr_value) + DepthW'(wptr_value)) ;
-
-    assign fifo_incr_wptr = wvalid_i & wready_o & ~under_rst;
-    assign fifo_incr_rptr = rvalid_o & rready_i & ~under_rst;
-
-    // full and not ready for write are two different concepts.
-    // The latter can be '0' when under reset, while the former is an indication that no more
-    // entries can be written.
-    assign wready_o = ~full & ~under_rst;
-    assign full_o   = full;
-    assign rvalid_o = ~empty & ~under_rst;
-
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-        fifo_wptr <= {(PTR_WIDTH){1'b0}};
-      end else if (clr_i) begin
-        fifo_wptr <= {(PTR_WIDTH){1'b0}};
-      end else if (fifo_incr_wptr) begin
-        if (fifo_wptr[PTR_WIDTH-2:0] == (PTR_WIDTH-1)'(Depth-1)) begin
-          fifo_wptr <= {~fifo_wptr[PTR_WIDTH-1],{(PTR_WIDTH-1){1'b0}}};
-        end else begin
-          fifo_wptr <= fifo_wptr + {{(PTR_WIDTH-1){1'b0}},1'b1};
-        end
-      end
-    end
-
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-        fifo_rptr <= {(PTR_WIDTH){1'b0}};
-      end else if (clr_i) begin
-        fifo_rptr <= {(PTR_WIDTH){1'b0}};
-      end else if (fifo_incr_rptr) begin
-        if (fifo_rptr[PTR_WIDTH-2:0] == (PTR_WIDTH-1)'(Depth-1)) begin
-          fifo_rptr <= {~fifo_rptr[PTR_WIDTH-1],{(PTR_WIDTH-1){1'b0}}};
-        end else begin
-          fifo_rptr <= fifo_rptr + {{(PTR_WIDTH-1){1'b0}},1'b1};
-        end
-      end
-    end
-
-    assign  full       = (fifo_wptr == (fifo_rptr ^ {1'b1,{(PTR_WIDTH-1){1'b0}}}));
-    assign  fifo_empty = (fifo_wptr ==  fifo_rptr);
-
-
-    // the generate blocks below are needed to avoid lint errors due to array indexing
-    // in the where the fifo only has one storage element
-    logic [Depth-1:0][Width-1:0] storage;
-    logic [Width-1:0] storage_rdata;
-    if (Depth == 1) begin : gen_depth_eq1
-      assign storage_rdata = storage[0];
-
-      always_ff @(posedge clk_i)
-        if (fifo_incr_wptr) begin
-          storage[0] <= wdata_i;
-        end
-    // fifo with more than one storage element
-    end else begin : gen_depth_gt1
-      assign storage_rdata = storage[fifo_rptr[PTR_WIDTH-2:0]];
-
-      always_ff @(posedge clk_i)
-        if (fifo_incr_wptr) begin
-          storage[fifo_wptr[PTR_WIDTH-2:0]] <= wdata_i;
-        end
-    end
-
-    logic [Width-1:0] rdata_int;
-    if (Pass == 1'b1) begin : gen_pass
-      assign rdata_int = (fifo_empty && wvalid_i) ? wdata_i : storage_rdata;
-      assign empty = fifo_empty & ~wvalid_i;
-    end else begin : gen_nopass
-      assign rdata_int = storage_rdata;
-      assign empty = fifo_empty;
-    end
-
-    if (OutputZeroIfEmpty == 1'b1) begin : gen_output_zero
-      assign rdata_o = empty ? 'b0 : rdata_int;
-    end else begin : gen_no_output_zero
-      assign rdata_o = rdata_int;
-    end
-
-    `ASSERT(depthShallNotExceedParamDepth, !empty |-> depth_o <= DepthW'(Depth))
-  end // block: gen_normal_fifo
-
-
-  //////////////////////
-  // Known Assertions //
-  //////////////////////
-
-  `ASSERT(DataKnown_A, rvalid_o |-> !$isunknown(rdata_o))
-  `ASSERT_KNOWN(DepthKnown_A, depth_o)
-  `ASSERT_KNOWN(RvalidKnown_A, rvalid_o)
-  `ASSERT_KNOWN(WreadyKnown_A, wready_o)
-
-endmodule
diff --git a/prim_filter.sv b/prim_filter.sv
deleted file mode 100644
index a9d5dcdc..00000000
--- a/prim_filter.sv
+++ /dev/null
@@ -1,73 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Primitive input filter, with enable.  Configurable number of cycles.
-//
-// when in reset, stored vector is zero
-// when enable is false, output is input
-// when enable is true, output is stored value,
-//   new input must be opposite value from stored value for
-//   #Cycles before switching to new value.
-
-module prim_filter #(
-  // If this parameter is set, an additional 2-stage synchronizer will be
-  // added at the input.
-  parameter bit AsyncOn = 0,
-  parameter int unsigned Cycles = 4
-) (
-  input        clk_i,
-  input        rst_ni,
-  input        enable_i,
-  input        filter_i,
-  output logic filter_o
-);
-
-  logic [Cycles-1:0] stored_vector_q, stored_vector_d;
-  logic stored_value_q, update_stored_value;
-  logic unused_stored_vector_q_msb;
-
-  logic filter_synced;
-
-  if (AsyncOn) begin : gen_async
-    // Run this through a 2 stage synchronizer to
-    // prevent metastability.
-    prim_flop_2sync #(
-      .Width(1)
-    ) prim_flop_2sync (
-      .clk_i,
-      .rst_ni,
-      .d_i(filter_i),
-      .q_o(filter_synced)
-    );
-  end else begin : gen_sync
-    assign filter_synced = filter_i;
-  end
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      stored_value_q <= 1'b0;
-    end else if (update_stored_value) begin
-      stored_value_q <= filter_synced;
-    end
-  end
-
-  assign stored_vector_d = {stored_vector_q[Cycles-2:0],filter_synced};
-  assign unused_stored_vector_q_msb = stored_vector_q[Cycles-1];
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      stored_vector_q <= '0;
-    end else begin
-      stored_vector_q <= stored_vector_d;
-    end
-  end
-
-  assign update_stored_value =
-             (stored_vector_d == {Cycles{1'b0}}) |
-             (stored_vector_d == {Cycles{1'b1}});
-
-  assign filter_o = enable_i ? stored_value_q : filter_synced;
-
-endmodule
-
diff --git a/prim_filter_ctr.sv b/prim_filter_ctr.sv
deleted file mode 100644
index 435b1615..00000000
--- a/prim_filter_ctr.sv
+++ /dev/null
@@ -1,82 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Primitive counter-based input filter, with enable.
-// Configurable number of cycles. Cheaper version of filter for
-// large values of #Cycles
-//
-// when in reset, stored value is zero
-// when enable is false, output is input
-// when enable is true, output is stored value,
-//   new input must be opposite value from stored value for
-//   #Cycles before switching to new value.
-
-module prim_filter_ctr #(
-  // If this parameter is set, an additional 2-stage synchronizer will be
-  // added at the input.
-  parameter bit AsyncOn = 0,
-  parameter int unsigned CntWidth = 2
-) (
-  input                clk_i,
-  input                rst_ni,
-  input                enable_i,
-  input                filter_i,
-  input [CntWidth-1:0] thresh_i,
-  output logic         filter_o
-);
-
-  logic [CntWidth-1:0] diff_ctr_q, diff_ctr_d;
-  logic filter_q, stored_value_q, update_stored_value;
-
-  logic filter_synced;
-
-  if (AsyncOn) begin : gen_async
-    // Run this through a 2 stage synchronizer to
-    // prevent metastability.
-    prim_flop_2sync #(
-      .Width(1)
-    ) prim_flop_2sync (
-      .clk_i,
-      .rst_ni,
-      .d_i(filter_i),
-      .q_o(filter_synced)
-    );
-  end else begin : gen_sync
-    assign filter_synced = filter_i;
-  end
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      filter_q <= 1'b0;
-    end else begin
-      filter_q <= filter_synced;
-    end
-  end
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      stored_value_q <= 1'b0;
-    end else if (update_stored_value) begin
-      stored_value_q <= filter_synced;
-    end
-  end
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      diff_ctr_q <= '0;
-    end else begin
-      diff_ctr_q <= diff_ctr_d;
-    end
-  end
-
-  // always look for differences, even if not filter enabled
-  assign update_stored_value = (diff_ctr_d == thresh_i);
-  assign diff_ctr_d = (filter_synced != filter_q) ? '0       :           // restart
-                      (diff_ctr_q >= thresh_i)    ? thresh_i :           // saturate
-                                                    (diff_ctr_q + 1'b1); // count up
-
-  assign filter_o = enable_i ? stored_value_q : filter_synced;
-
-endmodule
-
diff --git a/prim_flop_2sync.sv b/prim_flop_2sync.sv
deleted file mode 100644
index f9948b03..00000000
--- a/prim_flop_2sync.sv
+++ /dev/null
@@ -1,43 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Generic double-synchronizer flop
-// This may need to be moved to prim_generic if libraries have a specific cell
-// for synchronization
-
-module prim_flop_2sync #(
-  parameter int               Width      = 16,
-  parameter logic [Width-1:0] ResetValue = '0
-) (
-  input                    clk_i,
-  input                    rst_ni,
-  input        [Width-1:0] d_i,
-  output logic [Width-1:0] q_o
-);
-
-  // TODO(#10432): Add CDC instrumentation for simulations
-
-  logic [Width-1:0] intq;
-
-  prim_flop #(
-    .Width(Width),
-    .ResetValue(ResetValue)
-  ) u_sync_1 (
-    .clk_i,
-    .rst_ni,
-    .d_i,
-    .q_o(intq)
-  );
-
-  prim_flop #(
-    .Width(Width),
-    .ResetValue(ResetValue)
-  ) u_sync_2 (
-    .clk_i,
-    .rst_ni,
-    .d_i(intq),
-    .q_o
-  );
-
-endmodule : prim_flop_2sync
diff --git a/prim_gate_gen.sv b/prim_gate_gen.sv
deleted file mode 100644
index dac761fd..00000000
--- a/prim_gate_gen.sv
+++ /dev/null
@@ -1,109 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Simple parameterizable gate generator. Used to fill up the netlist with gates that cannot be
-// optimized away.
-//
-// The module leverages 4bit SBoxes from the PRINCE cipher, and interleaves them with registers,
-// resulting in a split of around 50/50 between logic and sequential cells.
-//
-// This generator has been tested with 32bit wide data, and produces the following results:
-//
-// -------------+-----------+----------
-// requested GE | actual GE | GE error
-// -------------+-----------+----------
-// 500          |  483      |  -17
-// 1000         |  964      |  -36
-// 1500         |  1447     |  -53
-// 2500         |  2892     |  392
-// 5000         |  5299     |  299
-// 7500         |  8030     |  530
-// 10000        |  10393    |  393
-// 15000        |  15575    |  575
-// 25000        |  26422    |  1422
-// 50000        |  52859    |  2859
-// 100000       |  105270   |  5270
-//
-// Note that the generator is not very accurate for smaller gate counts due to the generate loop
-// granularity. Hence, do not use for fever than 500 GE.
-//
-// If valid_i constantly set to 1'b1, the gate generator produces around 2.5% smaller designs for
-// the configurations listed in the table above.
-
-`include "prim_assert.sv"
-module prim_gate_gen #(
-  parameter int DataWidth = 32,
-  parameter int NumGates = 1000
-) (
-  input                        clk_i,
-  input                        rst_ni,
-
-  input                        valid_i,
-  input        [DataWidth-1:0] data_i,
-  output logic [DataWidth-1:0] data_o,
-  output                       valid_o
-);
-
-  /////////////////////////////////////
-  // Local parameters and assertions //
-  /////////////////////////////////////
-
-  // technology specific tuning, do not modify.
-  // an inner round is comprised of a 2bit rotation, followed by a 4bit SBox Layer.
-  localparam int NumInnerRounds = 2;
-  localparam int GatesPerRound  = DataWidth * 14;
-  // an outer round consists of NumInnerRounds, followed by a register.
-  localparam int NumOuterRounds = (NumGates + GatesPerRound / 2) / GatesPerRound;
-
-  // do not use for fewer than 500 GE
-  `ASSERT(MinimumNumGates_A, NumGates >= 500)
-  `ASSERT(DataMustBeMultipleOfFour_A, DataWidth % 4 == 0)
-
-  /////////////////////
-  // Generator Loops //
-  /////////////////////
-
-  logic [NumOuterRounds-1:0][DataWidth-1:0] regs_d, regs_q;
-  logic [NumOuterRounds-1:0] valid_d, valid_q;
-
-  for (genvar k = 0; k < NumOuterRounds; k++) begin : gen_outer_round
-
-    logic [NumInnerRounds:0][DataWidth-1:0] inner_data;
-
-    if (k==0) begin : gen_first
-      assign inner_data[0] = data_i;
-      assign valid_d[0]    = valid_i;
-    end else begin : gen_others
-      assign inner_data[0] = regs_q[k-1];
-      assign valid_d[k]    = valid_q[k-1];
-    end
-
-    for (genvar l = 0; l < NumInnerRounds; l++) begin : gen_inner
-      // 2bit rotation + sbox layer
-      assign inner_data[l+1] = prim_cipher_pkg::sbox4_32bit({inner_data[l][1:0],
-                                                             inner_data[l][DataWidth-1:2]},
-                                                             prim_cipher_pkg::PRINCE_SBOX4);
-    end
-
-    assign regs_d[k] = inner_data[NumInnerRounds];
-  end
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
-    if (!rst_ni) begin
-      regs_q <= '0;
-      valid_q <= '0;
-    end else begin
-      valid_q <= valid_d;
-      for (int k = 0; k < NumOuterRounds; k++) begin
-        if (valid_d[k]) begin
-          regs_q[k] <= regs_d[k];
-        end
-      end
-    end
-  end
-
-  assign data_o = regs_q[NumOuterRounds-1];
-  assign valid_o = valid_q[NumOuterRounds-1];
-
-endmodule : prim_gate_gen
diff --git a/prim_gf_mult.sv b/prim_gf_mult.sv
deleted file mode 100644
index 61e75949..00000000
--- a/prim_gf_mult.sv
+++ /dev/null
@@ -1,171 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// This module performs a the multiplication of two operands in Galois field GF(2^Width) modulo the
-// provided irreducible polynomial using a parallel Mastrovito multipler [3]. To cut long paths
-// potentially occurring for large data widths, the implementation provides a parameter
-// StagesPerCycle to decompose the multiplication into Width/StagesPerCycle iterative steps
-// (Digit-Serial/Parallel Multiplier [4]).
-//
-// Note that this module is not pipelined and produces an output sample every Width/StagesPerCycle
-// cycles.
-//
-// References:
-//
-// [1] Patel, "Parallel Multiplier Designs for the Galois/Counter Mode of Operation",
-// https://pdfs.semanticscholar.org/1246/a9ad98dc0421ccfc945e6529c886f23e848d.pdf
-// [2] Wagner, "The Laws of Cryptography: The Finite Field GF(2^8)",
-// http://www.cs.utsa.edu/~wagner/laws/FFM.html
-//
-// [3]: Mastrovito, "VLSI Designs for Multiplication over Finite Fields GF(2^m)",
-// https://link.springer.com/chapter/10.1007/3-540-51083-4_67
-// [4]: Song et al., "Efficient Finite Field Serial/Parallel Multiplication",
-// https://ieeexplore.ieee.org/document/542803
-
-
-`include "prim_assert.sv"
-
-module prim_gf_mult #(
-  parameter int Width = 32,
-  parameter int StagesPerCycle = Width,
-
-  // The field-generating, irreducible polynomial of degree Width.
-  // Can for example be a Conway polynomial, see
-  // http://www.math.rwth-aachen.de/~Frank.Luebeck/data/ConwayPol/CP2.html
-  // For Width = 33, the Conway polynomial hast bits 32, 15, 9, 7, 4, 3, 0 set to one.
-  parameter logic[Width-1:0] IPoly = 1'b1 << 15 |
-                                     1'b1 << 9  |
-                                     1'b1 << 7  |
-                                     1'b1 << 4  |
-                                     1'b1 << 3  |
-                                     1'b1 << 0
-) (
-  input clk_i,
-  input rst_ni,
-  input req_i,
-  input [Width-1:0] operand_a_i,
-  input [Width-1:0] operand_b_i,
-  output logic ack_o,
-  output logic [Width-1:0] prod_o
-);
-
-  `ASSERT_INIT(IntegerLoops_A, (Width % StagesPerCycle) == 0)
-  `ASSERT_INIT(StagePow2_A, $onehot(StagesPerCycle))
-
-  localparam int Loops = Width / StagesPerCycle;
-  localparam int CntWidth = (Loops == 1) ? 1 : $clog2(Loops);
-
-  // reformat operand_b_i
-  logic [Loops-1:0][StagesPerCycle-1:0] reformat_data;
-
-  // this slice of operand bits used during each loop
-  logic [StagesPerCycle-1:0] op_i_slice;
-
-  // the matrix is made up of a series of GF(2^Width) * x
-  logic [StagesPerCycle-1:0][Width-1:0] matrix;
-
-  // since the matrix generation is not done in one go, we must remember
-  // where it last left off
-  logic [Width-1:0] vector;
-
-  // this variable tracks which loop we are currently operating
-  logic [CntWidth-1:0] cnt;
-
-  // this variable tracks the first loop through the multiply
-  logic first;
-
-  // intermediate prod held between loops
-  logic [Width-1:0] prod_q, prod_d;
-
-  // select current slice
-  assign reformat_data = operand_b_i;
-  assign op_i_slice = reformat_data[cnt];
-
-  assign first = cnt == 0;
-
-  if (StagesPerCycle == Width) begin : gen_all_combo
-
-    assign ack_o = 1'b1;
-    assign cnt = '0;
-    assign prod_q = '0;
-    assign vector = '0;
-
-  end else begin : gen_decomposed
-
-    // multiply is done
-    assign ack_o = cnt == (Loops - 1);
-
-    // advance the stage count and also advance the bit position count
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-        cnt <= '0;
-      end else if (req_i && ack_o) begin
-        cnt <= '0;
-      end else if (req_i && cnt < (Loops - 1)) begin
-        cnt <= cnt + 1'b1;
-      end
-    end
-
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-        prod_q <= '0;
-        vector <= '0;
-      end else if (ack_o) begin
-        prod_q <= '0;
-        vector <= '0;
-      end else if (req_i) begin
-        prod_q <= prod_d;
-        vector <= matrix[StagesPerCycle-1];
-      end
-    end
-  end
-
-
-  assign matrix = first ? gen_matrix(operand_a_i, 1'b1) : gen_matrix(vector, 1'b0);
-  assign prod_d = prod_q ^ gf_mult(matrix, op_i_slice);
-
-  // The output is not toggled until it is ready
-  assign prod_o = ack_o ? prod_d : operand_a_i;
-
-
-  // GF(2^Width) * x
-  function automatic logic [Width-1:0] gf_mult2(
-    logic [Width-1:0] operand
-  );
-    logic [Width-1:0] mult_out;
-    mult_out = operand[Width-1] ? (operand << 1) ^ IPoly : (operand << 1);
-    return mult_out;
-  endfunction
-
-  // Matrix generate step
-  function automatic logic [StagesPerCycle-1:0][Width-1:0] gen_matrix(
-    logic [Width-1:0] seed,
-    logic init
-  );
-    logic [StagesPerCycle-1:0][Width-1:0] matrix_out;
-
-    matrix_out[0] = init ? seed : gf_mult2(seed);
-    matrix_out[StagesPerCycle-1:1] = '0;
-    for (int i = 1; i < StagesPerCycle; i++) begin
-      matrix_out[i] = gf_mult2(matrix_out[i-1]);
-    end
-    return matrix_out;
-  endfunction
-
-  // Galois multiply step
-  function automatic logic [Width-1:0] gf_mult(
-    logic [StagesPerCycle-1:0][Width-1:0] matrix,
-    logic [StagesPerCycle-1:0] operand
-  );
-    logic [Width-1:0] mult_out;
-    logic [Width-1:0] add_vector;
-    mult_out = '0;
-    for (int i = 0; i < StagesPerCycle; i++) begin
-      add_vector = operand[i] ? matrix[i] : '0;
-      mult_out = mult_out ^ add_vector;
-    end
-    return mult_out;
-  endfunction // gf_mult
-
-endmodule // prim_gf_mult
diff --git a/prim_intr_hw.sv b/prim_intr_hw.sv
deleted file mode 100644
index be09a7c8..00000000
--- a/prim_intr_hw.sv
+++ /dev/null
@@ -1,58 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Primitive interrupt handler. This assumes the existence of three
-// controller registers: INTR_ENABLE, INTR_STATE, INTR_TEST.
-// This module can be instantiated once per interrupt field, or
-// "bussified" with all fields of the interrupt vector.
-
-module prim_intr_hw # (
-  parameter int unsigned Width = 1,
-  parameter bit FlopOutput = 1
-) (
-  // event
-  input  clk_i,
-  input  rst_ni,
-  input  [Width-1:0]  event_intr_i,
-
-  // register interface
-  input  [Width-1:0]  reg2hw_intr_enable_q_i,
-  input  [Width-1:0]  reg2hw_intr_test_q_i,
-  input               reg2hw_intr_test_qe_i,
-  input  [Width-1:0]  reg2hw_intr_state_q_i,
-  output              hw2reg_intr_state_de_o,
-  output [Width-1:0]  hw2reg_intr_state_d_o,
-
-  // outgoing interrupt
-  output logic [Width-1:0]  intr_o
-);
-
-  logic  [Width-1:0]    new_event;
-  assign new_event =
-             (({Width{reg2hw_intr_test_qe_i}} & reg2hw_intr_test_q_i) | event_intr_i);
-  assign hw2reg_intr_state_de_o = |new_event;
-  // for scalar interrupts, this resolves to '1' with new event
-  // for vector interrupts, new events are OR'd in to existing interrupt state
-  assign hw2reg_intr_state_d_o  =  new_event | reg2hw_intr_state_q_i;
-
-  if (FlopOutput == 1) begin : gen_flop_intr_output
-    // flop the interrupt output
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-        intr_o <= '0;
-      end else begin
-        intr_o <= reg2hw_intr_state_q_i & reg2hw_intr_enable_q_i;
-      end
-    end
-
-  end else begin : gen_intr_passthrough_output
-    logic unused_clk;
-    logic unused_rst_n;
-    assign unused_clk = clk_i;
-    assign unused_rst_n = rst_ni;
-    assign intr_o = reg2hw_intr_state_q_i & reg2hw_intr_enable_q_i;
-  end
-
-
-endmodule
diff --git a/prim_keccak.sv b/prim_keccak.sv
deleted file mode 100644
index 16b31785..00000000
--- a/prim_keccak.sv
+++ /dev/null
@@ -1,295 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// prim_keccak is single round permutation module
-`include "prim_assert.sv"
-module prim_keccak #(
-  parameter int Width = 1600, // b= {25, 50, 100, 200, 400, 800, 1600}
-
-  // Derived
-  localparam int W        = Width/25,
-  localparam int L        = $clog2(W),
-  localparam int MaxRound = 12 + 2*L, // Keccak-f only
-  localparam int RndW     = $clog2(MaxRound+1) // Representing up to MaxRound
-) (
-  input        [RndW-1:0]  rnd_i,   // Current Round
-  input        [Width-1:0] s_i,
-  output logic [Width-1:0] s_o
-);
-  ///////////
-  // Types //
-  ///////////
-  //             x    y    z
-  typedef logic [4:0][4:0][W-1:0] box_t;   // (x,y,z) state
-  typedef logic           [W-1:0] lane_t;  // (z)
-  typedef logic [4:0]     [W-1:0] plane_t; // (x,z)
-  typedef logic [4:0][4:0]        slice_t; // (x,y)
-  typedef logic      [4:0][W-1:0] sheet_t; // (y,z) identical to plane_t
-  typedef logic [4:0]             row_t;   // (x)
-  typedef logic      [4:0]        col_t;   // (y) identical to row_t
-
-  //////////////
-  // Keccak_f //
-  //////////////
-  box_t state_in, keccak_f;
-  box_t theta_data, rho_data, pi_data, chi_data, iota_data;
-  assign state_in = bitarray_to_box(s_i);
-  assign theta_data = theta(state_in);
-  // Commented out rho function as vcs complains z-Offset%W isn't constant
-  //assign rho_data   = rho(theta_data);
-  assign pi_data    = pi(rho_data);
-  assign chi_data   = chi(pi_data);
-  assign iota_data  = iota(chi_data, rnd_i);
-  assign keccak_f   = iota_data;
-  assign s_o        = box_to_bitarray(keccak_f);
-
-  // Rho ======================================================================
-  // As RhoOffset[x][y] is considered as variable int in VCS,
-  // it is replaced with generate statement.
-  localparam int RhoOffset [5][5]  = '{
-    //y  0    1    2    3    4     x
-    '{   0,  36,   3, 105, 210},// 0
-    '{   1, 300,  10,  45,  66},// 1
-    '{ 190,   6, 171,  15, 253},// 2
-    '{  28,  55, 153,  21, 120},// 3
-    '{  91, 276, 231, 136,  78} // 4
-  };
-  for (genvar x = 0 ; x < 5 ; x++) begin : gen_rho_x
-    for (genvar y = 0 ; y < 5 ; y++) begin : gen_rho_y
-      localparam int Offset = RhoOffset[x][y]%W;
-      localparam int ShiftAmt = W- Offset;
-      if (Offset == 0) begin : gen_offset0
-        assign rho_data[x][y][W-1:0] = theta_data[x][y][W-1:0];
-      end else begin : gen_others
-        assign rho_data[x][y][W-1:0] = {theta_data[x][y][0+:ShiftAmt],
-                                        theta_data[x][y][ShiftAmt+:Offset]};
-      end
-    end
-  end
-
-  ////////////////
-  // Assertions //
-  ////////////////
-
-  `ASSERT_INIT(ValidWidth_A, Width inside {25, 50, 100, 200, 400, 800, 1600})
-  `ASSERT_INIT(ValidW_A, W inside {1, 2, 4, 8, 16, 32, 64})
-  `ASSERT_INIT(ValidL_A, L inside {0, 1, 2, 3, 4, 5, 6})
-  `ASSERT_INIT(ValidRound_A, MaxRound <= 24) // Keccak-f only
-
-  ///////////////
-  // Functions //
-  ///////////////
-
-  // Convert bitarray to 3D box
-  // Please take a look at FIPS PUB 202
-  // https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf
-  // > For all triples (x,y,z) such that 0<=x<5, 0<=y<5, and 0<=z<w,
-  // >    A[x,y,z]=S[w(5y+x)+z]
-  function automatic box_t bitarray_to_box(logic [Width-1:0] s_in);
-    automatic box_t box;
-    for (int y = 0 ; y < 5 ; y++) begin
-      for (int x = 0 ; x < 5 ; x++) begin
-        for (int z = 0 ; z < W ; z++) begin
-          box[x][y][z] = s_in[W*(5*y+x) + z];
-        end
-      end
-    end
-    return box;
-  endfunction : bitarray_to_box
-
-  // Convert 3D cube to bitarray
-  function automatic logic [Width-1:0] box_to_bitarray(box_t state);
-    automatic logic [Width-1:0] bitarray;
-    for (int y = 0 ; y < 5 ; y++) begin
-      for (int x = 0 ; x < 5 ; x++) begin
-        for (int z = 0 ; z < W ; z++) begin
-          bitarray[W*(5*y+x)+z] = state[x][y][z];
-        end
-      end
-    end
-    return bitarray;
-  endfunction : box_to_bitarray
-
-  // Step Mapping =============================================================
-  // theta
-  // XOR each bit in the state with the parity of two columns
-  // C[x,z] = A[x,0,z] ^ A[x,1,z] ^ A[x,2,z] ^ A[x,3,z] ^ A[x,4,z]
-  // D[x,z] = C[x-1,z] ^ C[x+1,z-1]
-  // theta = A[x,y,z] ^ D[x,z]
-  function automatic box_t theta(box_t state);
-    plane_t c;
-    plane_t d;
-    box_t result;
-    for (int x = 0 ; x < 5 ; x++) begin
-      for (int z = 0 ; z < W ; z++) begin
-        c[x][z] = state[x][0][z] ^ state[x][1][z]
-                ^ state[x][2][z] ^ state[x][3][z] ^ state[x][4][z];
-      end
-    end
-    for (int x = 0 ; x < 5 ; x++) begin
-      int index_x1, index_x2;
-      index_x1 = (x == 0) ? 4 : x-1; // (x-1)%5
-      index_x2 = (x == 4) ? 0 : x+1; // (x+1)%5
-      for (int z = 0 ; z < W ; z++) begin
-        int index_z;
-        index_z = (z == 0) ? W-1 : z-1; // (z+1)%W
-        d[x][z] = c[index_x1][z] ^ c[index_x2][index_z];
-      end
-    end
-    for (int x = 0 ; x < 5 ; x++) begin
-      for (int y = 0 ; y < 5 ; y++) begin
-        for (int z = 0 ; z < W ; z++) begin
-          result[x][y][z] = state[x][y][z] ^ d[x][z];
-        end
-      end
-    end
-    return result;
-  endfunction : theta
-
-  // rho
-
-  // Commented out entire rho function due to VCS elaboration error.
-  // (z-RhoOffset[x][y]%W) isn't considered as a constant in VCS.
-  // Even changing it to W-RhoOffset[x][y]%W and assign to ShiftAmt
-  // creates same error.
-
-  // Offset : Look at Table 2 in FIPS PUB 202
-  //localparam int RhoOffset [5][5]  = '{
-  //  //y  0    1    2    3    4     x
-  //  '{   0,  36,   3, 105, 210},// 0
-  //  '{   1, 300,  10,  45,  66},// 1
-  //  '{ 190,   6, 171,  15, 253},// 2
-  //  '{  28,  55, 153,  21, 120},// 3
-  //  '{  91, 276, 231, 136,  78} // 4
-  //};
-
-  // rotate bits of each lane by offset
-  // 1. rho[0,0,z] = A[0,0,z]
-  // 2. Offset swap
-  //    a. (x,y) := (1,0)
-  //    b. for t [0..23]
-  //       i. rho[x,y,z] = A[x,y,z-(t+1)(t+2)/2]
-  //       ii. (x,y) = (y, (2x+3y))
-  //function automatic box_t rho(box_t state);
-  //  box_t result;
-  //  for (int x = 0 ; x < 5 ; x++) begin
-  //    for (int y = 0 ; y < 5 ; y++) begin
-  //      for (int z = 0 ; z < W ; z++) begin
-  //        automatic int index_z;
-  //        index_z = (z-RhoOffset[x][y])%W;
-  //        result[x][y][z] = state[x][y][(z-RhoOffset[x][y])%W];
-  //      end
-  //    end
-  //  end
-  //  return result;
-  //endfunction : rho
-
-  // pi
-  // rearrange the position of lanes
-  // pi[x,y,z] = state[(x+3y),x,z]
-  localparam int PiRotate [5][5] = '{
-    //y  0    1    2    3    4     x
-    '{   0,   3,   1,   4,   2},// 0
-    '{   1,   4,   2,   0,   3},// 1
-    '{   2,   0,   3,   1,   4},// 2
-    '{   3,   1,   4,   2,   0},// 3
-    '{   4,   2,   0,   3,   1} // 4
-  };
-  function automatic box_t pi(box_t state);
-    box_t result;
-    for (int x = 0 ; x < 5 ; x++) begin
-      for (int y = 0 ; y < 5 ; y++) begin
-        int index_x;
-        result[x][y][W-1:0] = state[PiRotate[x][y]][x][W-1:0];
-      end
-    end
-    return result;
-  endfunction : pi
-
-  // chi
-  // chi[x,y,z] = state[x,y,z] ^ ((state[x+1,y,z] ^ 1) & state[x+2,y,z])
-  function automatic box_t chi(box_t state);
-    box_t result;
-    for (int x = 0 ; x < 5 ; x++) begin
-      int index_x1, index_x2;
-      index_x1 = (x == 4) ? 0 : x+1;
-      index_x2 = (x >= 3) ? x-3 : x+2;
-      for (int y = 0 ; y < 5 ; y++) begin
-        for (int z = 0 ; z < W ; z++) begin
-          result[x][y][z] = state[x][y][z] ^
-                                ((~state[index_x1][y][z])
-                                 & state[index_x2][y][z]);
-        end
-      end
-    end
-    return result;
-  endfunction : chi
-
-  // iota
-  // XOR (x,y) = (0,0) with round constant
-
-  // RC parameter: Precomputed by util/keccak_rc.py. Only up-to 0..L-1 is used
-  // RC = '0
-  // RC[2**j-1] = rc(j+7*rnd)
-  // rc(t) =
-  //    1. t%255 == 0 -> 1
-  //    2. R[0:7] = 'b10000000
-  //    3. for i = [1..t%255]
-  //      a. R = 0 || R
-  //      b. R[0] = R[0] ^ R[8]
-  //      c. R[4] = R[4] ^ R[8]
-  //      d. R[5] = R[5] ^ R[8]
-  //      e. R[6] = R[6] ^ R[8]
-  //      f. R = R[0:7]
-  //    4. return R[0]
-  // RC has L = [0..6]
-  // for lower L case, only chopping lower part of 64bit RC is sufficient.
-  localparam logic [63:0] RC [24] = '{
-     64'h 0000_0000_0000_0001, // Round 0
-     64'h 0000_0000_0000_8082, // Round 1
-     64'h 8000_0000_0000_808A, // Round 2
-     64'h 8000_0000_8000_8000, // Round 3
-     64'h 0000_0000_0000_808B, // Round 4
-     64'h 0000_0000_8000_0001, // Round 5
-     64'h 8000_0000_8000_8081, // Round 6
-     64'h 8000_0000_0000_8009, // Round 7
-     64'h 0000_0000_0000_008A, // Round 8
-     64'h 0000_0000_0000_0088, // Round 9
-     64'h 0000_0000_8000_8009, // Round 10
-     64'h 0000_0000_8000_000A, // Round 11
-     64'h 0000_0000_8000_808B, // Round 12
-     64'h 8000_0000_0000_008B, // Round 13
-     64'h 8000_0000_0000_8089, // Round 14
-     64'h 8000_0000_0000_8003, // Round 15
-     64'h 8000_0000_0000_8002, // Round 16
-     64'h 8000_0000_0000_0080, // Round 17
-     64'h 0000_0000_0000_800A, // Round 18
-     64'h 8000_0000_8000_000A, // Round 19
-     64'h 8000_0000_8000_8081, // Round 20
-     64'h 8000_0000_0000_8080, // Round 21
-     64'h 0000_0000_8000_0001, // Round 22
-     64'h 8000_0000_8000_8008  // Round 23
-  };
-
-  // iota: XOR with RC for (x,y) = (0,0)
-  function automatic box_t iota(box_t state, logic [RndW-1:0] rnd);
-    box_t result;
-    result = state;
-    result[0][0][W-1:0] = state[0][0][W-1:0] ^ RC[rnd][W-1:0];
-
-    return result;
-  endfunction : iota
-
-  // Round function : Rnd(A,i_r)
-  // Not used due to rho function issue described above.
-
-  //function automatic box_t keccak_rnd(box_t state, logic [RndW-1:0] rnd);
-  //  box_t keccak_state;
-  //  keccak_state = iota(chi(pi(rho(theta(state)))), rnd);
-  //
-  //  return keccak_state;
-  //endfunction : keccak_rnd
-
-endmodule
-
diff --git a/prim_lc_combine.sv b/prim_lc_combine.sv
deleted file mode 100644
index 67b9d825..00000000
--- a/prim_lc_combine.sv
+++ /dev/null
@@ -1,73 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Perform logical OR or AND between two life cycle multibit signals.
-
-module prim_lc_combine #(
-  // 0: use the ON value as active value for the logical combination
-  // 1: use the OFF value as active value for the logical combination
-  parameter bit ActiveLow = 0,
-  // 0: logical combination is an OR function
-  // 1: logical combination is an AND function
-  parameter bit CombineMode = 0
-) (
-  input  lc_ctrl_pkg::lc_tx_t lc_en_a_i,
-  input  lc_ctrl_pkg::lc_tx_t lc_en_b_i,
-  output lc_ctrl_pkg::lc_tx_t lc_en_o
-);
-
-  // Determine whether which multibit value is considered "active" for the
-  // purpose of the logical function below.
-  parameter lc_ctrl_pkg::lc_tx_t ActiveValue = (ActiveLow) ? lc_ctrl_pkg::Off : lc_ctrl_pkg::On;
-  // Truth tables:
-  //
-  // ActiveLow: 0, CombineMode: 0 (active-high "OR")
-  //
-  // A    | B    | OUT
-  //------+------+-----
-  // !On  | !On  | !On
-  // On   | !On  | On
-  // !On  | On   | On
-  // On   | On   | On
-  //
-  // ActiveLow: 0, CombineMode: 1 (active-high "AND")
-  //
-  // A    | B    | OUT
-  //------+------+-----
-  // !On  | !On  | !On
-  // On   | !On  | !On
-  // !On  | On   | !On
-  // On   | On   | On
-  //
-  // ActiveLow: 1, CombineMode: 0 (active-low "OR")
-  //
-  // A    | B    | OUT
-  //------+------+-----
-  // !Off | !Off | !Off
-  // Off  | !Off | Off
-  // !Off | Off  | Off
-  // Off  | Off  | Off
-  //
-  // ActiveLow: 1, CombineMode: 1 (active-low "AND")
-  //
-  // A    | B    | OUT
-  //------+------+-----
-  // !Off | !Off | !Off
-  // Off  | !Off | !Off
-  // !Off | Off  | !Off
-  // Off  | Off  | Off
-  //
-  // Note: the inactive value (e.g. !On) can be any multibit value
-  // different from the active value.
-  //
-  for (genvar k = 0; k < $bits(ActiveValue); k++) begin : gen_loop
-    if (CombineMode && ActiveValue[k] ||
-       (!CombineMode && !ActiveValue[k])) begin : gen_and_gate
-      assign lc_en_o[k] = lc_en_a_i[k] && lc_en_b_i[k];
-    end else begin : gen_or_gate
-      assign lc_en_o[k] = lc_en_a_i[k] || lc_en_b_i[k];
-    end
-  end
-
-endmodule : prim_lc_combine
diff --git a/prim_lc_dec.sv b/prim_lc_dec.sv
deleted file mode 100644
index 78845ae5..00000000
--- a/prim_lc_dec.sv
+++ /dev/null
@@ -1,28 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Decoder for life cycle control signals with additional
-// input buffers.
-
-module prim_lc_dec (
-  input lc_ctrl_pkg::lc_tx_t lc_en_i,
-  output logic lc_en_dec_o
-);
-
-logic [lc_ctrl_pkg::TxWidth-1:0] lc_en;
-logic [lc_ctrl_pkg::TxWidth-1:0] lc_en_out;
-assign lc_en = lc_en_i;
-
-// The buffer cells have a don't touch constraint on them
-// such that synthesis tools won't collapse them
-for (genvar k = 0; k < lc_ctrl_pkg::TxWidth; k++) begin : gen_bits
-  prim_buf u_prim_buf (
-    .in_i ( lc_en[k] ),
-    .out_o ( lc_en_out[k] )
-  );
-end
-
-assign lc_en_dec_o = (lc_en_out == lc_ctrl_pkg::On);
-
-endmodule : prim_lc_dec
diff --git a/prim_lc_sender.sv b/prim_lc_sender.sv
deleted file mode 100644
index ae95a2c7..00000000
--- a/prim_lc_sender.sv
+++ /dev/null
@@ -1,68 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Multibit life cycle signal sender module.
-//
-// This module is instantiates a hand-picked flop cell
-// for each bit in the life cycle control signal such that tools do not
-// optimize the multibit encoding.
-
-`include "prim_assert.sv"
-
-module prim_lc_sender #(
-  // This flops the output if set to 1.
-  // In special cases where the sender is in the same clock domain as the receiver,
-  // this can be set to 0. However, it is recommended to leave this at 1.
-  parameter bit AsyncOn = 1,
-  // 0: reset value is lc_ctrl_pkg::Off
-  // 1: reset value is lc_ctrl_pkg::On
-  parameter bit ResetValueIsOn = 0
-) (
-  input                       clk_i,
-  input                       rst_ni,
-  input  lc_ctrl_pkg::lc_tx_t lc_en_i,
-  output lc_ctrl_pkg::lc_tx_t lc_en_o
-);
-
-  localparam lc_ctrl_pkg::lc_tx_t ResetValue = (ResetValueIsOn) ? lc_ctrl_pkg::On :
-                                                                  lc_ctrl_pkg::Off;
-
-  logic [lc_ctrl_pkg::TxWidth-1:0] lc_en, lc_en_out;
-  assign lc_en = lc_ctrl_pkg::TxWidth'(lc_en_i);
-
-  if (AsyncOn) begin : gen_flops
-    prim_sec_anchor_flop #(
-      .Width(lc_ctrl_pkg::TxWidth),
-      .ResetValue(lc_ctrl_pkg::TxWidth'(ResetValue))
-    ) u_prim_flop (
-      .clk_i,
-      .rst_ni,
-      .d_i   ( lc_en     ),
-      .q_o   ( lc_en_out )
-    );
-  end else begin : gen_no_flops
-    for (genvar k = 0; k < lc_ctrl_pkg::TxWidth; k++) begin : gen_bits
-      prim_sec_anchor_buf u_prim_buf (
-        .in_i(lc_en[k]),
-        .out_o(lc_en_out[k])
-      );
-    end
-
-    // This unused companion logic helps remove lint errors
-    // for modules where clock and reset are used for assertions only
-    // or nothing at all.
-    // This logic will be removed for sythesis since it is unloaded.
-    lc_ctrl_pkg::lc_tx_t unused_logic;
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-         unused_logic <= lc_ctrl_pkg::Off;
-      end else begin
-         unused_logic <= lc_en_i;
-      end
-    end
-  end
-
-  assign lc_en_o = lc_ctrl_pkg::lc_tx_t'(lc_en_out);
-
-endmodule : prim_lc_sender
diff --git a/prim_lc_sync.sv b/prim_lc_sync.sv
deleted file mode 100644
index 633c142a..00000000
--- a/prim_lc_sync.sv
+++ /dev/null
@@ -1,107 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Double-synchronizer flop for life cycle control signals with additional
-// output buffers and life-cycle specific assertions.
-//
-// Should be used exactly as recommended in the life cycle controller spec:
-// https://docs.opentitan.org/hw/ip/lc_ctrl/doc/index.html#control-signal-propagation
-
-`include "prim_assert.sv"
-
-module prim_lc_sync #(
-  // Number of separately buffered output signals.
-  // The buffer cells have a don't touch constraint
-  // on them such that synthesis tools won't collapse
-  // all copies into one signal.
-  parameter int NumCopies = 1,
-  // This instantiates the synchronizer flops if set to 1.
-  // In special cases where the receiver is in the same clock domain as the sender,
-  // this can be set to 0. However, it is recommended to leave this at 1.
-  parameter bit AsyncOn = 1,
-  // 0: reset value is lc_ctrl_pkg::Off
-  // 1: reset value is lc_ctrl_pkg::On
-  parameter bit ResetValueIsOn = 0
-) (
-  input                                       clk_i,
-  input                                       rst_ni,
-  input  lc_ctrl_pkg::lc_tx_t                 lc_en_i,
-  output lc_ctrl_pkg::lc_tx_t [NumCopies-1:0] lc_en_o
-);
-
-  localparam lc_ctrl_pkg::lc_tx_t LcResetValue = (ResetValueIsOn) ? lc_ctrl_pkg::On :
-                                                                  lc_ctrl_pkg::Off;
-
-  `ASSERT_INIT(NumCopiesMustBeGreaterZero_A, NumCopies > 0)
-
-  logic [lc_ctrl_pkg::TxWidth-1:0] lc_en;
-  if (AsyncOn) begin : gen_flops
-    prim_flop_2sync #(
-      .Width(lc_ctrl_pkg::TxWidth),
-      .ResetValue(lc_ctrl_pkg::TxWidth'(LcResetValue))
-    ) u_prim_flop_2sync (
-      .clk_i,
-      .rst_ni,
-      .d_i(lc_en_i),
-      .q_o(lc_en)
-    );
-  end else begin : gen_no_flops
-    // This unused companion logic helps remove lint errors
-    // for modules where clock and reset are used for assertions only
-    // or nothing at all.
-    // This logic will be removed for sythesis since it is unloaded.
-    lc_ctrl_pkg::lc_tx_t unused_logic;
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-         unused_logic <= lc_ctrl_pkg::Off;
-      end else begin
-         unused_logic <= lc_en_i;
-      end
-    end
-
-    assign lc_en = lc_en_i;
-  end
-
-  for (genvar j = 0; j < NumCopies; j++) begin : gen_buffs
-    logic [lc_ctrl_pkg::TxWidth-1:0] lc_en_out;
-    for (genvar k = 0; k < lc_ctrl_pkg::TxWidth; k++) begin : gen_bits
-      prim_sec_anchor_buf u_prim_buf (
-        .in_i(lc_en[k]),
-        .out_o(lc_en_out[k])
-      );
-    end
-    assign lc_en_o[j] = lc_ctrl_pkg::lc_tx_t'(lc_en_out);
-  end
-
-  ////////////////
-  // Assertions //
-  ////////////////
-
-  // The outputs should be known at all times.
-  `ASSERT_KNOWN(OutputsKnown_A, lc_en_o)
-
-  // If the multibit signal is in a transient state, we expect it
-  // to be stable again within one clock cycle.
-  // DV will exclude these three assertions by name, thus added a module name prefix to make it
-  // harder to accidentally replicate in other modules.
-  `ASSERT(PrimLcSyncCheckTransients_A,
-      !(lc_en_i inside {lc_ctrl_pkg::On, lc_ctrl_pkg::Off})
-      |=>
-      (lc_en_i inside {lc_ctrl_pkg::On, lc_ctrl_pkg::Off}))
-
-  // If a signal departs from passive state, we expect it to move to the active state
-  // with only one transient cycle in between.
-  `ASSERT(PrimLcSyncCheckTransients0_A,
-      $past(lc_en_i == lc_ctrl_pkg::Off) &&
-      !(lc_en_i inside {lc_ctrl_pkg::On, lc_ctrl_pkg::Off})
-      |=>
-      (lc_en_i == lc_ctrl_pkg::On))
-
-  `ASSERT(PrimLcSyncCheckTransients1_A,
-      $past(lc_en_i == lc_ctrl_pkg::On) &&
-      !(lc_en_i inside {lc_ctrl_pkg::On, lc_ctrl_pkg::Off})
-      |=>
-      (lc_en_i == lc_ctrl_pkg::Off))
-
-endmodule : prim_lc_sync
diff --git a/prim_lfsr.sv b/prim_lfsr.sv
deleted file mode 100644
index e17e1126..00000000
--- a/prim_lfsr.sv
+++ /dev/null
@@ -1,669 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// This module implements different LFSR types:
-//
-// 0) Galois XOR type LFSR ([1], internal XOR gates, very fast).
-//    Parameterizable width from 4 to 64 bits.
-//    Coefficients obtained from [2].
-//
-// 1) Fibonacci XNOR type LFSR, parameterizable from 3 to 168 bits.
-//    Coefficients obtained from [3].
-//
-// All flavors have an additional entropy input and lockup protection, which
-// reseeds the state once it has accidentally fallen into the all-zero (XOR) or
-// all-one (XNOR) state. Further, an external seed can be loaded into the LFSR
-// state at runtime. If that seed is all-zero (XOR case) or all-one (XNOR case),
-// the state will be reseeded in the next cycle using the lockup protection mechanism.
-// Note that the external seed input takes precedence over internal state updates.
-//
-// All polynomials up to 34 bit in length have been verified in simulation.
-//
-// Refs: [1] https://en.wikipedia.org/wiki/Linear-feedback_shift_register
-//       [2] https://users.ece.cmu.edu/~koopman/lfsr/
-//       [3] https://www.xilinx.com/support/documentation/application_notes/xapp052.pdf
-
-`include "prim_assert.sv"
-
-module prim_lfsr #(
-  // Lfsr Type, can be FIB_XNOR or GAL_XOR
-  parameter                    LfsrType     = "GAL_XOR",
-  // Lfsr width
-  parameter int unsigned       LfsrDw       = 32,
-  // Derived parameter, do not override
-  localparam int unsigned      LfsrIdxDw    = $clog2(LfsrDw),
-  // Width of the entropy input to be XOR'd into state (lfsr_q[EntropyDw-1:0])
-  parameter int unsigned       EntropyDw    =  8,
-  // Width of output tap (from lfsr_q[StateOutDw-1:0])
-  parameter int unsigned       StateOutDw   =  8,
-  // Lfsr reset state, must be nonzero!
-  parameter logic [LfsrDw-1:0] DefaultSeed  = LfsrDw'(1),
-  // Custom polynomial coeffs
-  parameter logic [LfsrDw-1:0] CustomCoeffs = '0,
-  // If StatePermEn is set to 1, the custom permutation specified via StatePerm is applied to the
-  // state output, in order to break linear shifting patterns of the LFSR. Note that this
-  // permutation represents a way of customizing the LFSR via a random netlist constant. This is
-  // different from the NonLinearOut feature below which just transforms the output non-linearly
-  // with a fixed function. In most cases, designers should consider enabling StatePermEn as it
-  // comes basically "for free" in terms of area and timing impact. NonLinearOut on the other hand
-  // has area and timing implications and designers should consider whether the use of that feature
-  // is justified.
-  parameter bit                StatePermEn  = 1'b0,
-  parameter logic [LfsrDw-1:0][LfsrIdxDw-1:0] StatePerm = '0,
-  // Enable this for DV, disable this for long LFSRs in FPV
-  parameter bit                MaxLenSVA    = 1'b1,
-  // Can be disabled in cases where seed and entropy
-  // inputs are unused in order to not distort coverage
-  // (the SVA will be unreachable in such cases)
-  parameter bit                LockupSVA    = 1'b1,
-  parameter bit                ExtSeedSVA   = 1'b1,
-  // Introduce non-linearity to lfsr output. Note, unlike StatePermEn, this feature is not "for
-  // free". Please double check that this feature is indeed required. Also note that this feature
-  // is only available for LFSRs that have a power-of-two width greater or equal 16bit.
-  parameter bit                NonLinearOut = 1'b0
-) (
-  input                         clk_i,
-  input                         rst_ni,
-  input                         seed_en_i, // load external seed into the state (takes precedence)
-  input        [LfsrDw-1:0]     seed_i,    // external seed input
-  input                         lfsr_en_i, // enables the LFSR
-  input        [EntropyDw-1:0]  entropy_i, // additional entropy to be XOR'ed into the state
-  output logic [StateOutDw-1:0] state_o    // (partial) LFSR state output
-);
-
-  // automatically generated with util/design/get-lfsr-coeffs.py script
-  localparam int unsigned GAL_XOR_LUT_OFF = 4;
-  localparam logic [63:0] GAL_XOR_COEFFS [61] =
-    '{ 64'h9,
-       64'h12,
-       64'h21,
-       64'h41,
-       64'h8E,
-       64'h108,
-       64'h204,
-       64'h402,
-       64'h829,
-       64'h100D,
-       64'h2015,
-       64'h4001,
-       64'h8016,
-       64'h10004,
-       64'h20013,
-       64'h40013,
-       64'h80004,
-       64'h100002,
-       64'h200001,
-       64'h400010,
-       64'h80000D,
-       64'h1000004,
-       64'h2000023,
-       64'h4000013,
-       64'h8000004,
-       64'h10000002,
-       64'h20000029,
-       64'h40000004,
-       64'h80000057,
-       64'h100000029,
-       64'h200000073,
-       64'h400000002,
-       64'h80000003B,
-       64'h100000001F,
-       64'h2000000031,
-       64'h4000000008,
-       64'h800000001C,
-       64'h10000000004,
-       64'h2000000001F,
-       64'h4000000002C,
-       64'h80000000032,
-       64'h10000000000D,
-       64'h200000000097,
-       64'h400000000010,
-       64'h80000000005B,
-       64'h1000000000038,
-       64'h200000000000E,
-       64'h4000000000025,
-       64'h8000000000004,
-       64'h10000000000023,
-       64'h2000000000003E,
-       64'h40000000000023,
-       64'h8000000000004A,
-       64'h100000000000016,
-       64'h200000000000031,
-       64'h40000000000003D,
-       64'h800000000000001,
-       64'h1000000000000013,
-       64'h2000000000000034,
-       64'h4000000000000001,
-       64'h800000000000000D };
-
-  // automatically generated with get-lfsr-coeffs.py script
-  localparam int unsigned FIB_XNOR_LUT_OFF = 3;
-  localparam logic [167:0] FIB_XNOR_COEFFS [166] =
-    '{ 168'h6,
-       168'hC,
-       168'h14,
-       168'h30,
-       168'h60,
-       168'hB8,
-       168'h110,
-       168'h240,
-       168'h500,
-       168'h829,
-       168'h100D,
-       168'h2015,
-       168'h6000,
-       168'hD008,
-       168'h12000,
-       168'h20400,
-       168'h40023,
-       168'h90000,
-       168'h140000,
-       168'h300000,
-       168'h420000,
-       168'hE10000,
-       168'h1200000,
-       168'h2000023,
-       168'h4000013,
-       168'h9000000,
-       168'h14000000,
-       168'h20000029,
-       168'h48000000,
-       168'h80200003,
-       168'h100080000,
-       168'h204000003,
-       168'h500000000,
-       168'h801000000,
-       168'h100000001F,
-       168'h2000000031,
-       168'h4400000000,
-       168'hA000140000,
-       168'h12000000000,
-       168'h300000C0000,
-       168'h63000000000,
-       168'hC0000030000,
-       168'h1B0000000000,
-       168'h300003000000,
-       168'h420000000000,
-       168'hC00000180000,
-       168'h1008000000000,
-       168'h3000000C00000,
-       168'h6000C00000000,
-       168'h9000000000000,
-       168'h18003000000000,
-       168'h30000000030000,
-       168'h40000040000000,
-       168'hC0000600000000,
-       168'h102000000000000,
-       168'h200004000000000,
-       168'h600003000000000,
-       168'hC00000000000000,
-       168'h1800300000000000,
-       168'h3000000000000030,
-       168'h6000000000000000,
-       168'hD800000000000000,
-       168'h10000400000000000,
-       168'h30180000000000000,
-       168'h60300000000000000,
-       168'h80400000000000000,
-       168'h140000028000000000,
-       168'h300060000000000000,
-       168'h410000000000000000,
-       168'h820000000001040000,
-       168'h1000000800000000000,
-       168'h3000600000000000000,
-       168'h6018000000000000000,
-       168'hC000000018000000000,
-       168'h18000000600000000000,
-       168'h30000600000000000000,
-       168'h40200000000000000000,
-       168'hC0000000060000000000,
-       168'h110000000000000000000,
-       168'h240000000480000000000,
-       168'h600000000003000000000,
-       168'h800400000000000000000,
-       168'h1800000300000000000000,
-       168'h3003000000000000000000,
-       168'h4002000000000000000000,
-       168'hC000000000000000018000,
-       168'h10000000004000000000000,
-       168'h30000C00000000000000000,
-       168'h600000000000000000000C0,
-       168'hC00C0000000000000000000,
-       168'h140000000000000000000000,
-       168'h200001000000000000000000,
-       168'h400800000000000000000000,
-       168'hA00000000001400000000000,
-       168'h1040000000000000000000000,
-       168'h2004000000000000000000000,
-       168'h5000000000028000000000000,
-       168'h8000000004000000000000000,
-       168'h18600000000000000000000000,
-       168'h30000000000000000C00000000,
-       168'h40200000000000000000000000,
-       168'hC0300000000000000000000000,
-       168'h100010000000000000000000000,
-       168'h200040000000000000000000000,
-       168'h5000000000000000A0000000000,
-       168'h800000010000000000000000000,
-       168'h1860000000000000000000000000,
-       168'h3003000000000000000000000000,
-       168'h4010000000000000000000000000,
-       168'hA000000000140000000000000000,
-       168'h10080000000000000000000000000,
-       168'h30000000000000000000180000000,
-       168'h60018000000000000000000000000,
-       168'hC0000000000000000300000000000,
-       168'h140005000000000000000000000000,
-       168'h200000001000000000000000000000,
-       168'h404000000000000000000000000000,
-       168'h810000000000000000000000000102,
-       168'h1000040000000000000000000000000,
-       168'h3000000000000006000000000000000,
-       168'h5000000000000000000000000000000,
-       168'h8000000004000000000000000000000,
-       168'h18000000000000000000000000030000,
-       168'h30000000030000000000000000000000,
-       168'h60000000000000000000000000000000,
-       168'hA0000014000000000000000000000000,
-       168'h108000000000000000000000000000000,
-       168'h240000000000000000000000000000000,
-       168'h600000000000C00000000000000000000,
-       168'h800000040000000000000000000000000,
-       168'h1800000000000300000000000000000000,
-       168'h2000000000000010000000000000000000,
-       168'h4008000000000000000000000000000000,
-       168'hC000000000000000000000000000000600,
-       168'h10000080000000000000000000000000000,
-       168'h30600000000000000000000000000000000,
-       168'h4A400000000000000000000000000000000,
-       168'h80000004000000000000000000000000000,
-       168'h180000003000000000000000000000000000,
-       168'h200001000000000000000000000000000000,
-       168'h600006000000000000000000000000000000,
-       168'hC00000000000000006000000000000000000,
-       168'h1000000000000100000000000000000000000,
-       168'h3000000000000006000000000000000000000,
-       168'h6000000003000000000000000000000000000,
-       168'h8000001000000000000000000000000000000,
-       168'h1800000000000000000000000000C000000000,
-       168'h20000000000001000000000000000000000000,
-       168'h48000000000000000000000000000000000000,
-       168'hC0000000000000006000000000000000000000,
-       168'h180000000000000000000000000000000000000,
-       168'h280000000000000000000000000000005000000,
-       168'h60000000C000000000000000000000000000000,
-       168'hC00000000000000000000000000018000000000,
-       168'h1800000600000000000000000000000000000000,
-       168'h3000000C00000000000000000000000000000000,
-       168'h4000000080000000000000000000000000000000,
-       168'hC000300000000000000000000000000000000000,
-       168'h10000400000000000000000000000000000000000,
-       168'h30000000000000000000006000000000000000000,
-       168'h600000000000000C0000000000000000000000000,
-       168'hC0060000000000000000000000000000000000000,
-       168'h180000006000000000000000000000000000000000,
-       168'h3000000000C0000000000000000000000000000000,
-       168'h410000000000000000000000000000000000000000,
-       168'hA00140000000000000000000000000000000000000 };
-
-  logic lockup;
-  logic [LfsrDw-1:0] lfsr_d, lfsr_q;
-  logic [LfsrDw-1:0] next_lfsr_state, coeffs;
-
-
-  ////////////////
-  // Galois XOR //
-  ////////////////
-  if (64'(LfsrType) == 64'("GAL_XOR")) begin : gen_gal_xor
-
-    // if custom polynomial is provided
-    if (CustomCoeffs > 0) begin : gen_custom
-      assign coeffs = CustomCoeffs[LfsrDw-1:0];
-    end else begin : gen_lut
-      assign coeffs = GAL_XOR_COEFFS[LfsrDw-GAL_XOR_LUT_OFF][LfsrDw-1:0];
-      // check that the most significant bit of polynomial is 1
-      `ASSERT_INIT(MinLfsrWidth_A, LfsrDw >= $low(GAL_XOR_COEFFS)+GAL_XOR_LUT_OFF)
-      `ASSERT_INIT(MaxLfsrWidth_A, LfsrDw <= $high(GAL_XOR_COEFFS)+GAL_XOR_LUT_OFF)
-    end
-
-    // calculate next state using internal XOR feedback and entropy input
-    assign next_lfsr_state = LfsrDw'(entropy_i) ^ ({LfsrDw{lfsr_q[0]}} & coeffs) ^ (lfsr_q >> 1);
-
-    // lockup condition is all-zero
-    assign lockup = ~(|lfsr_q);
-
-    // check that seed is not all-zero
-    `ASSERT_INIT(DefaultSeedNzCheck_A, |DefaultSeed)
-
-
-  ////////////////////
-  // Fibonacci XNOR //
-  ////////////////////
-  end else if (64'(LfsrType) == "FIB_XNOR") begin : gen_fib_xnor
-
-    // if custom polynomial is provided
-    if (CustomCoeffs > 0) begin : gen_custom
-      assign coeffs = CustomCoeffs[LfsrDw-1:0];
-    end else begin : gen_lut
-      assign coeffs = FIB_XNOR_COEFFS[LfsrDw-FIB_XNOR_LUT_OFF][LfsrDw-1:0];
-      // check that the most significant bit of polynomial is 1
-      `ASSERT_INIT(MinLfsrWidth_A, LfsrDw >= $low(FIB_XNOR_COEFFS)+FIB_XNOR_LUT_OFF)
-      `ASSERT_INIT(MaxLfsrWidth_A, LfsrDw <= $high(FIB_XNOR_COEFFS)+FIB_XNOR_LUT_OFF)
-    end
-
-    // calculate next state using external XNOR feedback and entropy input
-    assign next_lfsr_state = LfsrDw'(entropy_i) ^ {lfsr_q[LfsrDw-2:0], ~(^(lfsr_q & coeffs))};
-
-    // lockup condition is all-ones
-    assign lockup = &lfsr_q;
-
-    // check that seed is not all-ones
-    `ASSERT_INIT(DefaultSeedNzCheck_A, !(&DefaultSeed))
-
-
-  /////////////
-  // Unknown //
-  /////////////
-  end else begin : gen_unknown_type
-    assign coeffs = '0;
-    assign next_lfsr_state = '0;
-    assign lockup = 1'b0;
-    `ASSERT_INIT(UnknownLfsrType_A, 0)
-  end
-
-
-  //////////////////
-  // Shared logic //
-  //////////////////
-
-  assign lfsr_d = (seed_en_i)           ? seed_i          :
-                  (lfsr_en_i && lockup) ? DefaultSeed     :
-                  (lfsr_en_i)           ? next_lfsr_state :
-                                          lfsr_q;
-
-  logic [LfsrDw-1:0] sbox_out;
-  if (NonLinearOut) begin : gen_out_non_linear
-    // The "aligned" permutation ensures that adjacent bits do not go into the same SBox. It is
-    // different from the state permutation that can be specified via the StatePerm parameter. The
-    // permutation taps out 4 SBox input bits at regular stride intervals. E.g., for a 16bit
-    // vector, the input assignment looks as follows:
-    //
-    // SBox0: 0,  4,  8, 12
-    // SBox1: 1,  5,  9, 13
-    // SBox2: 2,  6, 10, 14
-    // SBox3: 3,  7, 11, 15
-    //
-    // Note that this permutation can be produced by filling the input vector into matrix columns
-    // and reading out the SBox inputs as matrix rows.
-    localparam int NumSboxes = LfsrDw / 4;
-    // Fill in the input vector in col-major order.
-    logic [3:0][NumSboxes-1:0][LfsrIdxDw-1:0] matrix_indices;
-    for (genvar j = 0; j < LfsrDw; j++) begin : gen_input_idx_map
-      assign matrix_indices[j / NumSboxes][j % NumSboxes] = j;
-    end
-    // Due to the LFSR shifting pattern, the above permutation has the property that the output of
-    // SBox(n) is going to be equal to SBox(n+1) in the subsequent cycle (unless the LFSR polynomial
-    // modifies some of the associated shifted bits via an XOR tap).
-    // We therefore tweak this permutation by rotating and reversing some of the assignment matrix
-    // columns. The rotation and reversion operations have been chosen such that this
-    // generalizes to all power of two widths supported by the LFSR primitive. For 16bit, this
-    // looks as follows:
-    //
-    // SBox0: 0,  6, 11, 14
-    // SBox1: 1,  7, 10, 13
-    // SBox2: 2,  4,  9, 12
-    // SBox3: 3,  5,  8, 15
-    //
-    // This can be achieved by:
-    //   1) down rotating the second column by NumSboxes/2
-    //   2) reversing the third column
-    //   3) down rotating the fourth column by 1 and reversing it
-    //
-    logic [3:0][NumSboxes-1:0][LfsrIdxDw-1:0] matrix_rotrev_indices;
-    typedef logic [NumSboxes-1:0][LfsrIdxDw-1:0] matrix_col_t;
-
-    // left-rotates a matrix column by the shift amount
-    function automatic matrix_col_t lrotcol(matrix_col_t col, integer shift);
-      matrix_col_t out;
-      for (int k = 0; k < NumSboxes; k++) begin
-        out[(k + shift) % NumSboxes] = col[k];
-      end
-      return out;
-    endfunction : lrotcol
-
-    // reverses a matrix column
-    function automatic matrix_col_t revcol(matrix_col_t col);
-      return {<<LfsrIdxDw{col}};
-    endfunction : revcol
-
-    always_comb begin : p_rotrev
-      matrix_rotrev_indices[0] = matrix_indices[0];
-      matrix_rotrev_indices[1] = lrotcol(matrix_indices[1], NumSboxes/2);
-      matrix_rotrev_indices[2] = revcol(matrix_indices[2]);
-      matrix_rotrev_indices[3] = revcol(lrotcol(matrix_indices[3], 1));
-    end
-
-    // Read out the matrix rows and linearize.
-    logic [LfsrDw-1:0][LfsrIdxDw-1:0] sbox_in_indices;
-    for (genvar k = 0; k < LfsrDw; k++) begin : gen_reverse_upper
-      assign sbox_in_indices[k] = matrix_rotrev_indices[k % 4][k / 4];
-    end
-
-`ifndef SYNTHESIS
-      // Check that the permutation is indeed a permutation.
-      logic [LfsrDw-1:0] sbox_perm_test;
-      always_comb begin : p_perm_check
-        sbox_perm_test = '0;
-        for (int k = 0; k < LfsrDw; k++) begin
-          sbox_perm_test[sbox_in_indices[k]] = 1'b1;
-        end
-      end
-      // All bit positions must be marked with 1.
-      `ASSERT(SboxPermutationCheck_A, &sbox_perm_test)
-`endif
-
-`ifdef FPV_ON
-      // Verify that the permutation indeed breaks linear shifting patterns of 4bit input groups.
-      // The symbolic variables let the FPV tool select all sbox index combinations and linear shift
-      // offsets.
-      int shift;
-      int unsigned sk, sj;
-      `ASSUME(SjSkRange_M, (sj < NumSboxes) && (sk < NumSboxes))
-      `ASSUME(SjSkDifferent_M, sj != sk)
-      `ASSUME(SjSkStable_M, ##1 $stable(sj) && $stable(sk) && $stable(shift))
-      `ASSERT(SboxInputIndexGroupIsUnique_A,
-          !((((sbox_in_indices[sj * 4 + 0] + shift) % LfsrDw) == sbox_in_indices[sk * 4 + 0]) &&
-            (((sbox_in_indices[sj * 4 + 1] + shift) % LfsrDw) == sbox_in_indices[sk * 4 + 1]) &&
-            (((sbox_in_indices[sj * 4 + 2] + shift) % LfsrDw) == sbox_in_indices[sk * 4 + 2]) &&
-            (((sbox_in_indices[sj * 4 + 3] + shift) % LfsrDw) == sbox_in_indices[sk * 4 + 3])))
-
-      // this checks that the permutations does not preserve neighboring bit positions.
-      // i.e. no two neighboring bits are mapped to neighboring bit positions.
-      int y;
-      int unsigned ik;
-      `ASSUME(IkYRange_M, (ik < LfsrDw) && (y == 1 || y == -1))
-      `ASSUME(IkStable_M, ##1 $stable(ik) && $stable(y))
-      `ASSERT(IndicesNotAdjacent_A, (sbox_in_indices[ik] - sbox_in_indices[(ik + y) % LfsrDw]) != 1)
-`endif
-
-    // Use the permutation indices to create the SBox layer
-    for (genvar k = 0; k < NumSboxes; k++) begin : gen_sboxes
-      logic [3:0] sbox_in;
-      assign sbox_in = {lfsr_q[sbox_in_indices[k*4 + 3]],
-                        lfsr_q[sbox_in_indices[k*4 + 2]],
-                        lfsr_q[sbox_in_indices[k*4 + 1]],
-                        lfsr_q[sbox_in_indices[k*4 + 0]]};
-      assign sbox_out[k*4 +: 4] = prim_cipher_pkg::PRINCE_SBOX4[sbox_in];
-    end
-  end else begin : gen_out_passthru
-    assign sbox_out = lfsr_q;
-  end
-
-  // Random output permutation, defined at compile time
-  if (StatePermEn) begin : gen_state_perm
-
-    for (genvar k = 0; k < StateOutDw; k++) begin : gen_perm_loop
-      assign state_o[k] = sbox_out[StatePerm[k]];
-    end
-
-    // if lfsr width is greater than the output, then by definition
-    // not every bit will be picked
-    if (LfsrDw > StateOutDw) begin : gen_tieoff_unused
-      logic unused_sbox_out;
-      assign unused_sbox_out = ^sbox_out;
-    end
-
-  end else begin : gen_no_state_perm
-    assign state_o = StateOutDw'(sbox_out);
-  end
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin : p_reg
-    if (!rst_ni) begin
-      lfsr_q <= DefaultSeed;
-    end else begin
-      lfsr_q <= lfsr_d;
-    end
-  end
-
-
-  ///////////////////////
-  // shared assertions //
-  ///////////////////////
-
-  `ASSERT_KNOWN(DataKnownO_A, state_o)
-
-// the code below is not meant to be synthesized,
-// but it is intended to be used in simulation and FPV
-`ifndef SYNTHESIS
-  function automatic logic [LfsrDw-1:0] compute_next_state(logic [LfsrDw-1:0]    lfsrcoeffs,
-                                                           logic [EntropyDw-1:0] entropy,
-                                                           logic [LfsrDw-1:0]    current_state);
-    logic state0;
-    logic [LfsrDw-1:0] next_state;
-
-    next_state = current_state;
-
-    // Galois XOR
-    if (64'(LfsrType) == 64'("GAL_XOR")) begin
-      if (next_state == 0) begin
-        next_state = DefaultSeed;
-      end else begin
-        state0 = next_state[0];
-        next_state = next_state >> 1;
-        if (state0) next_state ^= lfsrcoeffs;
-        next_state ^= LfsrDw'(entropy);
-      end
-    // Fibonacci XNOR
-    end else if (64'(LfsrType) == "FIB_XNOR") begin
-      if (&next_state) begin
-        next_state = DefaultSeed;
-      end else begin
-        state0 = ~(^(next_state & lfsrcoeffs));
-        next_state = next_state << 1;
-        next_state[0] = state0;
-        next_state ^= LfsrDw'(entropy);
-      end
-    end else begin
-      $error("unknown lfsr type");
-    end
-
-    return next_state;
-  endfunction : compute_next_state
-
-  // check whether next state is computed correctly
-  // we shift the assertion by one clock cycle (##1) in order to avoid
-  // erroneous SVA triggers right after reset deassertion in cases where
-  // the precondition is true throughout the reset.
-  // this can happen since the disable_iff evaluates using unsampled values,
-  // meaning that the assertion may already read rst_ni == 1 on an active
-  // clock edge while the flops in the design have not yet changed state.
-  `ASSERT(NextStateCheck_A, ##1 lfsr_en_i && !seed_en_i |=> lfsr_q ==
-      compute_next_state(coeffs, $past(entropy_i), $past(lfsr_q)))
-
-  // Only check this if enabled.
-  if (StatePermEn) begin : gen_perm_check
-    // Check that the supplied permutation is valid.
-    logic [LfsrDw-1:0] lfsr_perm_test;
-    initial begin : p_perm_check
-      lfsr_perm_test = '0;
-      for (int k = 0; k < LfsrDw; k++) begin
-        lfsr_perm_test[StatePerm[k]] = 1'b1;
-      end
-      // All bit positions must be marked with 1.
-      `ASSERT_I(PermutationCheck_A, &lfsr_perm_test)
-    end
-  end
-
-`endif
-
-  `ASSERT_INIT(InputWidth_A, LfsrDw >= EntropyDw)
-  `ASSERT_INIT(OutputWidth_A, LfsrDw >= StateOutDw)
-
-  // MSB must be one in any case
-  `ASSERT(CoeffCheck_A, coeffs[LfsrDw-1])
-
-  // output check
-  `ASSERT_KNOWN(OutputKnown_A, state_o)
-  if (!StatePermEn && !NonLinearOut) begin : gen_output_sva
-    `ASSERT(OutputCheck_A, state_o == StateOutDw'(lfsr_q))
-  end
-  // if no external input changes the lfsr state, a lockup must not occur (by design)
-  //`ASSERT(NoLockups_A, (!entropy_i) && (!seed_en_i) |=> !lockup, clk_i, !rst_ni)
-  `ASSERT(NoLockups_A, lfsr_en_i && !entropy_i && !seed_en_i |=> !lockup)
-
-  // this can be disabled if unused in order to not distort coverage
-  if (ExtSeedSVA) begin : gen_ext_seed_sva
-    // check that external seed is correctly loaded into the state
-    // rst_ni is used directly as part of the pre-condition since the usage of rst_ni
-    // in disable_iff is unsampled.  See #1985 for more details
-    `ASSERT(ExtDefaultSeedInputCheck_A, (seed_en_i && rst_ni) |=> lfsr_q == $past(seed_i))
-  end
-
-  // if the external seed mechanism is not used,
-  // there is theoretically no way we end up in a lockup condition
-  // in order to not distort coverage, this SVA can be disabled in such cases
-  if (LockupSVA) begin : gen_lockup_mechanism_sva
-    // check that a stuck LFSR is correctly reseeded
-    `ASSERT(LfsrLockupCheck_A, lfsr_en_i && lockup && !seed_en_i |=> !lockup)
-  end
-
-  // If non-linear output requested, the LFSR width must be a power of 2 and greater than 16.
-  if(NonLinearOut) begin : gen_nonlinear_align_check_sva
-    `ASSERT_INIT(SboxByteAlign_A, 2**$clog2(LfsrDw) == LfsrDw && LfsrDw >= 16)
-  end
-
-  if (MaxLenSVA) begin : gen_max_len_sva
-`ifndef SYNTHESIS
-    // the code below is a workaround to enable long sequences to be checked.
-    // some simulators do not support SVA sequences longer than 2**32-1.
-    logic [LfsrDw-1:0] cnt_d, cnt_q;
-    logic perturbed_d, perturbed_q;
-    logic [LfsrDw-1:0] cmp_val;
-
-    assign cmp_val = {{(LfsrDw-1){1'b1}}, 1'b0}; // 2**LfsrDw-2
-    assign cnt_d = (lfsr_en_i && lockup)             ? '0           :
-                   (lfsr_en_i && (cnt_q == cmp_val)) ? '0           :
-                   (lfsr_en_i)                       ? cnt_q + 1'b1 :
-                                                       cnt_q;
-
-    assign perturbed_d = perturbed_q | (|entropy_i) | seed_en_i;
-
-    always_ff @(posedge clk_i or negedge rst_ni) begin : p_max_len
-      if (!rst_ni) begin
-        cnt_q       <= '0;
-        perturbed_q <= 1'b0;
-      end else begin
-        cnt_q       <= cnt_d;
-        perturbed_q <= perturbed_d;
-      end
-    end
-
-    `ASSERT(MaximalLengthCheck0_A, cnt_q == 0 |-> lfsr_q == DefaultSeed,
-        clk_i, !rst_ni || perturbed_q)
-    `ASSERT(MaximalLengthCheck1_A, cnt_q != 0 |-> lfsr_q != DefaultSeed,
-        clk_i, !rst_ni || perturbed_q)
-`endif
-  end
-
-endmodule
diff --git a/prim_max_tree.sv b/prim_max_tree.sv
deleted file mode 100644
index 9a3b85e4..00000000
--- a/prim_max_tree.sv
+++ /dev/null
@@ -1,147 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// The module implements a binary tree to find the maximal entry. the solution
-// has O(N) area and O(log(N)) delay complexity, and thus scales well with
-// many input sources.
-//
-// Note that only input values marked as "valid" are respected in the maximum computation.
-// If there are multiple valid inputs with the same value, the tree will always select the input
-// with the smallest index.
-//
-// If none of the input values are valid, the output index will be 0 and the output value will
-// be equal to the input value at index 0.
-
-
-`include "prim_assert.sv"
-
-module prim_max_tree #(
-  parameter int NumSrc = 32,
-  parameter int Width = 8,
-  // Derived parameters
-  localparam int SrcWidth = $clog2(NumSrc)
-) (
-  // The module is combinational - the clock and reset are only used for assertions.
-  input                         clk_i,
-  input                         rst_ni,
-  input [NumSrc-1:0][Width-1:0] values_i,    // Input values
-  input [NumSrc-1:0]            valid_i,     // Input valid bits
-  output logic [Width-1:0]      max_value_o, // Maximum value
-  output logic [SrcWidth-1:0]   max_idx_o,   // Index of the maximum value
-  output logic                  max_valid_o  // Whether any of the inputs is valid
-);
-
-  ///////////////////////
-  // Binary tree logic //
-  ///////////////////////
-
-  // This only works with 2 or more sources.
-  `ASSERT_INIT(NumSources_A, NumSrc >= 2)
-
-  // Align to powers of 2 for simplicity.
-  // A full binary tree with N levels has 2**N + 2**N-1 nodes.
-  localparam int NumLevels = $clog2(NumSrc);
-  logic [2**(NumLevels+1)-2:0]               vld_tree;
-  logic [2**(NumLevels+1)-2:0][SrcWidth-1:0] idx_tree;
-  logic [2**(NumLevels+1)-2:0][Width-1:0]    max_tree;
-
-  for (genvar level = 0; level < NumLevels+1; level++) begin : gen_tree
-    //
-    // level+1   C0   C1   <- "Base1" points to the first node on "level+1",
-    //            \  /         these nodes are the children of the nodes one level below
-    // level       Pa      <- "Base0", points to the first node on "level",
-    //                         these nodes are the parents of the nodes one level above
-    //
-    // hence we have the following indices for the paPa, C0, C1 nodes:
-    // Pa = 2**level     - 1 + offset       = Base0 + offset
-    // C0 = 2**(level+1) - 1 + 2*offset     = Base1 + 2*offset
-    // C1 = 2**(level+1) - 1 + 2*offset + 1 = Base1 + 2*offset + 1
-    //
-    localparam int Base0 = (2**level)-1;
-    localparam int Base1 = (2**(level+1))-1;
-
-    for (genvar offset = 0; offset < 2**level; offset++) begin : gen_level
-      localparam int Pa = Base0 + offset;
-      localparam int C0 = Base1 + 2*offset;
-      localparam int C1 = Base1 + 2*offset + 1;
-
-      // This assigns the input values, their corresponding IDs and valid signals to the tree leafs.
-      if (level == NumLevels) begin : gen_leafs
-        if (offset < NumSrc) begin : gen_assign
-          assign vld_tree[Pa] = valid_i[offset];
-          assign idx_tree[Pa] = offset;
-          assign max_tree[Pa] = values_i[offset];
-        end else begin : gen_tie_off
-          assign vld_tree[Pa] = '0;
-          assign idx_tree[Pa] = '0;
-          assign max_tree[Pa] = '0;
-        end
-      // This creates the node assignments.
-      end else begin : gen_nodes
-        logic sel; // Local helper variable
-        // In case only one of the parents is valid, forward that one
-        // In case both parents are valid, forward the one with higher value
-        assign sel = (~vld_tree[C0] & vld_tree[C1]) |
-                     (vld_tree[C0] & vld_tree[C1] & logic'(max_tree[C1] > max_tree[C0]));
-        // Forwarding muxes
-        // Note: these ternaries have triggered a synthesis bug in Vivado versions older
-        // than 2020.2. If the problem resurfaces again, have a look at issue #1408.
-        assign vld_tree[Pa] = (sel) ? vld_tree[C1] : vld_tree[C0];
-        assign idx_tree[Pa] = (sel) ? idx_tree[C1] : idx_tree[C0];
-        assign max_tree[Pa] = (sel) ? max_tree[C1] : max_tree[C0];
-      end
-    end : gen_level
-  end : gen_tree
-
-
-  // The results can be found at the tree root
-  assign max_valid_o = vld_tree[0];
-  assign max_idx_o   = idx_tree[0];
-  assign max_value_o = max_tree[0];
-
-  ////////////////
-  // Assertions //
-  ////////////////
-
-`ifdef INC_ASSERT
-  // Helper functions for assertions below.
-  function automatic logic [Width-1:0] max_value (input logic [NumSrc-1:0][Width-1:0] values_i,
-                                                  input logic [NumSrc-1:0]            valid_i);
-    logic [Width-1:0] value = '0;
-    for (int k = 0; k < NumSrc; k++) begin
-      if (valid_i[k] && values_i[k] > value) begin
-        value = values_i[k];
-      end
-    end
-    return value;
-  endfunction : max_value
-
-  function automatic logic [SrcWidth-1:0] max_idx (input logic [NumSrc-1:0][Width-1:0] values_i,
-                                                   input logic [NumSrc-1:0]            valid_i);
-    logic [Width-1:0] value = '0;
-    logic [SrcWidth-1:0] idx = '0;
-    for (int k = NumSrc-1; k >= 0; k--) begin
-      if (valid_i[k] && values_i[k] >= value) begin
-        value = values_i[k];
-        idx = k;
-      end
-    end
-    return idx;
-  endfunction : max_idx
-
-  logic [Width-1:0] max_value_exp;
-  logic [SrcWidth-1:0] max_idx_exp;
-  assign max_value_exp = max_value(values_i, valid_i);
-  assign max_idx_exp = max_idx(values_i, valid_i);
-
-  // TODO(10588): Below syntax is not supported in xcelium, track xcelium cases #46591452.
-  // `ASSERT(ValidInImpliesValidOut_A, |valid_i <-> max_valid_o)
-  `ASSERT(ValidInImpliesValidOut_A, |valid_i === max_valid_o)
-  `ASSERT(MaxComputation_A, max_valid_o |-> max_value_o == max_value_exp)
-  `ASSERT(MaxComputationInvalid_A, !max_valid_o |-> max_value_o == values_i[0])
-  `ASSERT(MaxIndexComputation_A, max_valid_o |-> max_idx_o == max_idx_exp)
-  `ASSERT(MaxIndexComputationInvalid_A, !max_valid_o |-> max_idx_o == '0)
-`endif
-
-endmodule : prim_max_tree
diff --git a/prim_msb_extend.sv b/prim_msb_extend.sv
deleted file mode 100644
index 9b37c64a..00000000
--- a/prim_msb_extend.sv
+++ /dev/null
@@ -1,27 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Extend the output with the msb of the input
-
-`include "prim_assert.sv"
-
-module prim_msb_extend # (
-  parameter int InWidth = 2,
-  parameter int OutWidth = 2
-) (
-  input [InWidth-1:0] in_i,
-  output [OutWidth-1:0] out_o
-);
-
-  `ASSERT_INIT(WidthCheck_A, OutWidth >= InWidth)
-
-  localparam int WidthDiff = OutWidth - InWidth;
-
-  if (WidthDiff == 0) begin : gen_feedthru
-    assign out_o = in_i;
-  end else begin : gen_tieoff
-    assign out_o = {{WidthDiff{in_i[InWidth-1]}}, in_i};
-  end
-
-endmodule
diff --git a/prim_mubi12_dec.sv b/prim_mubi12_dec.sv
deleted file mode 100644
index 1bc85033..00000000
--- a/prim_mubi12_dec.sv
+++ /dev/null
@@ -1,48 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// ------------------- W A R N I N G: A U T O - G E N E R A T E D   C O D E !! -------------------//
-// PLEASE DO NOT HAND-EDIT THIS FILE. IT HAS BEEN AUTO-GENERATED WITH THE FOLLOWING COMMAND:
-//
-//    util/design/gen-mubi.py
-//
-// Decoder for multibit control signals with additional input buffers.
-
-`include "prim_assert.sv"
-
-module prim_mubi12_dec
-  import prim_mubi_pkg::*;
-#(
-  parameter bit TestTrue = 1,
-  parameter bit TestStrict = 1
-) (
-  input  mubi12_t mubi_i,
-  output logic           mubi_dec_o
-);
-
-logic [MuBi12Width-1:0] mubi, mubi_out;
-assign mubi = MuBi12Width'(mubi_i);
-
-// The buffer cells have a don't touch constraint on them
-// such that synthesis tools won't collapse them
-for (genvar k = 0; k < MuBi12Width; k++) begin : gen_bits
-  prim_buf u_prim_buf (
-    .in_i  ( mubi[k]     ),
-    .out_o ( mubi_out[k] )
-  );
-end
-
-if (TestTrue && TestStrict) begin : gen_test_true_strict
-  assign mubi_dec_o = mubi12_test_true_strict(mubi12_t'(mubi_out));
-end else if (TestTrue && !TestStrict) begin : gen_test_true_loose
-  assign mubi_dec_o = mubi12_test_true_loose(mubi12_t'(mubi_out));
-end else if (!TestTrue && TestStrict) begin : gen_test_false_strict
-  assign mubi_dec_o = mubi12_test_false_strict(mubi12_t'(mubi_out));
-end else if (!TestTrue && !TestStrict) begin : gen_test_false_loose
-  assign mubi_dec_o = mubi12_test_false_loose(mubi12_t'(mubi_out));
-end else begin : gen_unknown_config
-  `ASSERT_INIT(UnknownConfig_A, 0)
-end
-
-endmodule : prim_mubi12_dec
diff --git a/prim_mubi12_sender.sv b/prim_mubi12_sender.sv
deleted file mode 100644
index 230efdca..00000000
--- a/prim_mubi12_sender.sv
+++ /dev/null
@@ -1,94 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// ------------------- W A R N I N G: A U T O - G E N E R A T E D   C O D E !! -------------------//
-// PLEASE DO NOT HAND-EDIT THIS FILE. IT HAS BEEN AUTO-GENERATED WITH THE FOLLOWING COMMAND:
-//
-//    util/design/gen-mubi.py
-//
-// Multibit sender module. This module is instantiates a hand-picked flop cell for each bit in the
-// multibit signal such that tools do not optimize the multibit encoding.
-
-`include "prim_assert.sv"
-
-module prim_mubi12_sender
-  import prim_mubi_pkg::*;
-#(
-  // This flops the output if set to 1.
-  // In special cases where the sender is in the same clock domain as the receiver,
-  // this can be set to 0. However, it is recommended to leave this at 1.
-  parameter bit AsyncOn = 1,
-  // Enable anchor buffer
-  parameter bit EnSecBuf = 0,
-  // Reset value for the sender flops
-  parameter mubi12_t ResetValue = MuBi12False
-) (
-  input          clk_i,
-  input          rst_ni,
-  input  mubi12_t mubi_i,
-  output mubi12_t mubi_o
-);
-
-  logic [MuBi12Width-1:0] mubi, mubi_int, mubi_out;
-  assign mubi = MuBi12Width'(mubi_i);
-
-  // first generation block decides whether a flop should be present
-  if (AsyncOn) begin : gen_flops
-    prim_flop #(
-      .Width(MuBi12Width),
-      .ResetValue(MuBi12Width'(ResetValue))
-    ) u_prim_flop (
-      .clk_i,
-      .rst_ni,
-      .d_i   ( mubi     ),
-      .q_o   ( mubi_int )
-    );
-  end else begin : gen_no_flops
-    assign mubi_int = mubi;
-
-    // This unused companion logic helps remove lint errors
-    // for modules where clock and reset are used for assertions only
-    // This logic will be removed for sythesis since it is unloaded.
-    mubi12_t unused_logic;
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-         unused_logic <= MuBi12False;
-      end else begin
-         unused_logic <= mubi_i;
-      end
-    end
-  end
-
-  // second generation block determines output buffer type
-  // 1. If EnSecBuf -> always leads to a sec buffer regardless of first block
-  // 2. If not EnSecBuf and not AsyncOn -> use normal buffer
-  // 3. If not EnSecBuf and AsyncOn -> feed through
-  if (EnSecBuf) begin : gen_sec_buf
-    prim_sec_anchor_buf #(
-      .Width(12)
-    ) u_prim_sec_buf (
-      .in_i(mubi_int),
-      .out_o(mubi_out)
-    );
-  end else if (!AsyncOn) begin : gen_prim_buf
-    prim_buf #(
-      .Width(12)
-    ) u_prim_buf (
-      .in_i(mubi_int),
-      .out_o(mubi_out)
-    );
-  end else begin : gen_feedthru
-    assign mubi_out = mubi_int;
-  end
-
-  assign mubi_o = mubi12_t'(mubi_out);
-
-  ////////////////
-  // Assertions //
-  ////////////////
-
-  // The outputs should be known at all times.
-  `ASSERT_KNOWN(OutputsKnown_A, mubi_o)
-
-endmodule : prim_mubi12_sender
diff --git a/prim_mubi12_sync.sv b/prim_mubi12_sync.sv
deleted file mode 100644
index c380142d..00000000
--- a/prim_mubi12_sync.sv
+++ /dev/null
@@ -1,165 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// ------------------- W A R N I N G: A U T O - G E N E R A T E D   C O D E !! -------------------//
-// PLEASE DO NOT HAND-EDIT THIS FILE. IT HAS BEEN AUTO-GENERATED WITH THE FOLLOWING COMMAND:
-//
-//    util/design/gen-mubi.py
-//
-// Double-synchronizer flop for multibit signals with additional output buffers.
-
-`include "prim_assert.sv"
-
-module prim_mubi12_sync
-  import prim_mubi_pkg::*;
-#(
-  // Number of separately buffered output signals.
-  // The buffer cells have a don't touch constraint
-  // on them such that synthesis tools won't collapse
-  // all copies into one signal.
-  parameter int NumCopies = 1,
-  // This instantiates the synchronizer flops if set to 1.
-  // In special cases where the receiver is in the same clock domain as the sender,
-  // this can be set to 0. However, it is recommended to leave this at 1.
-  parameter bit AsyncOn = 1,
-  // This controls whether the mubi module institutes stability checks when
-  // AsyncOn is set.  If stability checks are on, a 3rd stage of storage is
-  // added after the synchronizers and the outputs only updated if the 3rd
-  // stage and sychronizer agree.  If they do not agree, the ResetValue is
-  // output instead.
-  parameter bit StabilityCheck = 0,
-  // Reset value for the sync flops
-  parameter mubi12_t ResetValue = MuBi12False
-) (
-  input                          clk_i,
-  input                          rst_ni,
-  input  mubi12_t                 mubi_i,
-  output mubi12_t [NumCopies-1:0] mubi_o
-);
-
-  `ASSERT_INIT(NumCopiesMustBeGreaterZero_A, NumCopies > 0)
-
-  logic [MuBi12Width-1:0] mubi;
-  if (AsyncOn) begin : gen_flops
-    logic [MuBi12Width-1:0] mubi_sync;
-    prim_flop_2sync #(
-      .Width(MuBi12Width),
-      .ResetValue(MuBi12Width'(ResetValue))
-    ) u_prim_flop_2sync (
-      .clk_i,
-      .rst_ni,
-      .d_i(MuBi12Width'(mubi_i)),
-      .q_o(mubi_sync)
-    );
-
-    if (StabilityCheck) begin : gen_stable_chks
-      logic [MuBi12Width-1:0] mubi_q;
-      prim_flop #(
-        .Width(MuBi12Width),
-        .ResetValue(MuBi12Width'(ResetValue))
-      ) u_prim_flop_3rd_stage (
-        .clk_i,
-        .rst_ni,
-        .d_i(mubi_sync),
-        .q_o(mubi_q)
-      );
-
-      logic [MuBi12Width-1:0] sig_unstable;
-      prim_xor2 #(
-        .Width(MuBi12Width)
-      ) u_mubi_xor (
-        .in0_i(mubi_sync),
-        .in1_i(mubi_q),
-        .out_o(sig_unstable)
-      );
-
-      logic [MuBi12Width-1:0] reset_value;
-      assign reset_value = ResetValue;
-
-      for (genvar k = 0; k < MuBi12Width; k++) begin : gen_bufs_muxes
-        logic [MuBi12Width-1:0] sig_unstable_buf;
-
-        // each mux gets its own buffered output, this ensures the OR-ing
-        // cannot be defeated in one place.
-        prim_sec_anchor_buf #(
-          .Width(MuBi12Width)
-        ) u_sig_unstable_buf (
-          .in_i(sig_unstable),
-          .out_o(sig_unstable_buf)
-        );
-
-        // if any xor indicates signal is unstable, output the reset
-        // value.
-        prim_clock_mux2 #(
-          .NoFpgaBufG(1'b1)
-        ) u_mux (
-          .clk0_i(mubi_q[k]),
-          .clk1_i(reset_value[k]),
-          .sel_i(|sig_unstable_buf),
-          .clk_o(mubi[k])
-        );
-      end
-
-    end else begin : gen_no_stable_chks
-      assign mubi = mubi_sync;
-    end
-  end else begin : gen_no_flops
-
-    // This unused companion logic helps remove lint errors
-    // for modules where clock and reset are used for assertions only
-    // This logic will be removed for synthesis since it is unloaded.
-    mubi12_t unused_logic;
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-         unused_logic <= MuBi12False;
-      end else begin
-         unused_logic <= mubi_i;
-      end
-    end
-
-    assign mubi = MuBi12Width'(mubi_i);
-  end
-
-  for (genvar j = 0; j < NumCopies; j++) begin : gen_buffs
-    logic [MuBi12Width-1:0] mubi_out;
-    for (genvar k = 0; k < MuBi12Width; k++) begin : gen_bits
-      prim_buf u_prim_buf (
-        .in_i(mubi[k]),
-        .out_o(mubi_out[k])
-      );
-    end
-    assign mubi_o[j] = mubi12_t'(mubi_out);
-  end
-
-  ////////////////
-  // Assertions //
-  ////////////////
-
-  // The outputs should be known at all times.
-  `ASSERT_KNOWN(OutputsKnown_A, mubi_o)
-
-  // If the multibit signal is in a transient state, we expect it
-  // to be stable again within one clock cycle.
-  // DV will exclude these three assertions by name, thus added a module name prefix to make it
-  // harder to accidentally replicate in other modules.
-  `ASSERT(PrimMubi12SyncCheckTransients_A,
-      !(mubi_i inside {MuBi12True, MuBi12False})
-      |=>
-      (mubi_i inside {MuBi12True, MuBi12False}))
-
-  // If a signal departs from passive state, we expect it to move to the active state
-  // with only one transient cycle in between.
-  `ASSERT(PrimMubi12SyncCheckTransients0_A,
-      $past(mubi_i == MuBi12False) &&
-      !(mubi_i inside {MuBi12True, MuBi12False})
-      |=>
-      (mubi_i == MuBi12True))
-
-  `ASSERT(PrimMubi12SyncCheckTransients1_A,
-      $past(mubi_i == MuBi12True) &&
-      !(mubi_i inside {MuBi12True, MuBi12False})
-      |=>
-      (mubi_i == MuBi12False))
-
-endmodule : prim_mubi12_sync
diff --git a/prim_mubi16_dec.sv b/prim_mubi16_dec.sv
deleted file mode 100644
index 17411474..00000000
--- a/prim_mubi16_dec.sv
+++ /dev/null
@@ -1,48 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// ------------------- W A R N I N G: A U T O - G E N E R A T E D   C O D E !! -------------------//
-// PLEASE DO NOT HAND-EDIT THIS FILE. IT HAS BEEN AUTO-GENERATED WITH THE FOLLOWING COMMAND:
-//
-//    util/design/gen-mubi.py
-//
-// Decoder for multibit control signals with additional input buffers.
-
-`include "prim_assert.sv"
-
-module prim_mubi16_dec
-  import prim_mubi_pkg::*;
-#(
-  parameter bit TestTrue = 1,
-  parameter bit TestStrict = 1
-) (
-  input  mubi16_t mubi_i,
-  output logic           mubi_dec_o
-);
-
-logic [MuBi16Width-1:0] mubi, mubi_out;
-assign mubi = MuBi16Width'(mubi_i);
-
-// The buffer cells have a don't touch constraint on them
-// such that synthesis tools won't collapse them
-for (genvar k = 0; k < MuBi16Width; k++) begin : gen_bits
-  prim_buf u_prim_buf (
-    .in_i  ( mubi[k]     ),
-    .out_o ( mubi_out[k] )
-  );
-end
-
-if (TestTrue && TestStrict) begin : gen_test_true_strict
-  assign mubi_dec_o = mubi16_test_true_strict(mubi16_t'(mubi_out));
-end else if (TestTrue && !TestStrict) begin : gen_test_true_loose
-  assign mubi_dec_o = mubi16_test_true_loose(mubi16_t'(mubi_out));
-end else if (!TestTrue && TestStrict) begin : gen_test_false_strict
-  assign mubi_dec_o = mubi16_test_false_strict(mubi16_t'(mubi_out));
-end else if (!TestTrue && !TestStrict) begin : gen_test_false_loose
-  assign mubi_dec_o = mubi16_test_false_loose(mubi16_t'(mubi_out));
-end else begin : gen_unknown_config
-  `ASSERT_INIT(UnknownConfig_A, 0)
-end
-
-endmodule : prim_mubi16_dec
diff --git a/prim_mubi16_sender.sv b/prim_mubi16_sender.sv
deleted file mode 100644
index e12b99d2..00000000
--- a/prim_mubi16_sender.sv
+++ /dev/null
@@ -1,94 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// ------------------- W A R N I N G: A U T O - G E N E R A T E D   C O D E !! -------------------//
-// PLEASE DO NOT HAND-EDIT THIS FILE. IT HAS BEEN AUTO-GENERATED WITH THE FOLLOWING COMMAND:
-//
-//    util/design/gen-mubi.py
-//
-// Multibit sender module. This module is instantiates a hand-picked flop cell for each bit in the
-// multibit signal such that tools do not optimize the multibit encoding.
-
-`include "prim_assert.sv"
-
-module prim_mubi16_sender
-  import prim_mubi_pkg::*;
-#(
-  // This flops the output if set to 1.
-  // In special cases where the sender is in the same clock domain as the receiver,
-  // this can be set to 0. However, it is recommended to leave this at 1.
-  parameter bit AsyncOn = 1,
-  // Enable anchor buffer
-  parameter bit EnSecBuf = 0,
-  // Reset value for the sender flops
-  parameter mubi16_t ResetValue = MuBi16False
-) (
-  input          clk_i,
-  input          rst_ni,
-  input  mubi16_t mubi_i,
-  output mubi16_t mubi_o
-);
-
-  logic [MuBi16Width-1:0] mubi, mubi_int, mubi_out;
-  assign mubi = MuBi16Width'(mubi_i);
-
-  // first generation block decides whether a flop should be present
-  if (AsyncOn) begin : gen_flops
-    prim_flop #(
-      .Width(MuBi16Width),
-      .ResetValue(MuBi16Width'(ResetValue))
-    ) u_prim_flop (
-      .clk_i,
-      .rst_ni,
-      .d_i   ( mubi     ),
-      .q_o   ( mubi_int )
-    );
-  end else begin : gen_no_flops
-    assign mubi_int = mubi;
-
-    // This unused companion logic helps remove lint errors
-    // for modules where clock and reset are used for assertions only
-    // This logic will be removed for sythesis since it is unloaded.
-    mubi16_t unused_logic;
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-         unused_logic <= MuBi16False;
-      end else begin
-         unused_logic <= mubi_i;
-      end
-    end
-  end
-
-  // second generation block determines output buffer type
-  // 1. If EnSecBuf -> always leads to a sec buffer regardless of first block
-  // 2. If not EnSecBuf and not AsyncOn -> use normal buffer
-  // 3. If not EnSecBuf and AsyncOn -> feed through
-  if (EnSecBuf) begin : gen_sec_buf
-    prim_sec_anchor_buf #(
-      .Width(16)
-    ) u_prim_sec_buf (
-      .in_i(mubi_int),
-      .out_o(mubi_out)
-    );
-  end else if (!AsyncOn) begin : gen_prim_buf
-    prim_buf #(
-      .Width(16)
-    ) u_prim_buf (
-      .in_i(mubi_int),
-      .out_o(mubi_out)
-    );
-  end else begin : gen_feedthru
-    assign mubi_out = mubi_int;
-  end
-
-  assign mubi_o = mubi16_t'(mubi_out);
-
-  ////////////////
-  // Assertions //
-  ////////////////
-
-  // The outputs should be known at all times.
-  `ASSERT_KNOWN(OutputsKnown_A, mubi_o)
-
-endmodule : prim_mubi16_sender
diff --git a/prim_mubi16_sync.sv b/prim_mubi16_sync.sv
deleted file mode 100644
index 8ee4b2f2..00000000
--- a/prim_mubi16_sync.sv
+++ /dev/null
@@ -1,165 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// ------------------- W A R N I N G: A U T O - G E N E R A T E D   C O D E !! -------------------//
-// PLEASE DO NOT HAND-EDIT THIS FILE. IT HAS BEEN AUTO-GENERATED WITH THE FOLLOWING COMMAND:
-//
-//    util/design/gen-mubi.py
-//
-// Double-synchronizer flop for multibit signals with additional output buffers.
-
-`include "prim_assert.sv"
-
-module prim_mubi16_sync
-  import prim_mubi_pkg::*;
-#(
-  // Number of separately buffered output signals.
-  // The buffer cells have a don't touch constraint
-  // on them such that synthesis tools won't collapse
-  // all copies into one signal.
-  parameter int NumCopies = 1,
-  // This instantiates the synchronizer flops if set to 1.
-  // In special cases where the receiver is in the same clock domain as the sender,
-  // this can be set to 0. However, it is recommended to leave this at 1.
-  parameter bit AsyncOn = 1,
-  // This controls whether the mubi module institutes stability checks when
-  // AsyncOn is set.  If stability checks are on, a 3rd stage of storage is
-  // added after the synchronizers and the outputs only updated if the 3rd
-  // stage and sychronizer agree.  If they do not agree, the ResetValue is
-  // output instead.
-  parameter bit StabilityCheck = 0,
-  // Reset value for the sync flops
-  parameter mubi16_t ResetValue = MuBi16False
-) (
-  input                          clk_i,
-  input                          rst_ni,
-  input  mubi16_t                 mubi_i,
-  output mubi16_t [NumCopies-1:0] mubi_o
-);
-
-  `ASSERT_INIT(NumCopiesMustBeGreaterZero_A, NumCopies > 0)
-
-  logic [MuBi16Width-1:0] mubi;
-  if (AsyncOn) begin : gen_flops
-    logic [MuBi16Width-1:0] mubi_sync;
-    prim_flop_2sync #(
-      .Width(MuBi16Width),
-      .ResetValue(MuBi16Width'(ResetValue))
-    ) u_prim_flop_2sync (
-      .clk_i,
-      .rst_ni,
-      .d_i(MuBi16Width'(mubi_i)),
-      .q_o(mubi_sync)
-    );
-
-    if (StabilityCheck) begin : gen_stable_chks
-      logic [MuBi16Width-1:0] mubi_q;
-      prim_flop #(
-        .Width(MuBi16Width),
-        .ResetValue(MuBi16Width'(ResetValue))
-      ) u_prim_flop_3rd_stage (
-        .clk_i,
-        .rst_ni,
-        .d_i(mubi_sync),
-        .q_o(mubi_q)
-      );
-
-      logic [MuBi16Width-1:0] sig_unstable;
-      prim_xor2 #(
-        .Width(MuBi16Width)
-      ) u_mubi_xor (
-        .in0_i(mubi_sync),
-        .in1_i(mubi_q),
-        .out_o(sig_unstable)
-      );
-
-      logic [MuBi16Width-1:0] reset_value;
-      assign reset_value = ResetValue;
-
-      for (genvar k = 0; k < MuBi16Width; k++) begin : gen_bufs_muxes
-        logic [MuBi16Width-1:0] sig_unstable_buf;
-
-        // each mux gets its own buffered output, this ensures the OR-ing
-        // cannot be defeated in one place.
-        prim_sec_anchor_buf #(
-          .Width(MuBi16Width)
-        ) u_sig_unstable_buf (
-          .in_i(sig_unstable),
-          .out_o(sig_unstable_buf)
-        );
-
-        // if any xor indicates signal is unstable, output the reset
-        // value.
-        prim_clock_mux2 #(
-          .NoFpgaBufG(1'b1)
-        ) u_mux (
-          .clk0_i(mubi_q[k]),
-          .clk1_i(reset_value[k]),
-          .sel_i(|sig_unstable_buf),
-          .clk_o(mubi[k])
-        );
-      end
-
-    end else begin : gen_no_stable_chks
-      assign mubi = mubi_sync;
-    end
-  end else begin : gen_no_flops
-
-    // This unused companion logic helps remove lint errors
-    // for modules where clock and reset are used for assertions only
-    // This logic will be removed for synthesis since it is unloaded.
-    mubi16_t unused_logic;
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-         unused_logic <= MuBi16False;
-      end else begin
-         unused_logic <= mubi_i;
-      end
-    end
-
-    assign mubi = MuBi16Width'(mubi_i);
-  end
-
-  for (genvar j = 0; j < NumCopies; j++) begin : gen_buffs
-    logic [MuBi16Width-1:0] mubi_out;
-    for (genvar k = 0; k < MuBi16Width; k++) begin : gen_bits
-      prim_buf u_prim_buf (
-        .in_i(mubi[k]),
-        .out_o(mubi_out[k])
-      );
-    end
-    assign mubi_o[j] = mubi16_t'(mubi_out);
-  end
-
-  ////////////////
-  // Assertions //
-  ////////////////
-
-  // The outputs should be known at all times.
-  `ASSERT_KNOWN(OutputsKnown_A, mubi_o)
-
-  // If the multibit signal is in a transient state, we expect it
-  // to be stable again within one clock cycle.
-  // DV will exclude these three assertions by name, thus added a module name prefix to make it
-  // harder to accidentally replicate in other modules.
-  `ASSERT(PrimMubi16SyncCheckTransients_A,
-      !(mubi_i inside {MuBi16True, MuBi16False})
-      |=>
-      (mubi_i inside {MuBi16True, MuBi16False}))
-
-  // If a signal departs from passive state, we expect it to move to the active state
-  // with only one transient cycle in between.
-  `ASSERT(PrimMubi16SyncCheckTransients0_A,
-      $past(mubi_i == MuBi16False) &&
-      !(mubi_i inside {MuBi16True, MuBi16False})
-      |=>
-      (mubi_i == MuBi16True))
-
-  `ASSERT(PrimMubi16SyncCheckTransients1_A,
-      $past(mubi_i == MuBi16True) &&
-      !(mubi_i inside {MuBi16True, MuBi16False})
-      |=>
-      (mubi_i == MuBi16False))
-
-endmodule : prim_mubi16_sync
diff --git a/prim_mubi4_dec.sv b/prim_mubi4_dec.sv
deleted file mode 100644
index b822fa89..00000000
--- a/prim_mubi4_dec.sv
+++ /dev/null
@@ -1,48 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// ------------------- W A R N I N G: A U T O - G E N E R A T E D   C O D E !! -------------------//
-// PLEASE DO NOT HAND-EDIT THIS FILE. IT HAS BEEN AUTO-GENERATED WITH THE FOLLOWING COMMAND:
-//
-//    util/design/gen-mubi.py
-//
-// Decoder for multibit control signals with additional input buffers.
-
-`include "prim_assert.sv"
-
-module prim_mubi4_dec
-  import prim_mubi_pkg::*;
-#(
-  parameter bit TestTrue = 1,
-  parameter bit TestStrict = 1
-) (
-  input  mubi4_t mubi_i,
-  output logic           mubi_dec_o
-);
-
-logic [MuBi4Width-1:0] mubi, mubi_out;
-assign mubi = MuBi4Width'(mubi_i);
-
-// The buffer cells have a don't touch constraint on them
-// such that synthesis tools won't collapse them
-for (genvar k = 0; k < MuBi4Width; k++) begin : gen_bits
-  prim_buf u_prim_buf (
-    .in_i  ( mubi[k]     ),
-    .out_o ( mubi_out[k] )
-  );
-end
-
-if (TestTrue && TestStrict) begin : gen_test_true_strict
-  assign mubi_dec_o = mubi4_test_true_strict(mubi4_t'(mubi_out));
-end else if (TestTrue && !TestStrict) begin : gen_test_true_loose
-  assign mubi_dec_o = mubi4_test_true_loose(mubi4_t'(mubi_out));
-end else if (!TestTrue && TestStrict) begin : gen_test_false_strict
-  assign mubi_dec_o = mubi4_test_false_strict(mubi4_t'(mubi_out));
-end else if (!TestTrue && !TestStrict) begin : gen_test_false_loose
-  assign mubi_dec_o = mubi4_test_false_loose(mubi4_t'(mubi_out));
-end else begin : gen_unknown_config
-  `ASSERT_INIT(UnknownConfig_A, 0)
-end
-
-endmodule : prim_mubi4_dec
diff --git a/prim_mubi4_sender.sv b/prim_mubi4_sender.sv
deleted file mode 100644
index 85b7af87..00000000
--- a/prim_mubi4_sender.sv
+++ /dev/null
@@ -1,94 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// ------------------- W A R N I N G: A U T O - G E N E R A T E D   C O D E !! -------------------//
-// PLEASE DO NOT HAND-EDIT THIS FILE. IT HAS BEEN AUTO-GENERATED WITH THE FOLLOWING COMMAND:
-//
-//    util/design/gen-mubi.py
-//
-// Multibit sender module. This module is instantiates a hand-picked flop cell for each bit in the
-// multibit signal such that tools do not optimize the multibit encoding.
-
-`include "prim_assert.sv"
-
-module prim_mubi4_sender
-  import prim_mubi_pkg::*;
-#(
-  // This flops the output if set to 1.
-  // In special cases where the sender is in the same clock domain as the receiver,
-  // this can be set to 0. However, it is recommended to leave this at 1.
-  parameter bit AsyncOn = 1,
-  // Enable anchor buffer
-  parameter bit EnSecBuf = 0,
-  // Reset value for the sender flops
-  parameter mubi4_t ResetValue = MuBi4False
-) (
-  input          clk_i,
-  input          rst_ni,
-  input  mubi4_t mubi_i,
-  output mubi4_t mubi_o
-);
-
-  logic [MuBi4Width-1:0] mubi, mubi_int, mubi_out;
-  assign mubi = MuBi4Width'(mubi_i);
-
-  // first generation block decides whether a flop should be present
-  if (AsyncOn) begin : gen_flops
-    prim_flop #(
-      .Width(MuBi4Width),
-      .ResetValue(MuBi4Width'(ResetValue))
-    ) u_prim_flop (
-      .clk_i,
-      .rst_ni,
-      .d_i   ( mubi     ),
-      .q_o   ( mubi_int )
-    );
-  end else begin : gen_no_flops
-    assign mubi_int = mubi;
-
-    // This unused companion logic helps remove lint errors
-    // for modules where clock and reset are used for assertions only
-    // This logic will be removed for sythesis since it is unloaded.
-    mubi4_t unused_logic;
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-         unused_logic <= MuBi4False;
-      end else begin
-         unused_logic <= mubi_i;
-      end
-    end
-  end
-
-  // second generation block determines output buffer type
-  // 1. If EnSecBuf -> always leads to a sec buffer regardless of first block
-  // 2. If not EnSecBuf and not AsyncOn -> use normal buffer
-  // 3. If not EnSecBuf and AsyncOn -> feed through
-  if (EnSecBuf) begin : gen_sec_buf
-    prim_sec_anchor_buf #(
-      .Width(4)
-    ) u_prim_sec_buf (
-      .in_i(mubi_int),
-      .out_o(mubi_out)
-    );
-  end else if (!AsyncOn) begin : gen_prim_buf
-    prim_buf #(
-      .Width(4)
-    ) u_prim_buf (
-      .in_i(mubi_int),
-      .out_o(mubi_out)
-    );
-  end else begin : gen_feedthru
-    assign mubi_out = mubi_int;
-  end
-
-  assign mubi_o = mubi4_t'(mubi_out);
-
-  ////////////////
-  // Assertions //
-  ////////////////
-
-  // The outputs should be known at all times.
-  `ASSERT_KNOWN(OutputsKnown_A, mubi_o)
-
-endmodule : prim_mubi4_sender
diff --git a/prim_mubi4_sync.sv b/prim_mubi4_sync.sv
deleted file mode 100644
index 8c7d9958..00000000
--- a/prim_mubi4_sync.sv
+++ /dev/null
@@ -1,165 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// ------------------- W A R N I N G: A U T O - G E N E R A T E D   C O D E !! -------------------//
-// PLEASE DO NOT HAND-EDIT THIS FILE. IT HAS BEEN AUTO-GENERATED WITH THE FOLLOWING COMMAND:
-//
-//    util/design/gen-mubi.py
-//
-// Double-synchronizer flop for multibit signals with additional output buffers.
-
-`include "prim_assert.sv"
-
-module prim_mubi4_sync
-  import prim_mubi_pkg::*;
-#(
-  // Number of separately buffered output signals.
-  // The buffer cells have a don't touch constraint
-  // on them such that synthesis tools won't collapse
-  // all copies into one signal.
-  parameter int NumCopies = 1,
-  // This instantiates the synchronizer flops if set to 1.
-  // In special cases where the receiver is in the same clock domain as the sender,
-  // this can be set to 0. However, it is recommended to leave this at 1.
-  parameter bit AsyncOn = 1,
-  // This controls whether the mubi module institutes stability checks when
-  // AsyncOn is set.  If stability checks are on, a 3rd stage of storage is
-  // added after the synchronizers and the outputs only updated if the 3rd
-  // stage and sychronizer agree.  If they do not agree, the ResetValue is
-  // output instead.
-  parameter bit StabilityCheck = 0,
-  // Reset value for the sync flops
-  parameter mubi4_t ResetValue = MuBi4False
-) (
-  input                          clk_i,
-  input                          rst_ni,
-  input  mubi4_t                 mubi_i,
-  output mubi4_t [NumCopies-1:0] mubi_o
-);
-
-  `ASSERT_INIT(NumCopiesMustBeGreaterZero_A, NumCopies > 0)
-
-  logic [MuBi4Width-1:0] mubi;
-  if (AsyncOn) begin : gen_flops
-    logic [MuBi4Width-1:0] mubi_sync;
-    prim_flop_2sync #(
-      .Width(MuBi4Width),
-      .ResetValue(MuBi4Width'(ResetValue))
-    ) u_prim_flop_2sync (
-      .clk_i,
-      .rst_ni,
-      .d_i(MuBi4Width'(mubi_i)),
-      .q_o(mubi_sync)
-    );
-
-    if (StabilityCheck) begin : gen_stable_chks
-      logic [MuBi4Width-1:0] mubi_q;
-      prim_flop #(
-        .Width(MuBi4Width),
-        .ResetValue(MuBi4Width'(ResetValue))
-      ) u_prim_flop_3rd_stage (
-        .clk_i,
-        .rst_ni,
-        .d_i(mubi_sync),
-        .q_o(mubi_q)
-      );
-
-      logic [MuBi4Width-1:0] sig_unstable;
-      prim_xor2 #(
-        .Width(MuBi4Width)
-      ) u_mubi_xor (
-        .in0_i(mubi_sync),
-        .in1_i(mubi_q),
-        .out_o(sig_unstable)
-      );
-
-      logic [MuBi4Width-1:0] reset_value;
-      assign reset_value = ResetValue;
-
-      for (genvar k = 0; k < MuBi4Width; k++) begin : gen_bufs_muxes
-        logic [MuBi4Width-1:0] sig_unstable_buf;
-
-        // each mux gets its own buffered output, this ensures the OR-ing
-        // cannot be defeated in one place.
-        prim_sec_anchor_buf #(
-          .Width(MuBi4Width)
-        ) u_sig_unstable_buf (
-          .in_i(sig_unstable),
-          .out_o(sig_unstable_buf)
-        );
-
-        // if any xor indicates signal is unstable, output the reset
-        // value.
-        prim_clock_mux2 #(
-          .NoFpgaBufG(1'b1)
-        ) u_mux (
-          .clk0_i(mubi_q[k]),
-          .clk1_i(reset_value[k]),
-          .sel_i(|sig_unstable_buf),
-          .clk_o(mubi[k])
-        );
-      end
-
-    end else begin : gen_no_stable_chks
-      assign mubi = mubi_sync;
-    end
-  end else begin : gen_no_flops
-
-    // This unused companion logic helps remove lint errors
-    // for modules where clock and reset are used for assertions only
-    // This logic will be removed for synthesis since it is unloaded.
-    mubi4_t unused_logic;
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-         unused_logic <= MuBi4False;
-      end else begin
-         unused_logic <= mubi_i;
-      end
-    end
-
-    assign mubi = MuBi4Width'(mubi_i);
-  end
-
-  for (genvar j = 0; j < NumCopies; j++) begin : gen_buffs
-    logic [MuBi4Width-1:0] mubi_out;
-    for (genvar k = 0; k < MuBi4Width; k++) begin : gen_bits
-      prim_buf u_prim_buf (
-        .in_i(mubi[k]),
-        .out_o(mubi_out[k])
-      );
-    end
-    assign mubi_o[j] = mubi4_t'(mubi_out);
-  end
-
-  ////////////////
-  // Assertions //
-  ////////////////
-
-  // The outputs should be known at all times.
-  `ASSERT_KNOWN(OutputsKnown_A, mubi_o)
-
-  // If the multibit signal is in a transient state, we expect it
-  // to be stable again within one clock cycle.
-  // DV will exclude these three assertions by name, thus added a module name prefix to make it
-  // harder to accidentally replicate in other modules.
-  `ASSERT(PrimMubi4SyncCheckTransients_A,
-      !(mubi_i inside {MuBi4True, MuBi4False})
-      |=>
-      (mubi_i inside {MuBi4True, MuBi4False}))
-
-  // If a signal departs from passive state, we expect it to move to the active state
-  // with only one transient cycle in between.
-  `ASSERT(PrimMubi4SyncCheckTransients0_A,
-      $past(mubi_i == MuBi4False) &&
-      !(mubi_i inside {MuBi4True, MuBi4False})
-      |=>
-      (mubi_i == MuBi4True))
-
-  `ASSERT(PrimMubi4SyncCheckTransients1_A,
-      $past(mubi_i == MuBi4True) &&
-      !(mubi_i inside {MuBi4True, MuBi4False})
-      |=>
-      (mubi_i == MuBi4False))
-
-endmodule : prim_mubi4_sync
diff --git a/prim_mubi8_dec.sv b/prim_mubi8_dec.sv
deleted file mode 100644
index 0f7171f2..00000000
--- a/prim_mubi8_dec.sv
+++ /dev/null
@@ -1,48 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// ------------------- W A R N I N G: A U T O - G E N E R A T E D   C O D E !! -------------------//
-// PLEASE DO NOT HAND-EDIT THIS FILE. IT HAS BEEN AUTO-GENERATED WITH THE FOLLOWING COMMAND:
-//
-//    util/design/gen-mubi.py
-//
-// Decoder for multibit control signals with additional input buffers.
-
-`include "prim_assert.sv"
-
-module prim_mubi8_dec
-  import prim_mubi_pkg::*;
-#(
-  parameter bit TestTrue = 1,
-  parameter bit TestStrict = 1
-) (
-  input  mubi8_t mubi_i,
-  output logic           mubi_dec_o
-);
-
-logic [MuBi8Width-1:0] mubi, mubi_out;
-assign mubi = MuBi8Width'(mubi_i);
-
-// The buffer cells have a don't touch constraint on them
-// such that synthesis tools won't collapse them
-for (genvar k = 0; k < MuBi8Width; k++) begin : gen_bits
-  prim_buf u_prim_buf (
-    .in_i  ( mubi[k]     ),
-    .out_o ( mubi_out[k] )
-  );
-end
-
-if (TestTrue && TestStrict) begin : gen_test_true_strict
-  assign mubi_dec_o = mubi8_test_true_strict(mubi8_t'(mubi_out));
-end else if (TestTrue && !TestStrict) begin : gen_test_true_loose
-  assign mubi_dec_o = mubi8_test_true_loose(mubi8_t'(mubi_out));
-end else if (!TestTrue && TestStrict) begin : gen_test_false_strict
-  assign mubi_dec_o = mubi8_test_false_strict(mubi8_t'(mubi_out));
-end else if (!TestTrue && !TestStrict) begin : gen_test_false_loose
-  assign mubi_dec_o = mubi8_test_false_loose(mubi8_t'(mubi_out));
-end else begin : gen_unknown_config
-  `ASSERT_INIT(UnknownConfig_A, 0)
-end
-
-endmodule : prim_mubi8_dec
diff --git a/prim_mubi8_sender.sv b/prim_mubi8_sender.sv
deleted file mode 100644
index 7fb81f50..00000000
--- a/prim_mubi8_sender.sv
+++ /dev/null
@@ -1,94 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// ------------------- W A R N I N G: A U T O - G E N E R A T E D   C O D E !! -------------------//
-// PLEASE DO NOT HAND-EDIT THIS FILE. IT HAS BEEN AUTO-GENERATED WITH THE FOLLOWING COMMAND:
-//
-//    util/design/gen-mubi.py
-//
-// Multibit sender module. This module is instantiates a hand-picked flop cell for each bit in the
-// multibit signal such that tools do not optimize the multibit encoding.
-
-`include "prim_assert.sv"
-
-module prim_mubi8_sender
-  import prim_mubi_pkg::*;
-#(
-  // This flops the output if set to 1.
-  // In special cases where the sender is in the same clock domain as the receiver,
-  // this can be set to 0. However, it is recommended to leave this at 1.
-  parameter bit AsyncOn = 1,
-  // Enable anchor buffer
-  parameter bit EnSecBuf = 0,
-  // Reset value for the sender flops
-  parameter mubi8_t ResetValue = MuBi8False
-) (
-  input          clk_i,
-  input          rst_ni,
-  input  mubi8_t mubi_i,
-  output mubi8_t mubi_o
-);
-
-  logic [MuBi8Width-1:0] mubi, mubi_int, mubi_out;
-  assign mubi = MuBi8Width'(mubi_i);
-
-  // first generation block decides whether a flop should be present
-  if (AsyncOn) begin : gen_flops
-    prim_flop #(
-      .Width(MuBi8Width),
-      .ResetValue(MuBi8Width'(ResetValue))
-    ) u_prim_flop (
-      .clk_i,
-      .rst_ni,
-      .d_i   ( mubi     ),
-      .q_o   ( mubi_int )
-    );
-  end else begin : gen_no_flops
-    assign mubi_int = mubi;
-
-    // This unused companion logic helps remove lint errors
-    // for modules where clock and reset are used for assertions only
-    // This logic will be removed for sythesis since it is unloaded.
-    mubi8_t unused_logic;
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-         unused_logic <= MuBi8False;
-      end else begin
-         unused_logic <= mubi_i;
-      end
-    end
-  end
-
-  // second generation block determines output buffer type
-  // 1. If EnSecBuf -> always leads to a sec buffer regardless of first block
-  // 2. If not EnSecBuf and not AsyncOn -> use normal buffer
-  // 3. If not EnSecBuf and AsyncOn -> feed through
-  if (EnSecBuf) begin : gen_sec_buf
-    prim_sec_anchor_buf #(
-      .Width(8)
-    ) u_prim_sec_buf (
-      .in_i(mubi_int),
-      .out_o(mubi_out)
-    );
-  end else if (!AsyncOn) begin : gen_prim_buf
-    prim_buf #(
-      .Width(8)
-    ) u_prim_buf (
-      .in_i(mubi_int),
-      .out_o(mubi_out)
-    );
-  end else begin : gen_feedthru
-    assign mubi_out = mubi_int;
-  end
-
-  assign mubi_o = mubi8_t'(mubi_out);
-
-  ////////////////
-  // Assertions //
-  ////////////////
-
-  // The outputs should be known at all times.
-  `ASSERT_KNOWN(OutputsKnown_A, mubi_o)
-
-endmodule : prim_mubi8_sender
diff --git a/prim_mubi8_sync.sv b/prim_mubi8_sync.sv
deleted file mode 100644
index bb543a8d..00000000
--- a/prim_mubi8_sync.sv
+++ /dev/null
@@ -1,165 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// ------------------- W A R N I N G: A U T O - G E N E R A T E D   C O D E !! -------------------//
-// PLEASE DO NOT HAND-EDIT THIS FILE. IT HAS BEEN AUTO-GENERATED WITH THE FOLLOWING COMMAND:
-//
-//    util/design/gen-mubi.py
-//
-// Double-synchronizer flop for multibit signals with additional output buffers.
-
-`include "prim_assert.sv"
-
-module prim_mubi8_sync
-  import prim_mubi_pkg::*;
-#(
-  // Number of separately buffered output signals.
-  // The buffer cells have a don't touch constraint
-  // on them such that synthesis tools won't collapse
-  // all copies into one signal.
-  parameter int NumCopies = 1,
-  // This instantiates the synchronizer flops if set to 1.
-  // In special cases where the receiver is in the same clock domain as the sender,
-  // this can be set to 0. However, it is recommended to leave this at 1.
-  parameter bit AsyncOn = 1,
-  // This controls whether the mubi module institutes stability checks when
-  // AsyncOn is set.  If stability checks are on, a 3rd stage of storage is
-  // added after the synchronizers and the outputs only updated if the 3rd
-  // stage and sychronizer agree.  If they do not agree, the ResetValue is
-  // output instead.
-  parameter bit StabilityCheck = 0,
-  // Reset value for the sync flops
-  parameter mubi8_t ResetValue = MuBi8False
-) (
-  input                          clk_i,
-  input                          rst_ni,
-  input  mubi8_t                 mubi_i,
-  output mubi8_t [NumCopies-1:0] mubi_o
-);
-
-  `ASSERT_INIT(NumCopiesMustBeGreaterZero_A, NumCopies > 0)
-
-  logic [MuBi8Width-1:0] mubi;
-  if (AsyncOn) begin : gen_flops
-    logic [MuBi8Width-1:0] mubi_sync;
-    prim_flop_2sync #(
-      .Width(MuBi8Width),
-      .ResetValue(MuBi8Width'(ResetValue))
-    ) u_prim_flop_2sync (
-      .clk_i,
-      .rst_ni,
-      .d_i(MuBi8Width'(mubi_i)),
-      .q_o(mubi_sync)
-    );
-
-    if (StabilityCheck) begin : gen_stable_chks
-      logic [MuBi8Width-1:0] mubi_q;
-      prim_flop #(
-        .Width(MuBi8Width),
-        .ResetValue(MuBi8Width'(ResetValue))
-      ) u_prim_flop_3rd_stage (
-        .clk_i,
-        .rst_ni,
-        .d_i(mubi_sync),
-        .q_o(mubi_q)
-      );
-
-      logic [MuBi8Width-1:0] sig_unstable;
-      prim_xor2 #(
-        .Width(MuBi8Width)
-      ) u_mubi_xor (
-        .in0_i(mubi_sync),
-        .in1_i(mubi_q),
-        .out_o(sig_unstable)
-      );
-
-      logic [MuBi8Width-1:0] reset_value;
-      assign reset_value = ResetValue;
-
-      for (genvar k = 0; k < MuBi8Width; k++) begin : gen_bufs_muxes
-        logic [MuBi8Width-1:0] sig_unstable_buf;
-
-        // each mux gets its own buffered output, this ensures the OR-ing
-        // cannot be defeated in one place.
-        prim_sec_anchor_buf #(
-          .Width(MuBi8Width)
-        ) u_sig_unstable_buf (
-          .in_i(sig_unstable),
-          .out_o(sig_unstable_buf)
-        );
-
-        // if any xor indicates signal is unstable, output the reset
-        // value.
-        prim_clock_mux2 #(
-          .NoFpgaBufG(1'b1)
-        ) u_mux (
-          .clk0_i(mubi_q[k]),
-          .clk1_i(reset_value[k]),
-          .sel_i(|sig_unstable_buf),
-          .clk_o(mubi[k])
-        );
-      end
-
-    end else begin : gen_no_stable_chks
-      assign mubi = mubi_sync;
-    end
-  end else begin : gen_no_flops
-
-    // This unused companion logic helps remove lint errors
-    // for modules where clock and reset are used for assertions only
-    // This logic will be removed for synthesis since it is unloaded.
-    mubi8_t unused_logic;
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-         unused_logic <= MuBi8False;
-      end else begin
-         unused_logic <= mubi_i;
-      end
-    end
-
-    assign mubi = MuBi8Width'(mubi_i);
-  end
-
-  for (genvar j = 0; j < NumCopies; j++) begin : gen_buffs
-    logic [MuBi8Width-1:0] mubi_out;
-    for (genvar k = 0; k < MuBi8Width; k++) begin : gen_bits
-      prim_buf u_prim_buf (
-        .in_i(mubi[k]),
-        .out_o(mubi_out[k])
-      );
-    end
-    assign mubi_o[j] = mubi8_t'(mubi_out);
-  end
-
-  ////////////////
-  // Assertions //
-  ////////////////
-
-  // The outputs should be known at all times.
-  `ASSERT_KNOWN(OutputsKnown_A, mubi_o)
-
-  // If the multibit signal is in a transient state, we expect it
-  // to be stable again within one clock cycle.
-  // DV will exclude these three assertions by name, thus added a module name prefix to make it
-  // harder to accidentally replicate in other modules.
-  `ASSERT(PrimMubi8SyncCheckTransients_A,
-      !(mubi_i inside {MuBi8True, MuBi8False})
-      |=>
-      (mubi_i inside {MuBi8True, MuBi8False}))
-
-  // If a signal departs from passive state, we expect it to move to the active state
-  // with only one transient cycle in between.
-  `ASSERT(PrimMubi8SyncCheckTransients0_A,
-      $past(mubi_i == MuBi8False) &&
-      !(mubi_i inside {MuBi8True, MuBi8False})
-      |=>
-      (mubi_i == MuBi8True))
-
-  `ASSERT(PrimMubi8SyncCheckTransients1_A,
-      $past(mubi_i == MuBi8True) &&
-      !(mubi_i inside {MuBi8True, MuBi8False})
-      |=>
-      (mubi_i == MuBi8False))
-
-endmodule : prim_mubi8_sync
diff --git a/prim_mubi_pkg.sv b/prim_mubi_pkg.sv
deleted file mode 100644
index b0b3e838..00000000
--- a/prim_mubi_pkg.sv
+++ /dev/null
@@ -1,531 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// ------------------- W A R N I N G: A U T O - G E N E R A T E D   C O D E !! -------------------//
-// PLEASE DO NOT HAND-EDIT THIS FILE. IT HAS BEEN AUTO-GENERATED WITH THE FOLLOWING COMMAND:
-//
-//    util/design/gen-mubi.py
-//
-// This package defines common multibit signal types, active high and active low values and
-// the corresponding functions to test whether the values are set or not.
-
-package prim_mubi_pkg;
-
-  //////////////////////////////////////////////
-  // 4 Bit Multibit Type and Functions //
-  //////////////////////////////////////////////
-
-  parameter int MuBi4Width = 4;
-  typedef enum logic [MuBi4Width-1:0] {
-    MuBi4True = 4'hA, // enabled
-    MuBi4False = 4'h5  // disabled
-  } mubi4_t;
-
-  // Test whether the value is supplied is one of the valid enumerations
-  function automatic logic mubi4_test_invalid(mubi4_t val);
-    return ~(val inside {MuBi4True, MuBi4False});
-  endfunction : mubi4_test_invalid
-
-  // Convert a 1 input value to a mubi output
-  function automatic mubi4_t mubi4_bool_to_mubi(logic val);
-    return (val ? MuBi4True : MuBi4False);
-  endfunction : mubi4_bool_to_mubi
-
-  // Test whether the multibit value signals an "enabled" condition.
-  // The strict version of this function requires
-  // the multibit value to equal True.
-  function automatic logic mubi4_test_true_strict(mubi4_t val);
-    return MuBi4True == val;
-  endfunction : mubi4_test_true_strict
-
-  // Test whether the multibit value signals a "disabled" condition.
-  // The strict version of this function requires
-  // the multibit value to equal False.
-  function automatic logic mubi4_test_false_strict(mubi4_t val);
-    return MuBi4False == val;
-  endfunction : mubi4_test_false_strict
-
-  // Test whether the multibit value signals an "enabled" condition.
-  // The loose version of this function interprets all
-  // values other than False as "enabled".
-  function automatic logic mubi4_test_true_loose(mubi4_t val);
-    return MuBi4False != val;
-  endfunction : mubi4_test_true_loose
-
-  // Test whether the multibit value signals a "disabled" condition.
-  // The loose version of this function interprets all
-  // values other than True as "disabled".
-  function automatic logic mubi4_test_false_loose(mubi4_t val);
-    return MuBi4True != val;
-  endfunction : mubi4_test_false_loose
-
-
-  // Performs a logical OR operation between two multibit values.
-  // This treats "act" as logical 1, and all other values are
-  // treated as 0. Truth table:
-  //
-  // A    | B    | OUT
-  //------+------+-----
-  // !act | !act | !act
-  // act  | !act | act
-  // !act | act  | act
-  // act  | act  | act
-  //
-  function automatic mubi4_t mubi4_or(mubi4_t a, mubi4_t b, mubi4_t act);
-    logic [MuBi4Width-1:0] a_in, b_in, act_in, out;
-    a_in = a;
-    b_in = b;
-    act_in = act;
-    for (int k = 0; k < MuBi4Width; k++) begin
-      if (act_in[k]) begin
-        out[k] = a_in[k] || b_in[k];
-      end else begin
-        out[k] = a_in[k] && b_in[k];
-      end
-    end
-    return mubi4_t'(out);
-  endfunction : mubi4_or
-
-  // Performs a logical AND operation between two multibit values.
-  // This treats "act" as logical 1, and all other values are
-  // treated as 0. Truth table:
-  //
-  // A    | B    | OUT
-  //------+------+-----
-  // !act | !act | !act
-  // act  | !act | !act
-  // !act | act  | !act
-  // act  | act  | act
-  //
-  function automatic mubi4_t mubi4_and(mubi4_t a, mubi4_t b, mubi4_t act);
-    logic [MuBi4Width-1:0] a_in, b_in, act_in, out;
-    a_in = a;
-    b_in = b;
-    act_in = act;
-    for (int k = 0; k < MuBi4Width; k++) begin
-      if (act_in[k]) begin
-        out[k] = a_in[k] && b_in[k];
-      end else begin
-        out[k] = a_in[k] || b_in[k];
-      end
-    end
-    return mubi4_t'(out);
-  endfunction : mubi4_and
-
-  // Performs a logical OR operation between two multibit values.
-  // This treats "True" as logical 1, and all other values are
-  // treated as 0.
-  function automatic mubi4_t mubi4_or_hi(mubi4_t a, mubi4_t b);
-    return mubi4_or(a, b, MuBi4True);
-  endfunction : mubi4_or_hi
-
-  // Performs a logical AND operation between two multibit values.
-  // This treats "True" as logical 1, and all other values are
-  // treated as 0.
-  function automatic mubi4_t mubi4_and_hi(mubi4_t a, mubi4_t b);
-    return mubi4_and(a, b, MuBi4True);
-  endfunction : mubi4_and_hi
-
-  // Performs a logical OR operation between two multibit values.
-  // This treats "False" as logical 1, and all other values are
-  // treated as 0.
-  function automatic mubi4_t mubi4_or_lo(mubi4_t a, mubi4_t b);
-    return mubi4_or(a, b, MuBi4False);
-  endfunction : mubi4_or_lo
-
-  // Performs a logical AND operation between two multibit values.
-  // Tlos treats "False" as logical 1, and all other values are
-  // treated as 0.
-  function automatic mubi4_t mubi4_and_lo(mubi4_t a, mubi4_t b);
-    return mubi4_and(a, b, MuBi4False);
-  endfunction : mubi4_and_lo
-
-  //////////////////////////////////////////////
-  // 8 Bit Multibit Type and Functions //
-  //////////////////////////////////////////////
-
-  parameter int MuBi8Width = 8;
-  typedef enum logic [MuBi8Width-1:0] {
-    MuBi8True = 8'h5A, // enabled
-    MuBi8False = 8'hA5  // disabled
-  } mubi8_t;
-
-  // Test whether the value is supplied is one of the valid enumerations
-  function automatic logic mubi8_test_invalid(mubi8_t val);
-    return ~(val inside {MuBi8True, MuBi8False});
-  endfunction : mubi8_test_invalid
-
-  // Convert a 1 input value to a mubi output
-  function automatic mubi8_t mubi8_bool_to_mubi(logic val);
-    return (val ? MuBi8True : MuBi8False);
-  endfunction : mubi8_bool_to_mubi
-
-  // Test whether the multibit value signals an "enabled" condition.
-  // The strict version of this function requires
-  // the multibit value to equal True.
-  function automatic logic mubi8_test_true_strict(mubi8_t val);
-    return MuBi8True == val;
-  endfunction : mubi8_test_true_strict
-
-  // Test whether the multibit value signals a "disabled" condition.
-  // The strict version of this function requires
-  // the multibit value to equal False.
-  function automatic logic mubi8_test_false_strict(mubi8_t val);
-    return MuBi8False == val;
-  endfunction : mubi8_test_false_strict
-
-  // Test whether the multibit value signals an "enabled" condition.
-  // The loose version of this function interprets all
-  // values other than False as "enabled".
-  function automatic logic mubi8_test_true_loose(mubi8_t val);
-    return MuBi8False != val;
-  endfunction : mubi8_test_true_loose
-
-  // Test whether the multibit value signals a "disabled" condition.
-  // The loose version of this function interprets all
-  // values other than True as "disabled".
-  function automatic logic mubi8_test_false_loose(mubi8_t val);
-    return MuBi8True != val;
-  endfunction : mubi8_test_false_loose
-
-
-  // Performs a logical OR operation between two multibit values.
-  // This treats "act" as logical 1, and all other values are
-  // treated as 0. Truth table:
-  //
-  // A    | B    | OUT
-  //------+------+-----
-  // !act | !act | !act
-  // act  | !act | act
-  // !act | act  | act
-  // act  | act  | act
-  //
-  function automatic mubi8_t mubi8_or(mubi8_t a, mubi8_t b, mubi8_t act);
-    logic [MuBi8Width-1:0] a_in, b_in, act_in, out;
-    a_in = a;
-    b_in = b;
-    act_in = act;
-    for (int k = 0; k < MuBi8Width; k++) begin
-      if (act_in[k]) begin
-        out[k] = a_in[k] || b_in[k];
-      end else begin
-        out[k] = a_in[k] && b_in[k];
-      end
-    end
-    return mubi8_t'(out);
-  endfunction : mubi8_or
-
-  // Performs a logical AND operation between two multibit values.
-  // This treats "act" as logical 1, and all other values are
-  // treated as 0. Truth table:
-  //
-  // A    | B    | OUT
-  //------+------+-----
-  // !act | !act | !act
-  // act  | !act | !act
-  // !act | act  | !act
-  // act  | act  | act
-  //
-  function automatic mubi8_t mubi8_and(mubi8_t a, mubi8_t b, mubi8_t act);
-    logic [MuBi8Width-1:0] a_in, b_in, act_in, out;
-    a_in = a;
-    b_in = b;
-    act_in = act;
-    for (int k = 0; k < MuBi8Width; k++) begin
-      if (act_in[k]) begin
-        out[k] = a_in[k] && b_in[k];
-      end else begin
-        out[k] = a_in[k] || b_in[k];
-      end
-    end
-    return mubi8_t'(out);
-  endfunction : mubi8_and
-
-  // Performs a logical OR operation between two multibit values.
-  // This treats "True" as logical 1, and all other values are
-  // treated as 0.
-  function automatic mubi8_t mubi8_or_hi(mubi8_t a, mubi8_t b);
-    return mubi8_or(a, b, MuBi8True);
-  endfunction : mubi8_or_hi
-
-  // Performs a logical AND operation between two multibit values.
-  // This treats "True" as logical 1, and all other values are
-  // treated as 0.
-  function automatic mubi8_t mubi8_and_hi(mubi8_t a, mubi8_t b);
-    return mubi8_and(a, b, MuBi8True);
-  endfunction : mubi8_and_hi
-
-  // Performs a logical OR operation between two multibit values.
-  // This treats "False" as logical 1, and all other values are
-  // treated as 0.
-  function automatic mubi8_t mubi8_or_lo(mubi8_t a, mubi8_t b);
-    return mubi8_or(a, b, MuBi8False);
-  endfunction : mubi8_or_lo
-
-  // Performs a logical AND operation between two multibit values.
-  // Tlos treats "False" as logical 1, and all other values are
-  // treated as 0.
-  function automatic mubi8_t mubi8_and_lo(mubi8_t a, mubi8_t b);
-    return mubi8_and(a, b, MuBi8False);
-  endfunction : mubi8_and_lo
-
-  //////////////////////////////////////////////
-  // 12 Bit Multibit Type and Functions //
-  //////////////////////////////////////////////
-
-  parameter int MuBi12Width = 12;
-  typedef enum logic [MuBi12Width-1:0] {
-    MuBi12True = 12'hA5A, // enabled
-    MuBi12False = 12'h5A5  // disabled
-  } mubi12_t;
-
-  // Test whether the value is supplied is one of the valid enumerations
-  function automatic logic mubi12_test_invalid(mubi12_t val);
-    return ~(val inside {MuBi12True, MuBi12False});
-  endfunction : mubi12_test_invalid
-
-  // Convert a 1 input value to a mubi output
-  function automatic mubi12_t mubi12_bool_to_mubi(logic val);
-    return (val ? MuBi12True : MuBi12False);
-  endfunction : mubi12_bool_to_mubi
-
-  // Test whether the multibit value signals an "enabled" condition.
-  // The strict version of this function requires
-  // the multibit value to equal True.
-  function automatic logic mubi12_test_true_strict(mubi12_t val);
-    return MuBi12True == val;
-  endfunction : mubi12_test_true_strict
-
-  // Test whether the multibit value signals a "disabled" condition.
-  // The strict version of this function requires
-  // the multibit value to equal False.
-  function automatic logic mubi12_test_false_strict(mubi12_t val);
-    return MuBi12False == val;
-  endfunction : mubi12_test_false_strict
-
-  // Test whether the multibit value signals an "enabled" condition.
-  // The loose version of this function interprets all
-  // values other than False as "enabled".
-  function automatic logic mubi12_test_true_loose(mubi12_t val);
-    return MuBi12False != val;
-  endfunction : mubi12_test_true_loose
-
-  // Test whether the multibit value signals a "disabled" condition.
-  // The loose version of this function interprets all
-  // values other than True as "disabled".
-  function automatic logic mubi12_test_false_loose(mubi12_t val);
-    return MuBi12True != val;
-  endfunction : mubi12_test_false_loose
-
-
-  // Performs a logical OR operation between two multibit values.
-  // This treats "act" as logical 1, and all other values are
-  // treated as 0. Truth table:
-  //
-  // A    | B    | OUT
-  //------+------+-----
-  // !act | !act | !act
-  // act  | !act | act
-  // !act | act  | act
-  // act  | act  | act
-  //
-  function automatic mubi12_t mubi12_or(mubi12_t a, mubi12_t b, mubi12_t act);
-    logic [MuBi12Width-1:0] a_in, b_in, act_in, out;
-    a_in = a;
-    b_in = b;
-    act_in = act;
-    for (int k = 0; k < MuBi12Width; k++) begin
-      if (act_in[k]) begin
-        out[k] = a_in[k] || b_in[k];
-      end else begin
-        out[k] = a_in[k] && b_in[k];
-      end
-    end
-    return mubi12_t'(out);
-  endfunction : mubi12_or
-
-  // Performs a logical AND operation between two multibit values.
-  // This treats "act" as logical 1, and all other values are
-  // treated as 0. Truth table:
-  //
-  // A    | B    | OUT
-  //------+------+-----
-  // !act | !act | !act
-  // act  | !act | !act
-  // !act | act  | !act
-  // act  | act  | act
-  //
-  function automatic mubi12_t mubi12_and(mubi12_t a, mubi12_t b, mubi12_t act);
-    logic [MuBi12Width-1:0] a_in, b_in, act_in, out;
-    a_in = a;
-    b_in = b;
-    act_in = act;
-    for (int k = 0; k < MuBi12Width; k++) begin
-      if (act_in[k]) begin
-        out[k] = a_in[k] && b_in[k];
-      end else begin
-        out[k] = a_in[k] || b_in[k];
-      end
-    end
-    return mubi12_t'(out);
-  endfunction : mubi12_and
-
-  // Performs a logical OR operation between two multibit values.
-  // This treats "True" as logical 1, and all other values are
-  // treated as 0.
-  function automatic mubi12_t mubi12_or_hi(mubi12_t a, mubi12_t b);
-    return mubi12_or(a, b, MuBi12True);
-  endfunction : mubi12_or_hi
-
-  // Performs a logical AND operation between two multibit values.
-  // This treats "True" as logical 1, and all other values are
-  // treated as 0.
-  function automatic mubi12_t mubi12_and_hi(mubi12_t a, mubi12_t b);
-    return mubi12_and(a, b, MuBi12True);
-  endfunction : mubi12_and_hi
-
-  // Performs a logical OR operation between two multibit values.
-  // This treats "False" as logical 1, and all other values are
-  // treated as 0.
-  function automatic mubi12_t mubi12_or_lo(mubi12_t a, mubi12_t b);
-    return mubi12_or(a, b, MuBi12False);
-  endfunction : mubi12_or_lo
-
-  // Performs a logical AND operation between two multibit values.
-  // Tlos treats "False" as logical 1, and all other values are
-  // treated as 0.
-  function automatic mubi12_t mubi12_and_lo(mubi12_t a, mubi12_t b);
-    return mubi12_and(a, b, MuBi12False);
-  endfunction : mubi12_and_lo
-
-  //////////////////////////////////////////////
-  // 16 Bit Multibit Type and Functions //
-  //////////////////////////////////////////////
-
-  parameter int MuBi16Width = 16;
-  typedef enum logic [MuBi16Width-1:0] {
-    MuBi16True = 16'h5A5A, // enabled
-    MuBi16False = 16'hA5A5  // disabled
-  } mubi16_t;
-
-  // Test whether the value is supplied is one of the valid enumerations
-  function automatic logic mubi16_test_invalid(mubi16_t val);
-    return ~(val inside {MuBi16True, MuBi16False});
-  endfunction : mubi16_test_invalid
-
-  // Convert a 1 input value to a mubi output
-  function automatic mubi16_t mubi16_bool_to_mubi(logic val);
-    return (val ? MuBi16True : MuBi16False);
-  endfunction : mubi16_bool_to_mubi
-
-  // Test whether the multibit value signals an "enabled" condition.
-  // The strict version of this function requires
-  // the multibit value to equal True.
-  function automatic logic mubi16_test_true_strict(mubi16_t val);
-    return MuBi16True == val;
-  endfunction : mubi16_test_true_strict
-
-  // Test whether the multibit value signals a "disabled" condition.
-  // The strict version of this function requires
-  // the multibit value to equal False.
-  function automatic logic mubi16_test_false_strict(mubi16_t val);
-    return MuBi16False == val;
-  endfunction : mubi16_test_false_strict
-
-  // Test whether the multibit value signals an "enabled" condition.
-  // The loose version of this function interprets all
-  // values other than False as "enabled".
-  function automatic logic mubi16_test_true_loose(mubi16_t val);
-    return MuBi16False != val;
-  endfunction : mubi16_test_true_loose
-
-  // Test whether the multibit value signals a "disabled" condition.
-  // The loose version of this function interprets all
-  // values other than True as "disabled".
-  function automatic logic mubi16_test_false_loose(mubi16_t val);
-    return MuBi16True != val;
-  endfunction : mubi16_test_false_loose
-
-
-  // Performs a logical OR operation between two multibit values.
-  // This treats "act" as logical 1, and all other values are
-  // treated as 0. Truth table:
-  //
-  // A    | B    | OUT
-  //------+------+-----
-  // !act | !act | !act
-  // act  | !act | act
-  // !act | act  | act
-  // act  | act  | act
-  //
-  function automatic mubi16_t mubi16_or(mubi16_t a, mubi16_t b, mubi16_t act);
-    logic [MuBi16Width-1:0] a_in, b_in, act_in, out;
-    a_in = a;
-    b_in = b;
-    act_in = act;
-    for (int k = 0; k < MuBi16Width; k++) begin
-      if (act_in[k]) begin
-        out[k] = a_in[k] || b_in[k];
-      end else begin
-        out[k] = a_in[k] && b_in[k];
-      end
-    end
-    return mubi16_t'(out);
-  endfunction : mubi16_or
-
-  // Performs a logical AND operation between two multibit values.
-  // This treats "act" as logical 1, and all other values are
-  // treated as 0. Truth table:
-  //
-  // A    | B    | OUT
-  //------+------+-----
-  // !act | !act | !act
-  // act  | !act | !act
-  // !act | act  | !act
-  // act  | act  | act
-  //
-  function automatic mubi16_t mubi16_and(mubi16_t a, mubi16_t b, mubi16_t act);
-    logic [MuBi16Width-1:0] a_in, b_in, act_in, out;
-    a_in = a;
-    b_in = b;
-    act_in = act;
-    for (int k = 0; k < MuBi16Width; k++) begin
-      if (act_in[k]) begin
-        out[k] = a_in[k] && b_in[k];
-      end else begin
-        out[k] = a_in[k] || b_in[k];
-      end
-    end
-    return mubi16_t'(out);
-  endfunction : mubi16_and
-
-  // Performs a logical OR operation between two multibit values.
-  // This treats "True" as logical 1, and all other values are
-  // treated as 0.
-  function automatic mubi16_t mubi16_or_hi(mubi16_t a, mubi16_t b);
-    return mubi16_or(a, b, MuBi16True);
-  endfunction : mubi16_or_hi
-
-  // Performs a logical AND operation between two multibit values.
-  // This treats "True" as logical 1, and all other values are
-  // treated as 0.
-  function automatic mubi16_t mubi16_and_hi(mubi16_t a, mubi16_t b);
-    return mubi16_and(a, b, MuBi16True);
-  endfunction : mubi16_and_hi
-
-  // Performs a logical OR operation between two multibit values.
-  // This treats "False" as logical 1, and all other values are
-  // treated as 0.
-  function automatic mubi16_t mubi16_or_lo(mubi16_t a, mubi16_t b);
-    return mubi16_or(a, b, MuBi16False);
-  endfunction : mubi16_or_lo
-
-  // Performs a logical AND operation between two multibit values.
-  // Tlos treats "False" as logical 1, and all other values are
-  // treated as 0.
-  function automatic mubi16_t mubi16_and_lo(mubi16_t a, mubi16_t b);
-    return mubi16_and(a, b, MuBi16False);
-  endfunction : mubi16_and_lo
-
-endpackage : prim_mubi_pkg
diff --git a/prim_multibit_sync.sv b/prim_multibit_sync.sv
deleted file mode 100644
index 79a3ab6d..00000000
--- a/prim_multibit_sync.sv
+++ /dev/null
@@ -1,103 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// WARNING: DO NOT USE THIS MODULE IF YOU DO NOT HAVE A GOOD REASON TO DO SO.
-//
-// This module is only meant to be used in special cases where a handshake synchronizer
-// is not viable (this is for instance the case for the multibit life cycle signals).
-// For handshake-based synchronization, consider using prim_sync_reqack_data.
-//
-//
-// Description:
-//
-// This module implements a multibit synchronizer that employs a data consistency check to
-// decide whether the synchronized multibit signal is stable and can be output or not.
-//
-// The number of consistency checkers can be controlled via NumChecks. Each check adds another
-// delay register after the 2-flop synchronizer, and corresponding comparator that checks whether
-// the register input is equal to the output of the last register in the chain. If all checks are
-// successful, the output register is enabled such that the data can propagate to the output.
-//
-// This is illustrated bellow for NumChecks = 1:
-//
-//                  /--------\        /--------\        /--------\
-//                  |        |        |        |        |        |
-//    data_i --/--> |  flop  | --x--> |  flop  | --x--> |  flop  | --/--> data_o
-//           Width  | 2 sync |   |    |        |   |    |        |
-//                  |        |   |    |        |   |    |   en   |
-//                  \--------/   |    \--------/   |    \--------/
-//                               |                 v        ^
-//                               |               /----\     |
-//                               \-------------> | == | ----/
-//                                               \----/
-//
-// Note: CDC tools will likely flag this module due to re-convergent logic.
-//
-
-`include "prim_assert.sv"
-
-module prim_multibit_sync #(
-  // Width of the multibit signal.
-  parameter int               Width = 8,
-  // Number of cycles the synchronized multi-bit signal needs to
-  // be stable until it is relased to the output. Each check adds
-  // a comparator and an additional delay register.
-  parameter int               NumChecks = 1,
-  // Reset value of the multibit signal.
-  parameter logic [Width-1:0] ResetValue = '0
-) (
-  input clk_i,
-  input rst_ni,
-  input  logic [Width-1:0] data_i,
-  output logic [Width-1:0] data_o
-);
-
-  `ASSERT_INIT(NumChecks_A, NumChecks >= 1)
-
-  // First, synchronize the input data to this clock domain.
-  logic [NumChecks:0][Width-1:0]   data_check_d;
-  logic [NumChecks-1:0][Width-1:0] data_check_q;
-
-  prim_flop_2sync #(
-    .Width(Width),
-    .ResetValue(ResetValue)
-  ) i_prim_flop_2sync (
-    .clk_i,
-    .rst_ni,
-    .d_i(data_i),
-    .q_o(data_check_d[0])
-  );
-
-  // Shift register.
-  assign data_check_d[NumChecks:1] = data_check_q[NumChecks-1:0];
-
-  // Consistency check. Always compare to the output of the last register.
-  logic [NumChecks-1:0] checks;
-  for (genvar k = 0; k < NumChecks; k++) begin : gen_checks
-    assign checks[k] = (data_check_d[k] == data_check_d[NumChecks]);
-    // Output is only allowed to change when all checks have passed.
-    `ASSERT(StableCheck_A,
-          data_o != $past(data_o)
-          |->
-          $past(data_check_d[k]) == $past(data_check_d[NumChecks]))
-  end : gen_checks
-
-  // Only propagate to output register if all checks have passed.
-  logic [Width-1:0] data_synced_d, data_synced_q;
-  assign data_synced_d = (&checks) ? data_check_d[NumChecks] : data_synced_q;
-  assign data_o = data_synced_q;
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
-    if (!rst_ni) begin
-      data_synced_q <= ResetValue;
-      data_check_q  <= {NumChecks{ResetValue}};
-    end else begin
-      data_synced_q <= data_synced_d;
-      data_check_q  <= data_check_d[NumChecks-1:0];
-    end
-  end
-
-  `ASSERT_KNOWN(DataKnown_A, data_o)
-
-endmodule : prim_multibit_sync
diff --git a/prim_otp_pkg.sv b/prim_otp_pkg.sv
deleted file mode 100644
index 0b7ffc91..00000000
--- a/prim_otp_pkg.sv
+++ /dev/null
@@ -1,26 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-
-// Common interface definitions for OTP primitives.
-
-package prim_otp_pkg;
-
-  parameter int CmdWidth = 2;
-  parameter int ErrWidth = 3;
-
-  typedef enum logic [CmdWidth-1:0] {
-    Read  = 2'b00,
-    Write = 2'b01,
-    Init  = 2'b11
-  } cmd_e;
-
-  typedef enum logic [ErrWidth-1:0] {
-    NoError              = 3'h0,
-    MacroError           = 3'h1,
-    MacroEccCorrError    = 3'h2,
-    MacroEccUncorrError  = 3'h3,
-    MacroWriteBlankError = 3'h4
-  } err_e;
-
-endpackage : prim_otp_pkg
diff --git a/prim_packer.sv b/prim_packer.sv
deleted file mode 100644
index c278a39e..00000000
--- a/prim_packer.sv
+++ /dev/null
@@ -1,297 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Combine InW data and write to OutW data if packed to full word or stop signal
-
-`include "prim_assert.sv"
-
-module prim_packer #(
-  parameter int InW  = 32,
-  parameter int OutW = 32,
-  parameter int HintByteData = 0 // If 1, The input/output are byte granularity
-) (
-  input clk_i ,
-  input rst_ni,
-
-  input                   valid_i,
-  input        [InW-1:0]  data_i,
-  input        [InW-1:0]  mask_i,
-  output                  ready_o,
-
-  output logic            valid_o,
-  output logic [OutW-1:0] data_o,
-  output logic [OutW-1:0] mask_o,
-  input                   ready_i,
-
-  input                   flush_i,  // If 1, send out remnant and clear state
-  output logic            flush_done_o
-);
-
-  localparam int Width = InW + OutW; // storage width
-  localparam int ConcatW = Width + InW; // Input concatenated width
-  localparam int PtrW = $clog2(ConcatW+1);
-  localparam int IdxW = prim_util_pkg::vbits(InW);
-
-  logic valid_next, ready_next;
-  logic [Width-1:0]   stored_data, stored_mask;
-  logic [ConcatW-1:0] concat_data, concat_mask;
-  logic [ConcatW-1:0] shiftl_data, shiftl_mask;
-
-  logic [PtrW-1:0]          pos, pos_next; // Current write position
-  logic [IdxW-1:0]          lod_idx;       // result of Leading One Detector
-  logic [$clog2(InW+1)-1:0] inmask_ones;   // Counting Ones for mask_i
-
-  logic ack_in, ack_out;
-
-  logic flush_valid; // flush data out request
-  logic flush_done;
-
-  // Computing next position ==================================================
-  always_comb begin
-    // counting mask_i ones
-    inmask_ones = '0;
-    for (int i = 0 ; i < InW ; i++) begin
-      inmask_ones = inmask_ones + mask_i[i];
-    end
-  end
-
-  logic [PtrW-1:0] pos_with_input;
-
-  always_comb begin
-    pos_next = pos;
-    pos_with_input = pos + PtrW'(inmask_ones);
-
-    unique case ({ack_in, ack_out})
-      2'b00: pos_next = pos;
-      2'b01: pos_next = (pos <= OutW) ? '0 : pos - OutW;
-      2'b10: pos_next = pos_with_input;
-      2'b11: pos_next = (pos_with_input <= OutW) ? '0 : pos_with_input - OutW;
-      default: pos_next = pos;
-    endcase
-  end
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      pos <= '0;
-    end else if (flush_done) begin
-      pos <= '0;
-    end else begin
-      pos <= pos_next;
-    end
-  end
-  //---------------------------------------------------------------------------
-
-  // Leading one detector for mask_i
-  always_comb begin
-    lod_idx = 0;
-    for (int i = InW-1; i >= 0 ; i--) begin
-      if (mask_i[i] == 1'b1) begin
-        lod_idx = $unsigned(i);
-      end
-    end
-  end
-
-  assign ack_in  = valid_i & ready_o;
-  assign ack_out = valid_o & ready_i;
-
-  // Data process =============================================================
-  //  shiftl : Input data shifted into the current stored position
-  assign shiftl_data = (valid_i) ? Width'(data_i >> lod_idx) << pos : '0;
-  assign shiftl_mask = (valid_i) ? Width'(mask_i >> lod_idx) << pos : '0;
-
-  // concat : Merging stored and shiftl
-  assign concat_data = {{(InW){1'b0}}, stored_data & stored_mask} |
-                       (shiftl_data & shiftl_mask);
-  assign concat_mask = {{(InW){1'b0}}, stored_mask} | shiftl_mask;
-
-  logic [Width-1:0] stored_data_next, stored_mask_next;
-
-  always_comb begin
-    unique case ({ack_in, ack_out})
-      2'b 00: begin
-        stored_data_next = stored_data;
-        stored_mask_next = stored_mask;
-      end
-      2'b 01: begin
-        // ack_out : shift the amount of OutW
-        stored_data_next = {{OutW{1'b0}}, stored_data[Width-1:OutW]};
-        stored_mask_next = {{OutW{1'b0}}, stored_mask[Width-1:OutW]};
-      end
-      2'b 10: begin
-        // ack_in : Store concat data
-        stored_data_next = concat_data[0+:Width];
-        stored_mask_next = concat_mask[0+:Width];
-      end
-      2'b 11: begin
-        // both : shift the concat_data
-        stored_data_next = concat_data[ConcatW-1:OutW];
-        stored_mask_next = concat_mask[ConcatW-1:OutW];
-      end
-      default: begin
-        stored_data_next = stored_data;
-        stored_mask_next = stored_mask;
-      end
-    endcase
-  end
-
-  // Store the data temporary if it doesn't exceed OutW
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      stored_data <= '0;
-      stored_mask <= '0;
-    end else if (flush_done) begin
-      stored_data <= '0;
-      stored_mask <= '0;
-    end else begin
-      stored_data <= stored_data_next;
-      stored_mask <= stored_mask_next;
-    end
-  end
-  //---------------------------------------------------------------------------
-
-  // flush handling
-  typedef enum logic {
-    FlushIdle,
-    FlushSend
-  } flush_st_e;
-  flush_st_e flush_st, flush_st_next;
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      flush_st <= FlushIdle;
-    end else begin
-      flush_st <= flush_st_next;
-    end
-  end
-
-  always_comb begin
-    flush_st_next = FlushIdle;
-
-    flush_valid = 1'b0;
-    flush_done  = 1'b0;
-
-    unique case (flush_st)
-      FlushIdle: begin
-        if (flush_i) begin
-          flush_st_next = FlushSend;
-        end else begin
-          flush_st_next = FlushIdle;
-        end
-      end
-
-      FlushSend: begin
-        if (pos == '0) begin
-          flush_st_next = FlushIdle;
-
-          flush_valid = 1'b 0;
-          flush_done  = 1'b 1;
-        end else begin
-          flush_st_next = FlushSend;
-
-          flush_valid = 1'b 1;
-          flush_done  = 1'b 0;
-        end
-      end
-      default: begin
-        flush_st_next = FlushIdle;
-
-        flush_valid = 1'b 0;
-        flush_done  = 1'b 0;
-      end
-    endcase
-  end
-
-  assign flush_done_o = flush_done;
-
-
-  // Output signals ===========================================================
-  assign valid_next = (pos >= OutW) ? 1'b 1 : flush_valid;
-
-  // storage space is InW + OutW. So technically, ready_o can be asserted even
-  // if `pos` is greater than OutW. But in order to do that, the logic should
-  // use `inmask_ones` value whether pos+inmask_ones is less than (InW+OutW)
-  // with `valid_i`. It creates a path from `valid_i` --> `ready_o`.
-  // It may create a timing loop in some modules that use `ready_o` to
-  // `valid_i` (which is not a good practice though)
-  assign ready_next = pos <= OutW;
-
-  // Output request
-  assign valid_o = valid_next;
-  assign data_o  = stored_data[OutW-1:0];
-  assign mask_o  = stored_mask[OutW-1:0];
-
-  // ready_o
-  assign ready_o = ready_next;
-  //---------------------------------------------------------------------------
-
-  //////////////////////////////////////////////
-  // Assertions, Assumptions, and Coverpoints //
-  //////////////////////////////////////////////
-  // Assumption: mask_i should be contiguous ones
-  // e.g: 0011100 --> OK
-  //      0100011 --> Not OK
-  if (InW > 1) begin : gen_mask_assert
-    `ASSUME(ContiguousOnesMask_M,
-            valid_i |-> $countones(mask_i ^ {mask_i[InW-2:0],1'b0}) <= 2)
-  end
-
-  // Flush and Write Enable cannot be asserted same time
-  `ASSUME(ExFlushValid_M, flush_i |-> !valid_i)
-
-  // While in flush state, new request shouldn't come
-  `ASSUME(ValidIDeassertedOnFlush_M,
-          flush_st == FlushSend |-> $stable(valid_i))
-
-  // If not acked, input port keeps asserting valid and data
-  `ASSUME(DataIStable_M,
-          ##1 valid_i && $past(valid_i) && !$past(ready_o)
-          |-> $stable(data_i) && $stable(mask_i))
-
-  `ASSERT(FlushFollowedByDone_A,
-          ##1 $rose(flush_i) && !flush_done_o |-> !flush_done_o [*0:$] ##1 flush_done_o)
-
-  // If not acked, valid_o should keep asserting
-  `ASSERT(ValidOPairedWidthReadyI_A,
-          valid_o && !ready_i |=> valid_o)
-
-  // If stored data is greater than the output width, valid should be asserted
-  `ASSERT(ValidOAssertedForStoredDataGTEOutW_A,
-          ($countones(stored_mask) >= OutW) |-> valid_o)
-
-  // If output port doesn't accept the data, the data should be stable
-  `ASSERT(DataOStableWhenPending_A,
-          ##1 valid_o && $past(valid_o)
-          && !$past(ready_i) |-> $stable(data_o))
-
-  // If input data & stored data are greater than OutW, remained should be stored
-  `ASSERT(ExcessiveDataStored_A,
-          ack_in && ack_out && (($countones(mask_i) + $countones(stored_mask)) > OutW)
-          |=> (($past(data_i) &  $past(mask_i)) >>
-               ($past(lod_idx)+OutW-$countones($past(stored_mask))))
-               == stored_data)
-
-  `ASSERT(ExcessiveMaskStored_A,
-          ack_in && ack_out && (($countones(mask_i) + $countones(stored_mask)) > OutW)
-          |=> ($past(mask_i) >>
-               ($past(lod_idx)+OutW-$countones($past(stored_mask))))
-              == stored_mask)
-
-  // Assertions for byte hint enabled
-  if (HintByteData != 0) begin : g_byte_assert
-    `ASSERT_INIT(InputDividedBy8_A,  InW  % 8 == 0)
-    `ASSERT_INIT(OutputDividedBy8_A, OutW % 8 == 0)
-
-    // Masking[8*i+:8] should be all zero or all one
-    for (genvar i = 0 ; i < InW/8 ; i++) begin : g_byte_input_masking
-      `ASSERT(InputMaskContiguous_A,
-              valid_i |-> (|mask_i[8*i+:8] == 1'b 0)
-                       || (&mask_i[8*i+:8] == 1'b 1))
-    end
-    for (genvar i = 0 ; i < OutW/8 ; i++) begin : g_byte_output_masking
-      `ASSERT(OutputMaskContiguous_A,
-              valid_o |-> (|mask_o[8*i+:8] == 1'b 0)
-                       || (&mask_o[8*i+:8] == 1'b 1))
-    end
-  end
-endmodule
diff --git a/prim_packer_fifo.sv b/prim_packer_fifo.sv
deleted file mode 100644
index 95c143da..00000000
--- a/prim_packer_fifo.sv
+++ /dev/null
@@ -1,180 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Supports packed and unpacked modes
-// Uses FIFO timing on the control signals
-// No masking or flush functions supported
-
-// Timings - case where InW < OutW
-// clk_i      __|~~|__~~|__|~~|__~~|__|~~|__~~|__|~~|__~~|__|~~|__~~|__|~~|__
-// wvalid_i   _____|~~~~|_____|~~~~|_____|~~~~|_____|~~~~|___________________
-// wdata_i    Val N     |Val N+1   |Val N+2   |Val N+3   |-------------------
-// wready_o   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|__________|~~~~~~~~
-// rvalid_o   ___________________________________________|~~~~~~~~~~|________
-// rdata_o    -------------------------------------------|Val       |--------
-// rready_i   _________________________________________________|~~~~|________
-// depth_o    0000000000|1111111111|2222222222|3333333333|4444444444|00000000
-
-
-// Timings - case where InW > OutW
-// clk_i      __|~~|__~~|__|~~|__~~|__|~~|__~~|__|~~|__~~|__|~~|__~~|__|~~|__
-// wvalid_i   _____|~~~~|____________________________________________________
-// wdata_i    -----|Val |----------------------------------------------------
-// wready_o   ~~~~~~~~~~|___________________________________________|~~~~~~~~
-// rvalid_o   __________|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|________
-// rdata_o    ----------|Val N     |Val N+1   |Val N+2   |Val N+3   |--------
-// rready_i   ________________|~~~~|_____|~~~~|_____|~~~~|_____|~~~~|________
-// depth_o    0000000000|4444444444|3333333333|2222222222|1111111111|00000000
-
-
-// Timings - case where InW = OutW
-// clk_i      __|~~|__~~|__|~~|__~~|__|~~|__~~|__|~~|__~~|__|~~|__~~|__|~~|__
-// wvalid_i   _____|~~~~|____________________________________________________
-// wdata_i    -----|Val |----------------------------------------------------
-// wready_o   ~~~~~~~~~~|__________|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-// rvalid_o   __________|~~~~~~~~~~|_________________________________________
-// rdata_o    ----------|Val       |-----------------------------------------
-// rready_i   ________________|~~~~|_________________________________________
-// depth_o    0000000000|1111111111|00000000000000000000000000000000000000000
-
-
-`include "prim_assert.sv"
-
-module prim_packer_fifo #(
-  parameter int InW  = 32,
-  parameter int OutW = 8,
-  parameter bit ClearOnRead = 1'b1, // if == 1 always output 0 after read
-  // derived parameters
-  localparam int MaxW = (InW > OutW) ? InW : OutW,
-  localparam int MinW = (InW < OutW) ? InW : OutW,
-  localparam int DepthW = $clog2(MaxW/MinW)
-) (
-  input logic clk_i ,
-  input logic rst_ni,
-
-  input logic               clr_i,
-  input logic               wvalid_i,
-  input logic  [InW-1:0]    wdata_i,
-  output logic              wready_o,
-
-  output logic              rvalid_o,
-  output logic [OutW-1:0]   rdata_o,
-  input logic               rready_i,
-  output logic [DepthW:0]   depth_o
-);
-
-  localparam int unsigned   WidthRatio = MaxW / MinW;
-  localparam bit [DepthW:0] FullDepth = WidthRatio[DepthW:0];
-
-  // signals
-  logic  load_data;
-  logic  clear_data;
-  logic  clear_status;
-
-  // flops
-  logic [DepthW:0] depth_q, depth_d;
-  logic [MaxW-1:0] data_q, data_d;
-  logic            clr_q, clr_d;
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      depth_q <= '0;
-      data_q  <= '0;
-      clr_q   <= 1'b1;
-    end else begin
-      depth_q <= depth_d;
-      data_q  <= data_d;
-      clr_q   <= clr_d;
-    end
-  end
-
-  // flop for handling reset case for clr
-  assign clr_d = clr_i;
-
-  assign depth_o = depth_q;
-
-  if (InW < OutW) begin : gen_pack_mode
-    logic [MaxW-1:0] wdata_shifted;
-
-    assign wdata_shifted = {{OutW - InW{1'b0}}, wdata_i} << (depth_q*InW);
-    assign clear_status = (rready_i && rvalid_o) || clr_q;
-    assign clear_data = (ClearOnRead && clear_status) || clr_q;
-    assign load_data = wvalid_i && wready_o;
-
-    assign depth_d =  clear_status ? '0 :
-           load_data ? depth_q+1 :
-           depth_q;
-
-    assign data_d = clear_data ? '0 :
-           load_data ? (wdata_shifted | (depth_q == 0 ? '0 : data_q)) :
-           data_q;
-
-    // set outputs
-    assign wready_o = !(depth_q == FullDepth) && !clr_q;
-    assign rdata_o =  data_q;
-    assign rvalid_o = (depth_q == FullDepth) && !clr_q;
-
-  end else begin : gen_unpack_mode
-    logic [MaxW-1:0] rdata_shifted;
-    logic            pull_data;
-    logic [DepthW:0] ptr_q, ptr_d;
-    logic [DepthW:0] lsb_is_one;
-    logic [DepthW:0] max_value;
-
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-        ptr_q   <= '0;
-      end else begin
-        ptr_q   <= ptr_d;
-      end
-    end
-
-    assign lsb_is_one = {{DepthW{1'b0}},1'b1};
-    assign max_value = FullDepth;
-    assign rdata_shifted = data_q >> ptr_q*OutW;
-    assign clear_status = (rready_i && (depth_q == lsb_is_one)) || clr_q;
-    assign clear_data = (ClearOnRead && clear_status) || clr_q;
-    assign load_data = wvalid_i && wready_o;
-    assign pull_data = rvalid_o && rready_i;
-
-    assign depth_d =  clear_status ? '0 :
-           load_data ? max_value :
-           pull_data ? depth_q-1 :
-           depth_q;
-
-    assign ptr_d =  clear_status ? '0 :
-           pull_data ? ptr_q+1 :
-           ptr_q;
-
-    assign data_d = clear_data ? '0 :
-           load_data ? wdata_i :
-           data_q;
-
-    // set outputs
-    assign wready_o = (depth_q == '0) && !clr_q;
-    assign rdata_o =  rdata_shifted[OutW-1:0];
-    assign rvalid_o = !(depth_q == '0) && !clr_q;
-
-    // Avoid possible lint errors in case InW > OutW.
-    if (InW > OutW) begin : gen_unused
-      logic [MaxW-MinW-1:0] unused_rdata_shifted;
-      assign unused_rdata_shifted = rdata_shifted[MaxW-1:MinW];
-    end
-  end
-
-
-  //////////////////////////////////////////////
-  // Assertions, Assumptions, and Coverpoints //
-  //////////////////////////////////////////////
-
-  // If not acked, valid_o should keep asserting
-  `ASSERT(ValidOPairedWithReadyI_A,
-          rvalid_o && !rready_i && !clr_i |=> rvalid_o)
-
-  // If output port doesn't accept the data, the data should be stable
-  `ASSERT(DataOStableWhenPending_A,
-          ##1 rvalid_o && $past(rvalid_o)
-          && !$past(rready_i) && !$past(clr_i) |-> $stable(rdata_o))
-
-endmodule
diff --git a/prim_pad_wrapper_pkg.sv b/prim_pad_wrapper_pkg.sv
deleted file mode 100644
index 05acab6a..00000000
--- a/prim_pad_wrapper_pkg.sv
+++ /dev/null
@@ -1,46 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-
-package prim_pad_wrapper_pkg;
-
-  typedef enum logic [2:0] {
-    BidirStd = 3'h0,     // Standard bidirectional pad
-    BidirTol = 3'h1,     // Voltage tolerant pad
-    BidirOd = 3'h2,      // Open-drain capable pad
-    InputStd = 3'h3,     // Input-only pad
-    AnalogIn0 = 3'h4,    // Analog input pad
-    AnalogIn1 = 3'h5,    // Analog input pad
-    DualBidirTol = 3'h6  // Dual Voltage tolerant pad
-  } pad_type_e;
-
-  typedef enum logic [1:0] {
-    NoScan = 2'h0,
-    ScanIn = 2'h1,
-    ScanOut = 2'h2
-  } scan_role_e;
-
-  // Pad attributes
-  parameter int DriveStrDw = 4;
-  parameter int SlewRateDw = 2;
-
-  typedef struct packed {
-    logic [DriveStrDw-1:0] drive_strength; // Drive strength (0000: weakest, 1111: strongest).
-    logic [SlewRateDw-1:0] slew_rate;      // Slew rate (0: slowest, 11: fastest).
-    logic od_en;                           // Open-drain enable
-    logic schmitt_en;                      // Schmitt trigger enable.
-    logic keep_en;                         // Keeper enable.
-    logic pull_select;                     // Pull direction (0: pull down, 1: pull up).
-    logic pull_en;                         // Pull enable.
-    logic virt_od_en;                      // Virtual open drain enable.
-    logic invert;                          // Input/output inversion.
-  } pad_attr_t;
-
-  parameter int AttrDw = $bits(pad_attr_t);
-
-  // Power OK signals (library dependent)
-  parameter int PokDw = 8;
-
-  typedef logic [PokDw-1:0] pad_pok_t;
-
-endpackage : prim_pad_wrapper_pkg
diff --git a/prim_present.sv b/prim_present.sv
deleted file mode 100644
index 52adb3b8..00000000
--- a/prim_present.sv
+++ /dev/null
@@ -1,158 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// This module is an implementation of the encryption pass of the 64bit PRESENT
-// block cipher. It is a fully unrolled combinational implementation that
-// supports both key sizes specified in the paper (80bit and 128bit). Further,
-// the number of rounds is fully configurable, and the primitive supports a
-// 32bit block cipher flavor which is not specified in the original paper. It
-// should be noted, however, that the 32bit version is **not** secure and must
-// not be used in a setting where cryptographic cipher strength is required. The
-// 32bit variant is only intended to be used as a lightweight data scrambling
-// device.
-//
-// See also: prim_prince, prim_cipher_pkg
-//
-// References: - https://en.wikipedia.org/wiki/PRESENT
-//             - https://en.wikipedia.org/wiki/Prince_(cipher)
-//             - http://www.lightweightcrypto.org/present/present_ches2007.pdf
-//             - https://eprint.iacr.org/2012/529.pdf
-//             - https://csrc.nist.gov/csrc/media/events/lightweight-cryptography-workshop-2015/
-//               documents/papers/session7-maene-paper.pdf
-
-`include "prim_assert.sv"
-module prim_present #(
-  parameter int DataWidth = 64,  // {32, 64}
-  parameter int KeyWidth  = 128, // {64, 80, 128}
-  // Number of rounds to perform in total (>0)
-  parameter int NumRounds = 31,
-  // Number of physically instantiated PRESENT rounds.
-  // This can be used to construct e.g. an iterative
-  // full-round implementation that only has one physical
-  // round instance by setting NumRounds = 31 and NumPhysRounds = 1.
-  // Note that NumPhysRounds needs to divide NumRounds.
-  parameter int NumPhysRounds = NumRounds,
-  // Note that the decryption pass needs a modified key,
-  // to be calculated by performing NumRounds key updates
-  parameter bit Decrypt   = 0    // 0: encrypt, 1: decrypt
-) (
-  input        [DataWidth-1:0] data_i,
-  input        [KeyWidth-1:0]  key_i,
-  // Starting round index for keyschedule [1 ... 31].
-  // Set this to 5'd1 for a fully unrolled encryption, and 5'd31 for a fully unrolled decryption.
-  input        [4:0]           idx_i,
-  output logic [DataWidth-1:0] data_o,
-  output logic [KeyWidth-1:0]  key_o,
-  // Next round index for keyschedule
-  // (Enc: idx_i + NumPhysRounds, Dec: idx_i - NumPhysRounds)
-  // Can be ignored for a fully unrolled implementation.
-  output logic [4:0]           idx_o
-);
-
-  //////////////
-  // datapath //
-  //////////////
-
-  logic [NumPhysRounds:0][DataWidth-1:0] data_state;
-  logic [NumPhysRounds:0][KeyWidth-1:0]  round_key;
-  logic [NumPhysRounds:0][4:0]           round_idx;
-
-  // initialize
-  assign data_state[0] = data_i;
-  assign round_key[0]  = key_i;
-  assign round_idx[0]  = idx_i;
-
-  for (genvar k = 0; k < NumPhysRounds; k++) begin : gen_round
-    logic [DataWidth-1:0] data_state_xor, data_state_sbox;
-    // cipher layers
-    assign data_state_xor  = data_state[k] ^ round_key[k][KeyWidth-1 : KeyWidth-DataWidth];
-    ////////////////////////////////
-    // decryption pass, performs inverse permutation, sbox and keyschedule
-    if (Decrypt) begin : gen_dec
-      // Decrement round count.
-      assign round_idx[k+1] = round_idx[k] - 1'b1;
-      // original 64bit variant
-      if (DataWidth == 64) begin : gen_d64
-        assign data_state_sbox = prim_cipher_pkg::perm_64bit(data_state_xor,
-                                                             prim_cipher_pkg::PRESENT_PERM64_INV);
-        assign data_state[k+1] = prim_cipher_pkg::sbox4_64bit(data_state_sbox,
-                                                              prim_cipher_pkg::PRESENT_SBOX4_INV);
-      // reduced 32bit variant
-      end else begin : gen_d32
-        assign data_state_sbox = prim_cipher_pkg::perm_32bit(data_state_xor,
-                                                             prim_cipher_pkg::PRESENT_PERM32_INV);
-        assign data_state[k+1] = prim_cipher_pkg::sbox4_32bit(data_state_sbox,
-                                                              prim_cipher_pkg::PRESENT_SBOX4_INV);
-      end
-      // update round key, count goes from 1 to 31 (max)
-      // original 128bit key variant
-      if (KeyWidth == 128) begin : gen_k128
-        assign round_key[k+1]  = prim_cipher_pkg::present_inv_update_key128(round_key[k],
-                                                                            round_idx[k]);
-      // original 80bit key variant
-      end else if (KeyWidth == 80) begin : gen_k80
-        assign round_key[k+1]  = prim_cipher_pkg::present_inv_update_key80(round_key[k],
-                                                                           round_idx[k]);
-      // reduced 64bit key variant
-      end else begin : gen_k64
-        assign round_key[k+1]  = prim_cipher_pkg::present_inv_update_key64(round_key[k],
-                                                                           round_idx[k]);
-      end
-    ////////////////////////////////
-    // encryption pass
-    end else begin : gen_enc
-      // Increment round count.
-      assign round_idx[k+1] = round_idx[k] + 1'b1;
-      // original 64bit variant
-      if (DataWidth == 64) begin : gen_d64
-        assign data_state_sbox = prim_cipher_pkg::sbox4_64bit(data_state_xor,
-                                                              prim_cipher_pkg::PRESENT_SBOX4);
-        assign data_state[k+1] = prim_cipher_pkg::perm_64bit(data_state_sbox,
-                                                             prim_cipher_pkg::PRESENT_PERM64);
-      // reduced 32bit variant
-      end else begin : gen_d32
-        assign data_state_sbox = prim_cipher_pkg::sbox4_32bit(data_state_xor,
-                                                              prim_cipher_pkg::PRESENT_SBOX4);
-        assign data_state[k+1] = prim_cipher_pkg::perm_32bit(data_state_sbox,
-                                                             prim_cipher_pkg::PRESENT_PERM32);
-      end
-      // update round key, count goes from 1 to 31 (max)
-      // original 128bit key variant
-      if (KeyWidth == 128) begin : gen_k128
-        assign round_key[k+1]  = prim_cipher_pkg::present_update_key128(round_key[k], round_idx[k]);
-      // original 80bit key variant
-      end else if (KeyWidth == 80) begin : gen_k80
-        assign round_key[k+1]  = prim_cipher_pkg::present_update_key80(round_key[k], round_idx[k]);
-      // reduced 64bit key variant
-      end else begin : gen_k64
-        assign round_key[k+1]  = prim_cipher_pkg::present_update_key64(round_key[k], round_idx[k]);
-      end
-    end // gen_enc
-    ////////////////////////////////
-  end // gen_round
-
-  // This only needs to be applied after the last round.
-  // Note that for a full-round implementation the output index
-  // will be 0 for enc/dec for the last round (either due to wraparound or subtraction).
-  localparam int LastRoundIdx = (Decrypt != 0 || NumRounds == 31) ? 0 : NumRounds+1;
-  assign data_o = (idx_o == LastRoundIdx) ?
-      data_state[NumPhysRounds] ^
-      round_key[NumPhysRounds][KeyWidth-1 : KeyWidth-DataWidth] :
-      data_state[NumPhysRounds];
-
-  assign key_o  = round_key[NumPhysRounds];
-  assign idx_o  = round_idx[NumPhysRounds];
-
-  ////////////////
-  // assertions //
-  ////////////////
-
-  `ASSERT_INIT(SupportedWidths_A, (DataWidth == 64 && KeyWidth inside {80, 128}) ||
-                                  (DataWidth == 32 && KeyWidth == 64))
-  `ASSERT_INIT(SupportedNumRounds_A, NumRounds > 0 && NumRounds <= 31)
-  `ASSERT_INIT(SupportedNumPhysRounds0_A, NumPhysRounds > 0 && NumPhysRounds <= NumRounds)
-  // Currently we do not support other arrangements
-  `ASSERT_INIT(SupportedNumPhysRounds1_A, (NumRounds % NumPhysRounds) == 0)
-
-endmodule : prim_present
diff --git a/prim_prince.sv b/prim_prince.sv
deleted file mode 100644
index 0adb98c5..00000000
--- a/prim_prince.sv
+++ /dev/null
@@ -1,248 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// This module is an implementation of the 64bit PRINCE block cipher. It is a fully unrolled
-// combinational implementation with configurable number of rounds. Optionally, registers for the
-// data and key states can be enabled, if this is required. Due to the reflective construction of
-// this cipher, the same circuit can be used for encryption and decryption, as described below.
-// Further, the primitive supports a 32bit block cipher flavor which is not specified in the
-// original paper. It should be noted, however, that the 32bit version is **not** secure and must
-// not be used in a setting where cryptographic cipher strength is required. The 32bit variant is
-// only intended to be used as a lightweight data scrambling device.
-//
-// See also: prim_present, prim_cipher_pkg
-//
-// References: - https://en.wikipedia.org/wiki/PRESENT
-//             - https://en.wikipedia.org/wiki/Prince_(cipher)
-//             - http://www.lightweightcrypto.org/present/present_ches2007.pdf
-//             - https://csrc.nist.gov/csrc/media/events/lightweight-cryptography-workshop-2015/
-//               documents/papers/session7-maene-paper.pdf
-//             - https://eprint.iacr.org/2012/529.pdf
-//             - https://eprint.iacr.org/2015/372.pdf
-//             - https://eprint.iacr.org/2014/656.pdf
-
-`include "prim_assert.sv"
-module prim_prince #(
-  parameter int DataWidth     = 64,
-  parameter int KeyWidth      = 128,
-  // The construction is reflective. Total number of rounds is 2*NumRoundsHalf + 2
-  parameter int NumRoundsHalf = 5,
-  // This primitive uses the new key schedule proposed in https://eprint.iacr.org/2014/656.pdf
-  // Setting this parameter to 1 falls back to the original key schedule.
-  parameter bit UseOldKeySched = 1'b0,
-  // This instantiates a data register halfway in the primitive.
-  parameter bit HalfwayDataReg = 1'b0,
-  // This instantiates a key register halfway in the primitive.
-  parameter bit HalfwayKeyReg = 1'b0
-) (
-  input                        clk_i,
-  input                        rst_ni,
-
-  input                        valid_i,
-  input        [DataWidth-1:0] data_i,
-  input        [KeyWidth-1:0]  key_i,
-  input                        dec_i,   // set to 1 for decryption
-  output logic                 valid_o,
-  output logic [DataWidth-1:0] data_o
-);
-
-  ///////////////////
-  // key expansion //
-  ///////////////////
-
-  logic [DataWidth-1:0] k0, k0_prime_d, k1_d, k0_new_d, k0_prime_q, k1_q, k0_new_q;
-  always_comb begin : p_key_expansion
-    k0         = key_i[2*DataWidth-1 : DataWidth];
-    k0_prime_d = {k0[0], k0[DataWidth-1:2], k0[DataWidth-1] ^ k0[1]};
-    k1_d       = key_i[DataWidth-1:0];
-
-    // modify key for decryption
-    if (dec_i) begin
-      k0          = k0_prime_d;
-      k0_prime_d  = key_i[2*DataWidth-1 : DataWidth];
-      k1_d       ^= prim_cipher_pkg::PRINCE_ALPHA_CONST[DataWidth-1:0];
-    end
-  end
-
-  if (UseOldKeySched) begin : gen_legacy_keyschedule
-    // In this case we constantly use k1.
-    assign k0_new_d = k1_d;
-  end else begin : gen_new_keyschedule
-    // Imroved keyschedule proposed by https://eprint.iacr.org/2014/656.pdf
-    // In this case we alternate between k1 and k0.
-    always_comb begin : p_new_keyschedule_k0_alpha
-      k0_new_d = key_i[2*DataWidth-1 : DataWidth];
-      // We need to apply the alpha constant here as well, just as for k1 in decryption mode.
-      if (dec_i) begin
-        k0_new_d ^= prim_cipher_pkg::PRINCE_ALPHA_CONST[DataWidth-1:0];
-      end
-    end
-  end
-
-  if (HalfwayKeyReg) begin : gen_key_reg
-    always_ff @(posedge clk_i or negedge rst_ni) begin : p_key_reg
-      if (!rst_ni) begin
-        k1_q       <= '0;
-        k0_prime_q <= '0;
-        k0_new_q   <= '0;
-      end else begin
-        if (valid_i) begin
-          k1_q       <= k1_d;
-          k0_prime_q <= k0_prime_d;
-          k0_new_q   <= k0_new_d;
-        end
-      end
-    end
-  end else begin : gen_no_key_reg
-    // just pass the key through in this case
-    assign k1_q       = k1_d;
-    assign k0_prime_q = k0_prime_d;
-    assign k0_new_q   = k0_new_d;
-  end
-
-  //////////////
-  // datapath //
-  //////////////
-
-  // State variable for holding the rounds
-  //
-  // The "split_var" hint that we pass to verilator here tells it to schedule the different parts of
-  // data_state separately. This avoids an UNOPTFLAT error where it would otherwise see a dependency
-  // chain
-  //
-  //    data_state -> data_state_round -> data_state_xor -> data_state
-  //
-  logic [NumRoundsHalf*2+1:0][DataWidth-1:0] data_state /* verilator split_var */;
-
-  // pre-round XOR
-  always_comb begin : p_pre_round_xor
-    data_state[0] = data_i ^ k0;
-    data_state[0] ^= k1_d;
-    data_state[0] ^= prim_cipher_pkg::PRINCE_ROUND_CONST[0][DataWidth-1:0];
-  end
-
-  // forward pass
-  for (genvar k = 1; k <= NumRoundsHalf; k++) begin : gen_fwd_pass
-    logic [DataWidth-1:0] data_state_round;
-    if (DataWidth == 64) begin : gen_fwd_d64
-      always_comb begin : p_fwd_d64
-        data_state_round = prim_cipher_pkg::sbox4_64bit(data_state[k-1],
-            prim_cipher_pkg::PRINCE_SBOX4);
-        data_state_round = prim_cipher_pkg::prince_mult_prime_64bit(data_state_round);
-        data_state_round = prim_cipher_pkg::prince_shiftrows_64bit(data_state_round,
-            prim_cipher_pkg::PRINCE_SHIFT_ROWS64);
-      end
-    end else begin : gen_fwd_d32
-      always_comb begin : p_fwd_d32
-        data_state_round = prim_cipher_pkg::sbox4_32bit(data_state[k-1],
-            prim_cipher_pkg::PRINCE_SBOX4);
-        data_state_round = prim_cipher_pkg::prince_mult_prime_32bit(data_state_round);
-        data_state_round = prim_cipher_pkg::prince_shiftrows_32bit(data_state_round,
-            prim_cipher_pkg::PRINCE_SHIFT_ROWS64);
-      end
-    end
-    logic [DataWidth-1:0] data_state_xor;
-    assign data_state_xor = data_state_round ^
-                            prim_cipher_pkg::PRINCE_ROUND_CONST[k][DataWidth-1:0];
-    // improved keyschedule proposed by https://eprint.iacr.org/2014/656.pdf
-    if (k % 2 == 1) begin : gen_fwd_key_odd
-      assign data_state[k]  = data_state_xor ^ k0_new_d;
-    end else begin : gen_fwd_key_even
-      assign data_state[k]  = data_state_xor ^ k1_d;
-    end
-  end
-
-  // middle part
-  logic [DataWidth-1:0] data_state_middle_d, data_state_middle_q, data_state_middle;
-  if (DataWidth == 64) begin : gen_middle_d64
-    always_comb begin : p_middle_d64
-      data_state_middle_d = prim_cipher_pkg::sbox4_64bit(data_state[NumRoundsHalf],
-          prim_cipher_pkg::PRINCE_SBOX4);
-      data_state_middle = prim_cipher_pkg::prince_mult_prime_64bit(data_state_middle_q);
-      data_state_middle = prim_cipher_pkg::sbox4_64bit(data_state_middle,
-          prim_cipher_pkg::PRINCE_SBOX4_INV);
-    end
-  end else begin : gen_middle_d32
-    always_comb begin : p_middle_d32
-      data_state_middle_d = prim_cipher_pkg::sbox4_32bit(data_state_middle[NumRoundsHalf],
-          prim_cipher_pkg::PRINCE_SBOX4);
-      data_state_middle = prim_cipher_pkg::prince_mult_prime_32bit(data_state_middle_q);
-      data_state_middle = prim_cipher_pkg::sbox4_32bit(data_state_middle,
-          prim_cipher_pkg::PRINCE_SBOX4_INV);
-    end
-  end
-
-  if (HalfwayDataReg) begin : gen_data_reg
-    logic valid_q;
-    always_ff @(posedge clk_i or negedge rst_ni) begin : p_data_reg
-      if (!rst_ni) begin
-        valid_q <= 1'b0;
-        data_state_middle_q <= '0;
-      end else begin
-        valid_q <= valid_i;
-        if (valid_i) begin
-          data_state_middle_q <= data_state_middle_d;
-        end
-      end
-    end
-    assign valid_o = valid_q;
-  end else begin : gen_no_data_reg
-    // just pass data through in this case
-    assign data_state_middle_q = data_state_middle_d;
-    assign valid_o = valid_i;
-  end
-
-  assign data_state[NumRoundsHalf+1] = data_state_middle;
-
-  // backward pass
-  for (genvar k = 1; k <= NumRoundsHalf; k++) begin : gen_bwd_pass
-    logic [DataWidth-1:0] data_state_xor0, data_state_xor1;
-    // improved keyschedule proposed by https://eprint.iacr.org/2014/656.pdf
-    if ((NumRoundsHalf + k + 1) % 2 == 1) begin : gen_bkwd_key_odd
-      assign data_state_xor0 = data_state[NumRoundsHalf+k] ^ k0_new_q;
-    end else begin : gen_bkwd_key_even
-      assign data_state_xor0 = data_state[NumRoundsHalf+k] ^ k1_q;
-    end
-    // the construction is reflective, hence the subtraction with NumRoundsHalf
-    assign data_state_xor1 = data_state_xor0 ^
-                             prim_cipher_pkg::PRINCE_ROUND_CONST[10-NumRoundsHalf+k][DataWidth-1:0];
-
-    logic [DataWidth-1:0] data_state_bwd;
-    if (DataWidth == 64) begin : gen_bwd_d64
-      always_comb begin : p_bwd_d64
-        data_state_bwd = prim_cipher_pkg::prince_shiftrows_64bit(data_state_xor1,
-            prim_cipher_pkg::PRINCE_SHIFT_ROWS64_INV);
-        data_state_bwd = prim_cipher_pkg::prince_mult_prime_64bit(data_state_bwd);
-        data_state[NumRoundsHalf+k+1] = prim_cipher_pkg::sbox4_64bit(data_state_bwd,
-            prim_cipher_pkg::PRINCE_SBOX4_INV);
-      end
-    end else begin : gen_bwd_d32
-      always_comb begin : p_bwd_d32
-        data_state_bwd = prim_cipher_pkg::prince_shiftrows_32bit(data_state_xor1,
-            prim_cipher_pkg::PRINCE_SHIFT_ROWS64_INV);
-        data_state_bwd = prim_cipher_pkg::prince_mult_prime_32bit(data_state_bwd);
-        data_state[NumRoundsHalf+k+1] = prim_cipher_pkg::sbox4_32bit(data_state_bwd,
-            prim_cipher_pkg::PRINCE_SBOX4_INV);
-      end
-    end
-  end
-
-  // post-rounds
-  always_comb begin : p_post_round_xor
-    data_o  = data_state[2*NumRoundsHalf+1] ^
-              prim_cipher_pkg::PRINCE_ROUND_CONST[11][DataWidth-1:0];
-    data_o ^= k1_q;
-    data_o ^= k0_prime_q;
-  end
-
-  ////////////////
-  // assertions //
-  ////////////////
-
-  `ASSERT_INIT(SupportedWidths_A, (DataWidth == 64 && KeyWidth == 128) ||
-                                  (DataWidth == 32 && KeyWidth == 64))
-  `ASSERT_INIT(SupportedNumRounds_A, NumRoundsHalf > 0 && NumRoundsHalf < 6)
-
-
-endmodule : prim_prince
diff --git a/prim_pulse_sync.sv b/prim_pulse_sync.sv
deleted file mode 100644
index ad275fd9..00000000
--- a/prim_pulse_sync.sv
+++ /dev/null
@@ -1,66 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Pulse synchronizer: synchronizes a pulse from source clock domain (clk_src)
-// to destination clock domain (clk_dst). Each pulse has the length of one clock
-// cycle of its respective clock domain. Consecutive pulses need to be spaced
-// appropriately apart from each other depending on the clock frequency ratio
-// of the two clock domains.
-
-module prim_pulse_sync (
-  // source clock domain
-  input  logic clk_src_i,
-  input  logic rst_src_ni,
-  input  logic src_pulse_i,
-  // destination clock domain
-  input  logic clk_dst_i,
-  input  logic rst_dst_ni,
-  output logic dst_pulse_o
-);
-
-  ////////////////////////////////////////////////////////////////////////////////
-  // convert src_pulse to a level signal so we can use double-flop synchronizer //
-  ////////////////////////////////////////////////////////////////////////////////
-  logic src_level;
-
-  always_ff @(posedge clk_src_i or negedge rst_src_ni) begin
-    if (!rst_src_ni) begin
-      src_level <= 1'b0;
-    end else begin
-      src_level <= src_level ^ src_pulse_i;
-    end
-  end
-
-  //////////////////////////////////////////////////////////
-  // synchronize level signal to destination clock domain //
-  //////////////////////////////////////////////////////////
-  logic dst_level;
-
-  prim_flop_2sync #(.Width(1)) prim_flop_2sync (
-    // source clock domain
-    .d_i    (src_level),
-    // destination clock domain
-    .clk_i  (clk_dst_i),
-    .rst_ni (rst_dst_ni),
-    .q_o    (dst_level)
-  );
-
-  ////////////////////////////////////////
-  // convert level signal back to pulse //
-  ////////////////////////////////////////
-  logic dst_level_q;
-
-  // delay dst_level by 1 cycle
-  always_ff @(posedge clk_dst_i or negedge rst_dst_ni) begin
-    if (!rst_dst_ni) begin
-      dst_level_q <= 1'b0;
-    end else begin
-      dst_level_q <= dst_level;
-    end
-  end
-
-  // edge detection
-  assign dst_pulse_o = dst_level_q ^ dst_level;
-
-endmodule
diff --git a/prim_ram_1p_adv.sv b/prim_ram_1p_adv.sv
deleted file mode 100644
index 71bd99b0..00000000
--- a/prim_ram_1p_adv.sv
+++ /dev/null
@@ -1,269 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Single-Port SRAM Wrapper
-//
-// Supported configurations:
-// - ECC for 32b and 64b wide memories with no write mask
-//   (Width == 32 or Width == 64, DataBitsPerMask is ignored).
-// - Byte parity if Width is a multiple of 8 bit and write masks have Byte
-//   granularity (DataBitsPerMask == 8).
-//
-// Note that the write mask needs to be per Byte if parity is enabled. If ECC is enabled, the write
-// mask cannot be used and has to be tied to {Width{1'b1}}.
-
-`include "prim_assert.sv"
-
-module prim_ram_1p_adv import prim_ram_1p_pkg::*; #(
-  parameter  int Depth                = 512,
-  parameter  int Width                = 32,
-  parameter  int DataBitsPerMask      = 1,  // Number of data bits per bit of write mask
-  parameter      MemInitFile          = "", // VMEM file to initialize the memory with
-
-  // Configurations
-  parameter  bit EnableECC            = 0, // Enables per-word ECC
-  parameter  bit EnableParity         = 0, // Enables per-Byte Parity
-  parameter  bit EnableInputPipeline  = 0, // Adds an input register (read latency +1)
-  parameter  bit EnableOutputPipeline = 0, // Adds an output register (read latency +1)
-
-  // This switch allows to switch to standard Hamming ECC instead of the HSIAO ECC.
-  // It is recommended to leave this parameter at its default setting (HSIAO),
-  // since this results in a more compact and faster implementation.
-  parameter bit HammingECC            = 0,
-
-  localparam int Aw                   = prim_util_pkg::vbits(Depth)
-) (
-  input clk_i,
-  input rst_ni,
-
-  input                      req_i,
-  input                      write_i,
-  input        [Aw-1:0]      addr_i,
-  input        [Width-1:0]   wdata_i,
-  input        [Width-1:0]   wmask_i,
-  output logic [Width-1:0]   rdata_o,
-  output logic               rvalid_o, // read response (rdata_o) is valid
-  output logic [1:0]         rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
-
-  // config
-  input ram_1p_cfg_t         cfg_i
-);
-
-
-  `ASSERT_INIT(CannotHaveEccAndParity_A, !(EnableParity && EnableECC))
-
-  // Calculate ECC width
-  localparam int ParWidth  = (EnableParity) ? Width/8 :
-                             (!EnableECC)   ? 0 :
-                             (Width <=   4) ? 4 :
-                             (Width <=  11) ? 5 :
-                             (Width <=  26) ? 6 :
-                             (Width <=  57) ? 7 :
-                             (Width <= 120) ? 8 : 8 ;
-  localparam int TotalWidth = Width + ParWidth;
-
-  // If byte parity is enabled, the write enable bits are used to write memory colums
-  // with 8 + 1 = 9 bit width (data plus corresponding parity bit).
-  // If ECC is enabled, the DataBitsPerMask is ignored.
-  localparam int LocalDataBitsPerMask = (EnableParity) ? 9          :
-                                        (EnableECC)    ? TotalWidth :
-                                                         DataBitsPerMask;
-
-  ////////////////////////////
-  // RAM Primitive Instance //
-  ////////////////////////////
-
-  logic                    req_q,    req_d ;
-  logic                    write_q,  write_d ;
-  logic [Aw-1:0]           addr_q,   addr_d ;
-  logic [TotalWidth-1:0]   wdata_q,  wdata_d ;
-  logic [TotalWidth-1:0]   wmask_q,  wmask_d ;
-  logic                    rvalid_q, rvalid_d, rvalid_sram_q ;
-  logic [Width-1:0]        rdata_q,  rdata_d ;
-  logic [TotalWidth-1:0]   rdata_sram ;
-  logic [1:0]              rerror_q, rerror_d ;
-
-  prim_ram_1p #(
-    .MemInitFile     (MemInitFile),
-
-    .Width           (TotalWidth),
-    .Depth           (Depth),
-    .DataBitsPerMask (LocalDataBitsPerMask)
-  ) u_mem (
-    .clk_i,
-
-    .req_i    (req_q),
-    .write_i  (write_q),
-    .addr_i   (addr_q),
-    .wdata_i  (wdata_q),
-    .wmask_i  (wmask_q),
-    .rdata_o  (rdata_sram),
-    .cfg_i
-  );
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      rvalid_sram_q <= 1'b0;
-    end else begin
-      rvalid_sram_q <= req_q & ~write_q;
-    end
-  end
-
-  assign req_d              = req_i;
-  assign write_d            = write_i;
-  assign addr_d             = addr_i;
-  assign rvalid_o           = rvalid_q;
-  assign rdata_o            = rdata_q;
-  assign rerror_o           = rerror_q;
-
-  /////////////////////////////
-  // ECC / Parity Generation //
-  /////////////////////////////
-
-  if (EnableParity == 0 && EnableECC) begin : gen_secded
-    logic unused_wmask;
-    assign unused_wmask = ^wmask_i;
-
-    // check supported widths
-    `ASSERT_INIT(SecDecWidth_A, Width inside {16, 32})
-
-    // the wmask is constantly set to 1 in this case
-    `ASSERT(OnlyWordWritePossibleWithEccPortA_A, req_i |->
-          wmask_i == {Width{1'b1}})
-
-    assign wmask_d = {TotalWidth{1'b1}};
-
-    if (Width == 16) begin : gen_secded_22_16
-      if (HammingECC) begin : gen_hamming
-        prim_secded_inv_hamming_22_16_enc u_enc (
-          .data_i(wdata_i),
-          .data_o(wdata_d)
-        );
-        prim_secded_inv_hamming_22_16_dec u_dec (
-          .data_i     (rdata_sram),
-          .data_o     (rdata_d[0+:Width]),
-          .syndrome_o ( ),
-          .err_o      (rerror_d)
-        );
-      end else begin : gen_hsiao
-        prim_secded_inv_22_16_enc u_enc (
-          .data_i(wdata_i),
-          .data_o(wdata_d)
-        );
-        prim_secded_inv_22_16_dec u_dec (
-          .data_i     (rdata_sram),
-          .data_o     (rdata_d[0+:Width]),
-          .syndrome_o ( ),
-          .err_o      (rerror_d)
-        );
-      end
-    end else if (Width == 32) begin : gen_secded_39_32
-      if (HammingECC) begin : gen_hamming
-        prim_secded_inv_hamming_39_32_enc u_enc (
-          .data_i(wdata_i),
-          .data_o(wdata_d)
-        );
-        prim_secded_inv_hamming_39_32_dec u_dec (
-          .data_i     (rdata_sram),
-          .data_o     (rdata_d[0+:Width]),
-          .syndrome_o ( ),
-          .err_o      (rerror_d)
-        );
-      end else begin : gen_hsiao
-        prim_secded_inv_39_32_enc u_enc (
-          .data_i(wdata_i),
-          .data_o(wdata_d)
-        );
-        prim_secded_inv_39_32_dec u_dec (
-          .data_i     (rdata_sram),
-          .data_o     (rdata_d[0+:Width]),
-          .syndrome_o ( ),
-          .err_o      (rerror_d)
-        );
-      end
-    end
-
-  end else if (EnableParity) begin : gen_byte_parity
-
-    `ASSERT_INIT(WidthNeedsToBeByteAligned_A, Width % 8 == 0)
-    `ASSERT_INIT(ParityNeedsByteWriteMask_A, DataBitsPerMask == 8)
-
-    always_comb begin : p_parity
-      rerror_d = '0;
-      for (int i = 0; i < Width/8; i ++) begin
-        // Data mapping. We have to make 8+1 = 9 bit groups
-        // that have the same write enable such that FPGA tools
-        // can map this correctly to BRAM resources.
-        wmask_d[i*9 +: 8] = wmask_i[i*8 +: 8];
-        wdata_d[i*9 +: 8] = wdata_i[i*8 +: 8];
-        rdata_d[i*8 +: 8] = rdata_sram[i*9 +: 8];
-
-        // parity generation (odd parity)
-        wdata_d[i*9 + 8] = ~(^wdata_i[i*8 +: 8]);
-        wmask_d[i*9 + 8] = &wmask_i[i*8 +: 8];
-        // parity decoding (errors are always uncorrectable)
-        rerror_d[1] |= ~(^{rdata_sram[i*9 +: 8], rdata_sram[i*9 + 8]});
-      end
-    end
-  end else begin : gen_nosecded_noparity
-    assign wmask_d = wmask_i;
-    assign wdata_d = wdata_i;
-
-    assign rdata_d  = rdata_sram[0+:Width];
-    assign rerror_d = '0;
-  end
-
-  assign rvalid_d = rvalid_sram_q;
-
-  /////////////////////////////////////
-  // Input/Output Pipeline Registers //
-  /////////////////////////////////////
-
-  if (EnableInputPipeline) begin : gen_regslice_input
-    // Put the register slices between ECC encoding to SRAM port
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-        req_q   <= '0;
-        write_q <= '0;
-        addr_q  <= '0;
-        wdata_q <= '0;
-        wmask_q <= '0;
-      end else begin
-        req_q   <= req_d;
-        write_q <= write_d;
-        addr_q  <= addr_d;
-        wdata_q <= wdata_d;
-        wmask_q <= wmask_d;
-      end
-    end
-  end else begin : gen_dirconnect_input
-    assign req_q   = req_d;
-    assign write_q = write_d;
-    assign addr_q  = addr_d;
-    assign wdata_q = wdata_d;
-    assign wmask_q = wmask_d;
-  end
-
-  if (EnableOutputPipeline) begin : gen_regslice_output
-    // Put the register slices between ECC decoding to output
-    always_ff @(posedge clk_i or negedge rst_ni) begin
-      if (!rst_ni) begin
-        rvalid_q <= '0;
-        rdata_q  <= '0;
-        rerror_q <= '0;
-      end else begin
-        rvalid_q <= rvalid_d;
-        rdata_q  <= rdata_d;
-        // tie to zero if the read data is not valid
-        rerror_q <= rerror_d & {2{rvalid_d}};
-      end
-    end
-  end else begin : gen_dirconnect_output
-    assign rvalid_q = rvalid_d;
-    assign rdata_q  = rdata_d;
-    // tie to zero if the read data is not valid
-    assign rerror_q = rerror_d & {2{rvalid_d}};
-  end
-
-endmodule : prim_ram_1p_adv
diff --git a/prim_ram_1p_pkg.sv b/prim_ram_1p_pkg.sv
deleted file mode 100644
index d4796292..00000000
--- a/prim_ram_1p_pkg.sv
+++ /dev/null
@@ -1,20 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-
-package prim_ram_1p_pkg;
-
-  typedef struct packed {
-    logic       cfg_en;
-    logic [3:0] cfg;
-  } cfg_t;
-
-  typedef struct packed {
-    cfg_t ram_cfg;  // configuration for ram
-    cfg_t rf_cfg;   // configuration for regfile
-  } ram_1p_cfg_t;
-
-  parameter ram_1p_cfg_t RAM_1P_CFG_DEFAULT = '0;
-
-endpackage // prim_ram_1p_pkg
diff --git a/prim_ram_1p_scr.sv b/prim_ram_1p_scr.sv
deleted file mode 100644
index 8e3fe196..00000000
--- a/prim_ram_1p_scr.sv
+++ /dev/null
@@ -1,425 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// This is a draft implementation of a low-latency memory scrambling mechanism.
-//
-// The module is implemented as a primitive, in the same spirit as similar prim_ram_1p_adv wrappers.
-// Hence, it can be conveniently instantiated by comportable IPs (such as OTBN) or in top_earlgrey
-// for the main system memory.
-//
-// The currently implemented architecture uses a reduced-round PRINCE cipher primitive in CTR mode
-// in order to (weakly) scramble the data written to the memory macro. Plain CTR mode does not
-// diffuse the data since the keystream is just XOR'ed onto it, hence we also we perform byte-wise
-// diffusion using a (shallow) substitution/permutation network layers in order to provide a limited
-// avalanche effect within a byte.
-//
-// In order to break the linear addressing space, the address is passed through a bijective
-// scrambling function constructed using a (shallow) substitution/permutation and a nonce. Due to
-// that nonce, the address mapping is not fully baked into RTL and can be changed at runtime as
-// well.
-//
-// See also: prim_cipher_pkg, prim_prince
-
-`include "prim_assert.sv"
-
-module prim_ram_1p_scr import prim_ram_1p_pkg::*; #(
-  parameter  int Depth               = 16*1024, // Needs to be a power of 2 if NumAddrScrRounds > 0.
-  parameter  int Width               = 32, // Needs to be byte aligned if byte parity is enabled.
-  parameter  int DataBitsPerMask     = 8, // Needs to be set to 8 in case of byte parity.
-  parameter  bit EnableParity        = 1, // Enable byte parity.
-
-  // Scrambling parameters. Note that this needs to be low-latency, hence we have to keep the
-  // amount of cipher rounds low. PRINCE has 5 half rounds in its original form, which corresponds
-  // to 2*5 + 1 effective rounds. Setting this to 2 halves this to approximately 5 effective rounds.
-  // Number of PRINCE half rounds, can be [1..5]
-  parameter  int NumPrinceRoundsHalf = 2,
-  // Number of extra diffusion rounds. Setting this to 0 to disable diffusion.
-  parameter  int NumDiffRounds       = 2,
-  // This parameter governs the block-width of additional diffusion layers.
-  // For intra-byte diffusion, set this parameter to 8.
-  parameter  int DiffWidth           = DataBitsPerMask,
-  // Number of address scrambling rounds. Setting this to 0 disables address scrambling.
-  parameter  int NumAddrScrRounds    = 2,
-  // If set to 1, the same 64bit key stream is replicated if the data port is wider than 64bit.
-  // If set to 0, the cipher primitive is replicated, and together with a wider nonce input,
-  // a unique keystream is generated for the full data width.
-  parameter  bit ReplicateKeyStream  = 1'b0,
-  // Derived parameters
-  localparam int AddrWidth           = prim_util_pkg::vbits(Depth),
-  // Depending on the data width, we need to instantiate multiple parallel cipher primitives to
-  // create a keystream that is wide enough (PRINCE has a block size of 64bit)
-  localparam int NumParScr           = (ReplicateKeyStream) ? 1 : (Width + 63) / 64,
-  localparam int NumParKeystr        = (ReplicateKeyStream) ? (Width + 63) / 64 : 1,
-  // This is given by the PRINCE cipher primitive. All parallel cipher modules
-  // use the same key, but they use a different IV
-  localparam int DataKeyWidth        = 128,
-  // Each 64 bit scrambling primitive requires a 64bit IV
-  localparam int NonceWidth          = 64 * NumParScr
-) (
-  input                             clk_i,
-  input                             rst_ni,
-
-  // Key interface. Memory requests will not be granted if key_valid is set to 0.
-  input                             key_valid_i,
-  input        [DataKeyWidth-1:0]   key_i,
-  input        [NonceWidth-1:0]     nonce_i,
-
-  // Interface to TL-UL SRAM adapter
-  input                             req_i,
-  output logic                      gnt_o,
-  input                             write_i,
-  input        [AddrWidth-1:0]      addr_i,
-  input        [Width-1:0]          wdata_i,
-  input        [Width-1:0]          wmask_i,  // Needs to be byte-aligned for parity
-  // The incoming transaction contains an integrity error and the module should alter
-  // its behavior appropriately.
-  // On integrity errors, the primitive reverses the bit-order of the nonce and surpresses
-  // any real transaction to the memory.
-  input                             intg_error_i,
-  output logic [Width-1:0]          rdata_o,
-  output logic                      rvalid_o, // Read response (rdata_o) is valid
-  output logic [1:0]                rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
-  output logic [31:0]               raddr_o,  // Read address for error reporting.
-
-  // config
-  input ram_1p_cfg_t                cfg_i
-);
-
-  //////////////////////
-  // Parameter Checks //
-  //////////////////////
-
-  // The depth needs to be a power of 2 in case address scrambling is turned on
-  `ASSERT_INIT(DepthPow2Check_A, NumAddrScrRounds <= '0 || 2**$clog2(Depth) == Depth)
-  `ASSERT_INIT(DiffWidthMinimum_A, DiffWidth >= 4)
-  `ASSERT_INIT(DiffWidthWithParity_A, EnableParity && (DiffWidth == 8) || !EnableParity)
-
-  /////////////////////////////////////////
-  // Pending Write and Address Registers //
-  /////////////////////////////////////////
-
-  // Writes are delayed by one cycle, such the same keystream generation primitive (prim_prince) can
-  // be reused among reads and writes. Note however that with this arrangement, we have to introduce
-  // a mechanism to hold a pending write transaction in cases where that transaction is immediately
-  // followed by a read. The pending write transaction is written to memory as soon as there is no
-  // new read transaction incoming. The latter can be a special case if the incoming read goes to
-  // the same address as the pending write. To that end, we detect the address collision and return
-  // the data from the write holding register.
-
-  // Read / write strobes
-  logic read_en, write_en_d, write_en_q;
-  assign gnt_o = req_i & key_valid_i;
-
-  assign read_en = gnt_o & ~write_i;
-  assign write_en_d = gnt_o & write_i;
-
-  logic write_pending_q;
-  logic addr_collision_d, addr_collision_q;
-  logic [AddrWidth-1:0] waddr_q;
-  assign addr_collision_d = read_en & (write_en_q | write_pending_q) & (addr_i == waddr_q);
-
-  // Macro requests and write strobe
-  // The macro operation is silenced if an integrity error is seen
-  logic macro_req;
-  logic intg_err_macro_req;
-  prim_buf u_intg_err_macro_req (
-    .in_i(intg_error_i),
-    .out_o(intg_err_macro_req)
-  );
-  assign macro_req   = ~intg_err_macro_req & (read_en | write_en_q | write_pending_q);
-  // We are allowed to write a pending write transaction to the memory if there is no incoming read
-  logic macro_write;
-  assign macro_write = (write_en_q | write_pending_q) & ~read_en;
-  // New read write collision
-  logic rw_collision;
-  assign rw_collision = write_en_q & read_en;
-
-  ////////////////////////
-  // Address Scrambling //
-  ////////////////////////
-
-  // We only select the pending write address in case there is no incoming read transaction.
-  logic [AddrWidth-1:0] addr_mux;
-  assign addr_mux = (read_en) ? addr_i : waddr_q;
-
-  // This creates a bijective address mapping using a substitution / permutation network.
-  logic [AddrWidth-1:0] addr_scr;
-  if (NumAddrScrRounds > 0) begin : gen_addr_scr
-
-    logic intg_err_addr_scr;
-    prim_buf u_intg_err_addr_scr (
-      .in_i(intg_error_i),
-      .out_o(intg_err_addr_scr)
-    );
-
-    // If there is an intergirty error, the nonce used is reversed
-    logic [AddrWidth-1:0] addr_scr_nonce;
-    for (genvar j = 0; j < AddrWidth; j++) begin : gen_addr_scr_nonce
-      assign addr_scr_nonce[j] = intg_err_addr_scr ?
-                                 nonce_i[NonceWidth - 1 - j] :
-                                 nonce_i[NonceWidth - AddrWidth + j];
-    end
-
-    prim_subst_perm #(
-      .DataWidth ( AddrWidth        ),
-      .NumRounds ( NumAddrScrRounds ),
-      .Decrypt   ( 0                )
-    ) u_prim_subst_perm (
-      .data_i ( addr_mux       ),
-      // Since the counter mode concatenates {nonce_i[NonceWidth-1-AddrWidth:0], addr} to form
-      // the IV, the upper AddrWidth bits of the nonce are not used and can be used for address
-      // scrambling. In cases where N parallel PRINCE blocks are used due to a data
-      // width > 64bit, N*AddrWidth nonce bits are left dangling.
-      .key_i  ( addr_scr_nonce ),
-      .data_o ( addr_scr       )
-    );
-  end else begin : gen_no_addr_scr
-    assign addr_scr = addr_mux;
-  end
-
-  // We latch the non-scrambled address for error reporting.
-  logic [AddrWidth-1:0] raddr_q;
-  assign raddr_o = 32'(raddr_q);
-
-  //////////////////////////////////////////////
-  // Keystream Generation for Data Scrambling //
-  //////////////////////////////////////////////
-
-  // This encrypts the IV consisting of the nonce and address using the key provided in order to
-  // generate the keystream for the data. Note that we instantiate a register halfway within this
-  // primitive to balance the delay between request and response side.
-  localparam int DataNonceWidth = 64 - AddrWidth;
-  logic [NumParScr*64-1:0] keystream;
-  logic [NumParScr-1:0][DataNonceWidth-1:0] data_scr_nonce;
-
-  logic intg_err_data_scr;
-  prim_buf u_intg_err_data_scr (
-    .in_i(intg_error_i),
-    .out_o(intg_err_data_scr)
-  );
-
-  for (genvar k = 0; k < NumParScr; k++) begin : gen_par_scr
-
-    for (genvar j = 0; j < DataNonceWidth; j++) begin : gen_data_nonce
-      assign data_scr_nonce[k][j] = intg_err_data_scr ?
-                                    nonce_i[(k + 1) * DataNonceWidth - j] :
-                                    nonce_i[k * DataNonceWidth + j];
-    end
-
-
-    prim_prince #(
-      .DataWidth      (64),
-      .KeyWidth       (128),
-      .NumRoundsHalf  (NumPrinceRoundsHalf),
-      .UseOldKeySched (1'b0),
-      .HalfwayDataReg (1'b1), // instantiate a register halfway in the primitive
-      .HalfwayKeyReg  (1'b0)  // no need to instantiate a key register as the key remains static
-    ) u_prim_prince (
-      .clk_i,
-      .rst_ni,
-      .valid_i ( gnt_o ),
-      // The IV is composed of a nonce and the row address
-      //.data_i  ( {nonce_i[k * (64 - AddrWidth) +: (64 - AddrWidth)], addr} ),
-      .data_i  ( {data_scr_nonce[k], addr_i} ),
-      // All parallel scramblers use the same key
-      .key_i,
-      // Since we operate in counter mode, this can always be set to encryption mode
-      .dec_i   ( 1'b0 ),
-      // Output keystream to be XOR'ed
-      .data_o  ( keystream[k * 64 +: 64] ),
-      .valid_o ( )
-    );
-
-    // Unread unused bits from keystream
-    if (k == NumParKeystr-1 && (Width % 64) > 0) begin : gen_unread_last
-      localparam int UnusedWidth = 64 - (Width % 64);
-      logic [UnusedWidth-1:0] unused_keystream;
-      assign unused_keystream = keystream[(k+1) * 64 - 1 -: UnusedWidth];
-    end
-  end
-
-  // Replicate keystream if needed
-  logic [Width-1:0] keystream_repl;
-  assign keystream_repl = Width'({NumParKeystr{keystream}});
-
-  /////////////////////
-  // Data Scrambling //
-  /////////////////////
-
-  // Data scrambling is a two step process. First, we XOR the write data with the keystream obtained
-  // by operating a reduced-round PRINCE cipher in CTR-mode. Then, we diffuse data within each byte
-  // in order to get a limited "avalanche" behavior in case parts of the bytes are flipped as a
-  // result of a malicious attempt to tamper with the data in memory. We perform the diffusion only
-  // within bytes in order to maintain the ability to write individual bytes. Note that the
-  // keystream XOR is performed first for the write path such that it can be performed last for the
-  // read path. This allows us to hide a part of the combinational delay of the PRINCE primitive
-  // behind the propagation delay of the SRAM macro and the per-byte diffusion step.
-
-  logic [Width-1:0] rdata_scr, rdata;
-  logic [Width-1:0] wdata_scr_d, wdata_scr_q, wdata_q;
-  for (genvar k = 0; k < (Width + DiffWidth - 1) / DiffWidth; k++) begin : gen_diffuse_data
-    // If the Width is not divisible by DiffWidth, we need to adjust the width of the last slice.
-    localparam int LocalWidth = (Width - k * DiffWidth >= DiffWidth) ? DiffWidth :
-                                                                       (Width - k * DiffWidth);
-
-    // Write path. Note that since this does not fan out into the interconnect, the write path is
-    // not as critical as the read path below in terms of timing.
-    // Apply the keystream first
-    logic [LocalWidth-1:0] wdata_xor;
-    assign wdata_xor = wdata_q[k*DiffWidth +: LocalWidth] ^
-                       keystream_repl[k*DiffWidth +: LocalWidth];
-
-    // Byte aligned diffusion using a substitution / permutation network
-    prim_subst_perm #(
-      .DataWidth ( LocalWidth       ),
-      .NumRounds ( NumDiffRounds ),
-      .Decrypt   ( 0                )
-    ) u_prim_subst_perm_enc (
-      .data_i ( wdata_xor ),
-      .key_i  ( '0        ),
-      .data_o ( wdata_scr_d[k*DiffWidth +: LocalWidth] )
-    );
-
-    // Read path. This is timing critical. The keystream XOR operation is performed last in order to
-    // hide the combinational delay of the PRINCE primitive behind the propagation delay of the
-    // SRAM and the byte diffusion.
-    // Reverse diffusion first
-    logic [LocalWidth-1:0] rdata_xor;
-    prim_subst_perm #(
-      .DataWidth ( LocalWidth       ),
-      .NumRounds ( NumDiffRounds ),
-      .Decrypt   ( 1                )
-    ) u_prim_subst_perm_dec (
-      .data_i ( rdata_scr[k*DiffWidth +: LocalWidth] ),
-      .key_i  ( '0        ),
-      .data_o ( rdata_xor )
-    );
-
-    // Apply Keystream, replicate it if needed
-    assign rdata[k*DiffWidth +: LocalWidth] = rdata_xor ^
-                                              keystream_repl[k*DiffWidth +: LocalWidth];
-  end
-
-  ////////////////////////////////////////////////
-  // Scrambled data register and forwarding mux //
-  ////////////////////////////////////////////////
-
-  // This is the scrambled data holding register for pending writes. This is needed in order to make
-  // back to back patterns of the form WR -> RD -> WR work:
-  //
-  // cycle:          0   |  1   | 2   | 3   |
-  // incoming op:    WR0 |  RD  | WR1 | -   |
-  // prince:         -   |  WR0 | RD  | WR1 |
-  // memory op:      -   |  RD  | WR0 | WR1 |
-  //
-  // The read transaction in cycle 1 interrupts the first write transaction which has already used
-  // the PRINCE primitive for scrambling. If this sequence is followed by another write back-to-back
-  // in cycle 2, we cannot use the PRINCE primitive a second time for the first write, and hence
-  // need an additional holding register that can buffer the scrambled data of the first write in
-  // cycle 1.
-
-  // Clear this if we can write the memory in this cycle. Set only if the current write cannot
-  // proceed due to an incoming read operation.
-  logic write_scr_pending_d;
-  assign write_scr_pending_d = (macro_write)  ? 1'b0 :
-                               (rw_collision) ? 1'b1 :
-                                                write_pending_q;
-
-  // Select the correct scrambled word to be written, based on whether the word in the scrambled
-  // data holding register is valid or not. Note that the write_scr_q register could in theory be
-  // combined with the wdata_q register. We don't do that here for timing reasons, since that would
-  // require another read data mux to inject the scrambled data into the read descrambling path.
-  logic [Width-1:0] wdata_scr;
-  assign wdata_scr = (write_pending_q) ? wdata_scr_q : wdata_scr_d;
-
-  // Output read valid strobe
-  logic rvalid_q;
-  assign rvalid_o = rvalid_q;
-
-  logic intg_error_q;
-  logic [Width-1:0] wmask_q;
-  always_comb begin : p_forward_mux
-    rdata_o = '0;
-    // regular reads. note that we just return zero in case
-    // an integrity error was signalled.
-    if (rvalid_q && !intg_error_q) begin
-      rdata_o = rdata;
-    end
-    // In case of a collision, we forward the valid bytes of the write data from the unscrambled
-    // holding register.
-    if (addr_collision_q && !intg_error_q) begin
-      for (int k = 0; k < Width; k++) begin
-        if (wmask_q[k]) begin
-          rdata_o[k] = wdata_q[k];
-        end
-      end
-    end
-  end
-
-  ///////////////
-  // Registers //
-  ///////////////
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin : p_wdata_buf
-    if (!rst_ni) begin
-      write_pending_q     <= 1'b0;
-      addr_collision_q    <= 1'b0;
-      rvalid_q            <= 1'b0;
-      write_en_q          <= 1'b0;
-      intg_error_q        <= 1'b0;
-      raddr_q             <= '0;
-      waddr_q             <= '0;
-      wmask_q             <= '0;
-      wdata_q             <= '0;
-      wdata_scr_q         <= '0;
-    end else begin
-      write_pending_q     <= write_scr_pending_d;
-      addr_collision_q    <= addr_collision_d;
-      rvalid_q            <= read_en;
-      write_en_q          <= write_en_d;
-      intg_error_q        <= intg_error_i;
-
-      if (read_en) begin
-        raddr_q <= addr_i;
-      end
-      if (write_en_d) begin
-        waddr_q <= addr_i;
-        wmask_q <= wmask_i;
-        wdata_q <= wdata_i;
-      end
-      if (rw_collision) begin
-        wdata_scr_q <= wdata_scr_d;
-      end
-    end
-  end
-
-  //////////////////
-  // Memory Macro //
-  //////////////////
-
-  prim_ram_1p_adv #(
-    .Depth(Depth),
-    .Width(Width),
-    .DataBitsPerMask(DataBitsPerMask),
-    .EnableECC(1'b0),
-    .EnableParity(EnableParity),
-    .EnableInputPipeline(1'b0),
-    .EnableOutputPipeline(1'b0)
-  ) u_prim_ram_1p_adv (
-    .clk_i,
-    .rst_ni,
-    .req_i    ( macro_req   ),
-    .write_i  ( macro_write ),
-    .addr_i   ( addr_scr    ),
-    .wdata_i  ( wdata_scr   ),
-    .wmask_i  ( wmask_q     ),
-    .rdata_o  ( rdata_scr   ),
-    .rvalid_o ( ),
-    .rerror_o,
-    .cfg_i
-  );
-
-  `include "prim_util_get_scramble_params.svh"
-
-endmodule : prim_ram_1p_scr
diff --git a/prim_ram_2p_adv.sv b/prim_ram_2p_adv.sv
deleted file mode 100644
index 866217a6..00000000
--- a/prim_ram_2p_adv.sv
+++ /dev/null
@@ -1,95 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Dual-Port SRAM Wrapper
-//
-// Supported configurations:
-// - ECC for 32b and 64b wide memories with no write mask
-//   (Width == 32 or Width == 64, DataBitsPerMask is ignored).
-// - Byte parity if Width is a multiple of 8 bit and write masks have Byte
-//   granularity (DataBitsPerMask == 8).
-//
-// Note that the write mask needs to be per Byte if parity is enabled. If ECC is enabled, the write
-// mask cannot be used and has to be tied to {Width{1'b1}}.
-
-`include "prim_assert.sv"
-
-module prim_ram_2p_adv import prim_ram_2p_pkg::*; #(
-  parameter  int Depth                = 512,
-  parameter  int Width                = 32,
-  parameter  int DataBitsPerMask      = 1,  // Number of data bits per bit of write mask
-  parameter      MemInitFile          = "", // VMEM file to initialize the memory with
-
-  // Configurations
-  parameter  bit EnableECC            = 0, // Enables per-word ECC
-  parameter  bit EnableParity         = 0, // Enables per-Byte Parity
-  parameter  bit EnableInputPipeline  = 0, // Adds an input register (read latency +1)
-  parameter  bit EnableOutputPipeline = 0, // Adds an output register (read latency +1)
-
-  // This switch allows to switch to standard Hamming ECC instead of the HSIAO ECC.
-  // It is recommended to leave this parameter at its default setting (HSIAO),
-  // since this results in a more compact and faster implementation.
-  parameter bit HammingECC            = 0,
-
-  localparam int Aw                   = prim_util_pkg::vbits(Depth)
-) (
-  input                    clk_i,
-  input                    rst_ni,
-
-  input                    a_req_i,
-  input                    a_write_i,
-  input        [Aw-1:0]    a_addr_i,
-  input        [Width-1:0] a_wdata_i,
-  input        [Width-1:0] a_wmask_i,  // cannot be used with ECC, tie to 1 in that case
-  output logic [Width-1:0] a_rdata_o,
-  output logic             a_rvalid_o, // read response (a_rdata_o) is valid
-  output logic [1:0]       a_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
-
-  input                    b_req_i,
-  input                    b_write_i,
-  input        [Aw-1:0]    b_addr_i,
-  input        [Width-1:0] b_wdata_i,
-  input        [Width-1:0] b_wmask_i,  // cannot be used with ECC, tie to 1 in that case
-  output logic [Width-1:0] b_rdata_o,
-  output logic             b_rvalid_o, // read response (b_rdata_o) is valid
-  output logic [1:0]       b_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
-
-  input ram_2p_cfg_t       cfg_i
-);
-
-  prim_ram_2p_async_adv #(
-    .Depth               (Depth),
-    .Width               (Width),
-    .DataBitsPerMask     (DataBitsPerMask),
-    .MemInitFile         (MemInitFile),
-    .EnableECC           (EnableECC),
-    .EnableParity        (EnableParity),
-    .EnableInputPipeline (EnableInputPipeline),
-    .EnableOutputPipeline(EnableOutputPipeline),
-    .HammingECC          (HammingECC)
-  ) i_prim_ram_2p_async_adv (
-    .clk_a_i(clk_i),
-    .rst_a_ni(rst_ni),
-    .clk_b_i(clk_i),
-    .rst_b_ni(rst_ni),
-    .a_req_i,
-    .a_write_i,
-    .a_addr_i,
-    .a_wdata_i,
-    .a_wmask_i,
-    .a_rdata_o,
-    .a_rvalid_o,
-    .a_rerror_o,
-    .b_req_i,
-    .b_write_i,
-    .b_addr_i,
-    .b_wdata_i,
-    .b_wmask_i,
-    .b_rdata_o,
-    .b_rvalid_o,
-    .b_rerror_o,
-    .cfg_i
-  );
-
-endmodule : prim_ram_2p_adv
diff --git a/prim_ram_2p_async_adv.sv b/prim_ram_2p_async_adv.sv
deleted file mode 100644
index d3de6f67..00000000
--- a/prim_ram_2p_async_adv.sv
+++ /dev/null
@@ -1,358 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Asynchronous Dual-Port SRAM Wrapper
-//
-// Supported configurations:
-// - ECC for 32b and 64b wide memories with no write mask
-//   (Width == 32 or Width == 64, DataBitsPerMask is ignored).
-// - Byte parity if Width is a multiple of 8 bit and write masks have Byte
-//   granularity (DataBitsPerMask == 8).
-//
-// Note that the write mask needs to be per Byte if parity is enabled. If ECC is enabled, the write
-// mask cannot be used and has to be tied to {Width{1'b1}}.
-
-`include "prim_assert.sv"
-
-module prim_ram_2p_async_adv import prim_ram_2p_pkg::*; #(
-  parameter  int Depth                = 512,
-  parameter  int Width                = 32,
-  parameter  int DataBitsPerMask      = 1,  // Number of data bits per bit of write mask
-  parameter      MemInitFile          = "", // VMEM file to initialize the memory with
-
-  // Configurations
-  parameter  bit EnableECC            = 0, // Enables per-word ECC
-  parameter  bit EnableParity         = 0, // Enables per-Byte Parity
-  parameter  bit EnableInputPipeline  = 0, // Adds an input register (read latency +1)
-  parameter  bit EnableOutputPipeline = 0, // Adds an output register (read latency +1)
-
-  // This switch allows to switch to standard Hamming ECC instead of the HSIAO ECC.
-  // It is recommended to leave this parameter at its default setting (HSIAO),
-  // since this results in a more compact and faster implementation.
-  parameter bit HammingECC            = 0,
-
-  localparam int Aw                   = prim_util_pkg::vbits(Depth)
-) (
-  input clk_a_i,
-  input clk_b_i,
-  input rst_a_ni,
-  input rst_b_ni,
-
-  input                    a_req_i,
-  input                    a_write_i,
-  input        [Aw-1:0]    a_addr_i,
-  input        [Width-1:0] a_wdata_i,
-  input        [Width-1:0] a_wmask_i,  // cannot be used with ECC, tie to 1 in that case
-  output logic [Width-1:0] a_rdata_o,
-  output logic             a_rvalid_o, // read response (a_rdata_o) is valid
-  output logic [1:0]       a_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
-
-  input                    b_req_i,
-  input                    b_write_i,
-  input        [Aw-1:0]    b_addr_i,
-  input        [Width-1:0] b_wdata_i,
-  input        [Width-1:0] b_wmask_i,  // cannot be used with ECC, tie to 1 in that case
-  output logic [Width-1:0] b_rdata_o,
-  output logic             b_rvalid_o, // read response (b_rdata_o) is valid
-  output logic [1:0]       b_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable
-
-  // config
-  input ram_2p_cfg_t       cfg_i
-);
-
-
-  `ASSERT_INIT(CannotHaveEccAndParity_A, !(EnableParity && EnableECC))
-
-  // Calculate ECC width
-  localparam int ParWidth  = (EnableParity) ? Width/8 :
-                             (!EnableECC)   ? 0 :
-                             (Width <=   4) ? 4 :
-                             (Width <=  11) ? 5 :
-                             (Width <=  26) ? 6 :
-                             (Width <=  57) ? 7 :
-                             (Width <= 120) ? 8 : 8 ;
-  localparam int TotalWidth = Width + ParWidth;
-
-  // If byte parity is enabled, the write enable bits are used to write memory colums
-  // with 8 + 1 = 9 bit width (data plus corresponding parity bit).
-  // If ECC is enabled, the DataBitsPerMask is ignored.
-  localparam int LocalDataBitsPerMask = (EnableParity) ? 9          :
-                                        (EnableECC)    ? TotalWidth :
-                                                         DataBitsPerMask;
-
-  ////////////////////////////
-  // RAM Primitive Instance //
-  ////////////////////////////
-
-  logic                    a_req_q,    a_req_d ;
-  logic                    a_write_q,  a_write_d ;
-  logic [Aw-1:0]           a_addr_q,   a_addr_d ;
-  logic [TotalWidth-1:0]   a_wdata_q,  a_wdata_d ;
-  logic [TotalWidth-1:0]   a_wmask_q,  a_wmask_d ;
-  logic                    a_rvalid_q, a_rvalid_d, a_rvalid_sram_q ;
-  logic [Width-1:0]        a_rdata_q,  a_rdata_d ;
-  logic [TotalWidth-1:0]   a_rdata_sram ;
-  logic [1:0]              a_rerror_q, a_rerror_d ;
-
-  logic                    b_req_q,    b_req_d ;
-  logic                    b_write_q,  b_write_d ;
-  logic [Aw-1:0]           b_addr_q,   b_addr_d ;
-  logic [TotalWidth-1:0]   b_wdata_q,  b_wdata_d ;
-  logic [TotalWidth-1:0]   b_wmask_q,  b_wmask_d ;
-  logic                    b_rvalid_q, b_rvalid_d, b_rvalid_sram_q ;
-  logic [Width-1:0]        b_rdata_q,  b_rdata_d ;
-  logic [TotalWidth-1:0]   b_rdata_sram ;
-  logic [1:0]              b_rerror_q, b_rerror_d ;
-
-  prim_ram_2p #(
-    .MemInitFile     (MemInitFile),
-
-    .Width           (TotalWidth),
-    .Depth           (Depth),
-    .DataBitsPerMask (LocalDataBitsPerMask)
-  ) u_mem (
-    .clk_a_i    (clk_a_i),
-    .clk_b_i    (clk_b_i),
-
-    .a_req_i    (a_req_q),
-    .a_write_i  (a_write_q),
-    .a_addr_i   (a_addr_q),
-    .a_wdata_i  (a_wdata_q),
-    .a_wmask_i  (a_wmask_q),
-    .a_rdata_o  (a_rdata_sram),
-
-    .b_req_i    (b_req_q),
-    .b_write_i  (b_write_q),
-    .b_addr_i   (b_addr_q),
-    .b_wdata_i  (b_wdata_q),
-    .b_wmask_i  (b_wmask_q),
-    .b_rdata_o  (b_rdata_sram),
-
-    .cfg_i
-  );
-
-  always_ff @(posedge clk_a_i or negedge rst_a_ni) begin
-    if (!rst_a_ni) begin
-      a_rvalid_sram_q <= 1'b0;
-    end else begin
-      a_rvalid_sram_q <= a_req_q & ~a_write_q;
-    end
-  end
-  always_ff @(posedge clk_b_i or negedge rst_b_ni) begin
-    if (!rst_b_ni) begin
-      b_rvalid_sram_q <= 1'b0;
-    end else begin
-      b_rvalid_sram_q <= b_req_q & ~b_write_q;
-    end
-  end
-
-  assign a_req_d              = a_req_i;
-  assign a_write_d            = a_write_i;
-  assign a_addr_d             = a_addr_i;
-  assign a_rvalid_o           = a_rvalid_q;
-  assign a_rdata_o            = a_rdata_q;
-  assign a_rerror_o           = a_rerror_q;
-
-  assign b_req_d              = b_req_i;
-  assign b_write_d            = b_write_i;
-  assign b_addr_d             = b_addr_i;
-  assign b_rvalid_o           = b_rvalid_q;
-  assign b_rdata_o            = b_rdata_q;
-  assign b_rerror_o           = b_rerror_q;
-
-  /////////////////////////////
-  // ECC / Parity Generation //
-  /////////////////////////////
-
-  if (EnableParity == 0 && EnableECC) begin : gen_secded
-
-    // check supported widths
-    `ASSERT_INIT(SecDecWidth_A, Width inside {32})
-
-    // the wmask is constantly set to 1 in this case
-    `ASSERT(OnlyWordWritePossibleWithEccPortA_A, a_req_i |->
-        a_wmask_i == {Width{1'b1}}, clk_a_i, rst_a_ni)
-    `ASSERT(OnlyWordWritePossibleWithEccPortB_A, b_req_i |->
-        b_wmask_i == {Width{1'b1}}, clk_b_i, rst_b_ni)
-
-    assign a_wmask_d = {TotalWidth{1'b1}};
-    assign b_wmask_d = {TotalWidth{1'b1}};
-
-    if (Width == 32) begin : gen_secded_39_32
-      if (HammingECC) begin : gen_hamming
-        prim_secded_inv_hamming_39_32_enc u_enc_a (
-          .data_i(a_wdata_i),
-          .data_o(a_wdata_d)
-        );
-        prim_secded_inv_hamming_39_32_dec u_dec_a (
-          .data_i     (a_rdata_sram),
-          .data_o     (a_rdata_d[0+:Width]),
-          .syndrome_o ( ),
-          .err_o      (a_rerror_d)
-        );
-        prim_secded_inv_hamming_39_32_enc u_enc_b (
-          .data_i(b_wdata_i),
-          .data_o(b_wdata_d)
-        );
-        prim_secded_inv_hamming_39_32_dec u_dec_b (
-          .data_i     (b_rdata_sram),
-          .data_o     (b_rdata_d[0+:Width]),
-          .syndrome_o ( ),
-          .err_o      (b_rerror_d)
-        );
-      end else begin : gen_hsiao
-        prim_secded_inv_39_32_enc u_enc_a (
-          .data_i(a_wdata_i),
-          .data_o(a_wdata_d)
-        );
-        prim_secded_inv_39_32_dec u_dec_a (
-          .data_i     (a_rdata_sram),
-          .data_o     (a_rdata_d[0+:Width]),
-          .syndrome_o ( ),
-          .err_o      (a_rerror_d)
-        );
-        prim_secded_inv_39_32_enc u_enc_b (
-          .data_i(b_wdata_i),
-          .data_o(b_wdata_d)
-        );
-        prim_secded_inv_39_32_dec u_dec_b (
-          .data_i     (b_rdata_sram),
-          .data_o     (b_rdata_d[0+:Width]),
-          .syndrome_o ( ),
-          .err_o      (b_rerror_d)
-        );
-      end
-    end
-  end else if (EnableParity) begin : gen_byte_parity
-
-    `ASSERT_INIT(ParityNeedsByteWriteMask_A, DataBitsPerMask == 8)
-    `ASSERT_INIT(WidthNeedsToBeByteAligned_A, Width % 8 == 0)
-
-    always_comb begin : p_parity
-      a_rerror_d = '0;
-      b_rerror_d = '0;
-      for (int i = 0; i < Width/8; i ++) begin
-        // Data mapping. We have to make 8+1 = 9 bit groups
-        // that have the same write enable such that FPGA tools
-        // can map this correctly to BRAM resources.
-        a_wmask_d[i*9 +: 8] = a_wmask_i[i*8 +: 8];
-        a_wdata_d[i*9 +: 8] = a_wdata_i[i*8 +: 8];
-        a_rdata_d[i*8 +: 8] = a_rdata_sram[i*9 +: 8];
-        b_wmask_d[i*9 +: 8] = b_wmask_i[i*8 +: 8];
-        b_wdata_d[i*9 +: 8] = b_wdata_i[i*8 +: 8];
-        b_rdata_d[i*8 +: 8] = b_rdata_sram[i*9 +: 8];
-
-        // parity generation (odd parity)
-        a_wdata_d[i*9 + 8] = ~(^a_wdata_i[i*8 +: 8]);
-        a_wmask_d[i*9 + 8] = &a_wmask_i[i*8 +: 8];
-        b_wdata_d[i*9 + 8] = ~(^b_wdata_i[i*8 +: 8]);
-        b_wmask_d[i*9 + 8] = &b_wmask_i[i*8 +: 8];
-        // parity decoding (errors are always uncorrectable)
-        a_rerror_d[1] |= ~(^{a_rdata_sram[i*9 +: 8], a_rdata_sram[i*9 + 8]});
-        b_rerror_d[1] |= ~(^{b_rdata_sram[i*9 +: 8], b_rdata_sram[i*9 + 8]});
-      end
-    end
-  end else begin : gen_nosecded_noparity
-    assign a_wmask_d  = a_wmask_i;
-    assign b_wmask_d  = b_wmask_i;
-    assign a_wdata_d  = a_wdata_i;
-    assign b_wdata_d  = b_wdata_i;
-    assign a_rdata_d  = a_rdata_sram[0+:Width];
-    assign b_rdata_d  = b_rdata_sram[0+:Width];
-    assign a_rerror_d = '0;
-    assign b_rerror_d = '0;
-  end
-
-  assign a_rvalid_d = a_rvalid_sram_q;
-  assign b_rvalid_d = b_rvalid_sram_q;
-
-  /////////////////////////////////////
-  // Input/Output Pipeline Registers //
-  /////////////////////////////////////
-
-  if (EnableInputPipeline) begin : gen_regslice_input
-    // Put the register slices between ECC encoding to SRAM port
-    always_ff @(posedge clk_a_i or negedge rst_a_ni) begin
-      if (!rst_a_ni) begin
-        a_req_q   <= '0;
-        a_write_q <= '0;
-        a_addr_q  <= '0;
-        a_wdata_q <= '0;
-        a_wmask_q <= '0;
-      end else begin
-        a_req_q   <= a_req_d;
-        a_write_q <= a_write_d;
-        a_addr_q  <= a_addr_d;
-        a_wdata_q <= a_wdata_d;
-        a_wmask_q <= a_wmask_d;
-      end
-    end
-    always_ff @(posedge clk_b_i or negedge rst_b_ni) begin
-      if (!rst_b_ni) begin
-        b_req_q   <= '0;
-        b_write_q <= '0;
-        b_addr_q  <= '0;
-        b_wdata_q <= '0;
-        b_wmask_q <= '0;
-      end else begin
-        b_req_q   <= b_req_d;
-        b_write_q <= b_write_d;
-        b_addr_q  <= b_addr_d;
-        b_wdata_q <= b_wdata_d;
-        b_wmask_q <= b_wmask_d;
-      end
-    end
-  end else begin : gen_dirconnect_input
-    assign a_req_q   = a_req_d;
-    assign a_write_q = a_write_d;
-    assign a_addr_q  = a_addr_d;
-    assign a_wdata_q = a_wdata_d;
-    assign a_wmask_q = a_wmask_d;
-
-    assign b_req_q   = b_req_d;
-    assign b_write_q = b_write_d;
-    assign b_addr_q  = b_addr_d;
-    assign b_wdata_q = b_wdata_d;
-    assign b_wmask_q = b_wmask_d;
-  end
-
-  if (EnableOutputPipeline) begin : gen_regslice_output
-    // Put the register slices between ECC decoding to output
-    always_ff @(posedge clk_a_i or negedge rst_a_ni) begin
-      if (!rst_a_ni) begin
-        a_rvalid_q <= '0;
-        a_rdata_q  <= '0;
-        a_rerror_q <= '0;
-      end else begin
-        a_rvalid_q <= a_rvalid_d;
-        a_rdata_q  <= a_rdata_d;
-        // tie to zero if the read data is not valid
-        a_rerror_q <= a_rerror_d & {2{a_rvalid_d}};
-      end
-    end
-    always_ff @(posedge clk_b_i or negedge rst_b_ni) begin
-      if (!rst_b_ni) begin
-        b_rvalid_q <= '0;
-        b_rdata_q  <= '0;
-        b_rerror_q <= '0;
-      end else begin
-        b_rvalid_q <= b_rvalid_d;
-        b_rdata_q  <= b_rdata_d;
-        // tie to zero if the read data is not valid
-        b_rerror_q <= b_rerror_d & {2{b_rvalid_d}};
-      end
-    end
-  end else begin : gen_dirconnect_output
-    assign a_rvalid_q = a_rvalid_d;
-    assign a_rdata_q  = a_rdata_d;
-    // tie to zero if the read data is not valid
-    assign a_rerror_q = a_rerror_d & {2{a_rvalid_d}};
-
-    assign b_rvalid_q = b_rvalid_d;
-    assign b_rdata_q  = b_rdata_d;
-    // tie to zero if the read data is not valid
-    assign b_rerror_q = b_rerror_d & {2{b_rvalid_d}};
-  end
-
-endmodule : prim_ram_2p_async_adv
diff --git a/prim_ram_2p_pkg.sv b/prim_ram_2p_pkg.sv
deleted file mode 100644
index 4ae04271..00000000
--- a/prim_ram_2p_pkg.sv
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-
-package prim_ram_2p_pkg;
-
-  typedef struct packed {
-    logic       cfg_en;
-    logic [3:0] cfg;
-  } cfg_t;
-
-  typedef struct packed {
-    cfg_t a_ram_fcfg;  // configuration for a port
-    cfg_t b_ram_fcfg;  // configuration for b port
-    cfg_t a_ram_lcfg;  // configuration for a port
-    cfg_t b_ram_lcfg;  // configuration for b port
-  } ram_2p_cfg_t;
-
-  parameter ram_2p_cfg_t RAM_2P_CFG_DEFAULT = '0;
-
-endpackage // prim_ram_2p_pkg
diff --git a/prim_reg_cdc.sv b/prim_reg_cdc.sv
deleted file mode 100644
index 3cc7ddbe..00000000
--- a/prim_reg_cdc.sv
+++ /dev/null
@@ -1,156 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Component handling register CDC
-
-`include "prim_assert.sv"
-
-module prim_reg_cdc #(
-  parameter int DataWidth = 32,
-  parameter logic [DataWidth-1:0] ResetVal = 32'h0,
-  parameter logic [DataWidth-1:0] BitMask = 32'hFFFFFFFF
-) (
-  input clk_src_i,
-  input rst_src_ni,
-  input clk_dst_i,
-  input rst_dst_ni,
-
-  input src_update_i,
-  input src_regwen_i,
-  input src_we_i,
-  input src_re_i,
-  input [DataWidth-1:0] src_wd_i,
-  output logic src_busy_o,
-  output logic [DataWidth-1:0] src_qs_o,
-  input  [DataWidth-1:0] dst_d_i,
-  output logic dst_we_o,
-  output logic dst_re_o,
-  output logic dst_regwen_o,
-  output logic [DataWidth-1:0] dst_wd_o
-);
-
-  ////////////////////////////
-  // Source domain
-  ////////////////////////////
-  localparam int TxnWidth = 3;
-
-  logic src_ack;
-  logic src_busy_q;
-  logic [DataWidth-1:0] src_q;
-  logic [TxnWidth-1:0] txn_bits_q;
-  logic src_req;
-
-  assign src_req = src_we_i | src_re_i;
-
-  // busy indication back-pressures upstream if the register is accessed
-  // again.  The busy indication is also used as a "commit" indication for
-  // resolving software and hardware write conflicts
-  always_ff @(posedge clk_src_i or negedge rst_src_ni) begin
-    if (!rst_src_ni) begin
-      src_busy_q <= '0;
-    end else if (src_req) begin
-      src_busy_q <= 1'b1;
-    end else if (src_busy_q && src_ack) begin
-      src_busy_q <= 1'b0;
-    end
-  end
-
-  assign src_busy_o = src_busy_q;
-
-  // src_q acts as both the write holding register and the software read back
-  // register.
-  // When software performs a write, the write data is captured in src_q for
-  // CDC purposes.  When not performing a write, the src_q periodically
-  // samples the destination domain using the src_update_i indication.
-  //
-  // To resolve software and hardware conflicts, the process is as follows:
-  // When software issues a write, this module asserts "busy".  While busy,
-  // src_q does not sample the destination value.  Since the
-  // logic has committed to updating based on software command, there is an irreversible
-  // window from which hardware writes are ignored.  Once the busy window completes,
-  // the cdc portion then begins sampling once more.
-  //
-  // This is consistent with prim_subreg_arb where during software / hardware conflicts,
-  // software is always prioritized.  The main difference is the conflict resolution window
-  // is now larger instead of just one destination clock cycle.
-
-  logic busy;
-  assign busy = src_busy_q & !src_ack;
-
-  always_ff @(posedge clk_src_i or negedge rst_src_ni) begin
-    if (!rst_src_ni) begin
-      src_q <= ResetVal;
-      txn_bits_q <= '0;
-    end else if (src_req && !busy) begin
-      src_q <= src_wd_i & BitMask;
-      txn_bits_q <= {src_we_i, src_re_i, src_regwen_i};
-    end else if (src_busy_q && src_ack || src_update_i && !busy) begin
-      // sample data whenever a busy transaction finishes OR
-      // when an update pulse is seen.
-      // TODO: We should add a cover group to test different sync timings
-      // between src_ack and src_update. Ie, there can be 3 scearios:
-      // 1. update one cycle before ack
-      // 2. ack one cycle before update
-      // 3. update / ack on the same cycle
-      // During all 3 cases the read data should be correct
-      src_q <= dst_d_i;
-      txn_bits_q <= '0;
-    end
-  end
-
-  // reserved bits are not used
-  logic unused_wd;
-  assign unused_wd = ^src_wd_i;
-
-  // src_q is always updated in the clk_src domain.
-  // when performing an update to the destination domain, it is guaranteed
-  // to not change by protocol.
-  assign src_qs_o = src_q;
-  assign dst_wd_o = src_q;
-
-  ////////////////////////////
-  // CDC handling
-  ////////////////////////////
-  logic dst_req;
-  prim_sync_reqack u_prim_sync (
-    .clk_src_i,
-    .rst_src_ni,
-    .clk_dst_i,
-    .rst_dst_ni,
-    .req_chk_i(1'b0),
-    // prim_sync_reqack does not natively handle single
-    // pulse requests, so use src_busy to even it out.
-    .src_req_i(src_req | src_busy_q),
-    .src_ack_o(src_ack),
-    .dst_req_o(dst_req),
-    // immediately ack on destination once request is seen
-    .dst_ack_i(dst_req)
-  );
-
-  // Each is valid only when destination request pulse is high
-  assign {dst_we_o, dst_re_o, dst_regwen_o} = txn_bits_q & {TxnWidth{dst_req}};
-
-  `ASSERT_KNOWN(SrcBusyKnown_A, src_busy_o, clk_src_i, !rst_src_ni)
-  `ASSERT_KNOWN(DstReqKnown_A, dst_req, clk_dst_i, !rst_dst_ni)
-
-  // If busy goes high, we must eventually see an ack
-  `ASSERT(HungHandShake_A, $rose(src_busy_o) |-> strong(##[0:$] src_ack), clk_src_i, !rst_src_ni)
-
-  `ifdef INC_ASSERT
-    logic async_flag;
-    always_ff @(posedge clk_src_i or negedge rst_src_ni) begin
-      if (!rst_src_ni) begin
-        async_flag <= '0;
-      end else if (src_req) begin
-        async_flag <= 1'b1;
-      end else if (dst_req) begin
-        async_flag <= '0;
-      end
-    end
-
-    `ASSERT(ReqTimeout_A, $rose(async_flag) |-> strong(##[0:3] dst_req), clk_dst_i, !rst_dst_ni)
-  `endif
-
-
-endmodule // prim_subreg_cdc
diff --git a/prim_rom_adv.sv b/prim_rom_adv.sv
deleted file mode 100644
index 1cfcf25a..00000000
--- a/prim_rom_adv.sv
+++ /dev/null
@@ -1,53 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// ROM wrapper with rvalid register
-
-`include "prim_assert.sv"
-
-module prim_rom_adv import prim_rom_pkg::*; #(
-  // Parameters passed on the the ROM primitive.
-  parameter  int Width       = 32,
-  parameter  int Depth       = 2048, // 8kB default
-  parameter      MemInitFile = "", // VMEM file to initialize the memory with
-
-  localparam int Aw          = $clog2(Depth)
-) (
-  input  logic             clk_i,
-  input  logic             rst_ni,
-  input  logic             req_i,
-  input  logic [Aw-1:0]    addr_i,
-  output logic             rvalid_o,
-  output logic [Width-1:0] rdata_o,
-
-  input rom_cfg_t          cfg_i
-);
-
-  prim_rom #(
-    .Width(Width),
-    .Depth(Depth),
-    .MemInitFile(MemInitFile)
-  ) u_prim_rom (
-    .clk_i,
-    .req_i,
-    .addr_i,
-    .rdata_o,
-    .cfg_i
-  );
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      rvalid_o <= 1'b0;
-    end else begin
-      rvalid_o <= req_i;
-    end
-  end
-
-  ////////////////
-  // ASSERTIONS //
-  ////////////////
-
-  // Control Signals should never be X
-  `ASSERT(noXOnCsI, !$isunknown(req_i), clk_i, '0)
-endmodule : prim_rom_adv
diff --git a/prim_rom_pkg.sv b/prim_rom_pkg.sv
deleted file mode 100644
index 1ac84ee0..00000000
--- a/prim_rom_pkg.sv
+++ /dev/null
@@ -1,15 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-
-package prim_rom_pkg;
-
-  typedef struct packed {
-    logic       cfg_en;
-    logic [3:0] cfg;
-  } rom_cfg_t;
-
-  parameter rom_cfg_t ROM_CFG_DEFAULT = '0;
-
-endpackage // prim_rom_pkg
diff --git a/prim_sec_anchor_buf.sv b/prim_sec_anchor_buf.sv
deleted file mode 100644
index 1ea71841..00000000
--- a/prim_sec_anchor_buf.sv
+++ /dev/null
@@ -1,21 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-
-`include "prim_assert.sv"
-
-module prim_sec_anchor_buf #(
-  parameter int Width = 1
-) (
-  input        [Width-1:0] in_i,
-  output logic [Width-1:0] out_o
-);
-
-  prim_buf #(
-    .Width(Width)
-  ) u_secure_anchor_buf (
-    .in_i,
-    .out_o
-  );
-
-endmodule
diff --git a/prim_sec_anchor_flop.sv b/prim_sec_anchor_flop.sv
deleted file mode 100644
index ce18b47d..00000000
--- a/prim_sec_anchor_flop.sv
+++ /dev/null
@@ -1,27 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-
-`include "prim_assert.sv"
-
-module prim_sec_anchor_flop #(
-  parameter int               Width      = 1,
-  parameter logic [Width-1:0] ResetValue = 0
-) (
-  input                    clk_i,
-  input                    rst_ni,
-  input        [Width-1:0] d_i,
-  output logic [Width-1:0] q_o
-);
-
-  prim_flop #(
-    .Width(Width),
-    .ResetValue(ResetValue)
-  ) u_secure_anchor_flop (
-    .clk_i,
-    .rst_ni,
-    .d_i,
-    .q_o
-  );
-
-endmodule
diff --git a/prim_secded_22_16_dec.sv b/prim_secded_22_16_dec.sv
deleted file mode 100644
index 4fa1196c..00000000
--- a/prim_secded_22_16_dec.sv
+++ /dev/null
@@ -1,45 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_22_16_dec (
-  input        [21:0] data_i,
-  output logic [15:0] data_o,
-  output logic [5:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 22'h01496E);
-    syndrome_o[1] = ^(data_i & 22'h02F20B);
-    syndrome_o[2] = ^(data_i & 22'h048ED8);
-    syndrome_o[3] = ^(data_i & 22'h087714);
-    syndrome_o[4] = ^(data_i & 22'h10ACA5);
-    syndrome_o[5] = ^(data_i & 22'h2011F3);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 6'h32) ^ data_i[0];
-    data_o[1] = (syndrome_o == 6'h23) ^ data_i[1];
-    data_o[2] = (syndrome_o == 6'h19) ^ data_i[2];
-    data_o[3] = (syndrome_o == 6'h7) ^ data_i[3];
-    data_o[4] = (syndrome_o == 6'h2c) ^ data_i[4];
-    data_o[5] = (syndrome_o == 6'h31) ^ data_i[5];
-    data_o[6] = (syndrome_o == 6'h25) ^ data_i[6];
-    data_o[7] = (syndrome_o == 6'h34) ^ data_i[7];
-    data_o[8] = (syndrome_o == 6'h29) ^ data_i[8];
-    data_o[9] = (syndrome_o == 6'he) ^ data_i[9];
-    data_o[10] = (syndrome_o == 6'h1c) ^ data_i[10];
-    data_o[11] = (syndrome_o == 6'h15) ^ data_i[11];
-    data_o[12] = (syndrome_o == 6'h2a) ^ data_i[12];
-    data_o[13] = (syndrome_o == 6'h1a) ^ data_i[13];
-    data_o[14] = (syndrome_o == 6'hb) ^ data_i[14];
-    data_o[15] = (syndrome_o == 6'h16) ^ data_i[15];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-  end
-endmodule : prim_secded_22_16_dec
diff --git a/prim_secded_22_16_enc.sv b/prim_secded_22_16_enc.sv
deleted file mode 100644
index 30cb1e85..00000000
--- a/prim_secded_22_16_enc.sv
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_22_16_enc (
-  input        [15:0] data_i,
-  output logic [21:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 22'(data_i);
-    data_o[16] = 1'b0 ^ ^(data_o & 22'h00496E);
-    data_o[17] = 1'b0 ^ ^(data_o & 22'h00F20B);
-    data_o[18] = 1'b0 ^ ^(data_o & 22'h008ED8);
-    data_o[19] = 1'b0 ^ ^(data_o & 22'h007714);
-    data_o[20] = 1'b0 ^ ^(data_o & 22'h00ACA5);
-    data_o[21] = 1'b0 ^ ^(data_o & 22'h0011F3);
-  end
-
-endmodule : prim_secded_22_16_enc
diff --git a/prim_secded_28_22_dec.sv b/prim_secded_28_22_dec.sv
deleted file mode 100644
index 7df02e24..00000000
--- a/prim_secded_28_22_dec.sv
+++ /dev/null
@@ -1,51 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_28_22_dec (
-  input        [27:0] data_i,
-  output logic [21:0] data_o,
-  output logic [5:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 28'h07003FF);
-    syndrome_o[1] = ^(data_i & 28'h090FC0F);
-    syndrome_o[2] = ^(data_i & 28'h1271C71);
-    syndrome_o[3] = ^(data_i & 28'h23B6592);
-    syndrome_o[4] = ^(data_i & 28'h43DAAA4);
-    syndrome_o[5] = ^(data_i & 28'h83ED348);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 6'h7) ^ data_i[0];
-    data_o[1] = (syndrome_o == 6'hb) ^ data_i[1];
-    data_o[2] = (syndrome_o == 6'h13) ^ data_i[2];
-    data_o[3] = (syndrome_o == 6'h23) ^ data_i[3];
-    data_o[4] = (syndrome_o == 6'hd) ^ data_i[4];
-    data_o[5] = (syndrome_o == 6'h15) ^ data_i[5];
-    data_o[6] = (syndrome_o == 6'h25) ^ data_i[6];
-    data_o[7] = (syndrome_o == 6'h19) ^ data_i[7];
-    data_o[8] = (syndrome_o == 6'h29) ^ data_i[8];
-    data_o[9] = (syndrome_o == 6'h31) ^ data_i[9];
-    data_o[10] = (syndrome_o == 6'he) ^ data_i[10];
-    data_o[11] = (syndrome_o == 6'h16) ^ data_i[11];
-    data_o[12] = (syndrome_o == 6'h26) ^ data_i[12];
-    data_o[13] = (syndrome_o == 6'h1a) ^ data_i[13];
-    data_o[14] = (syndrome_o == 6'h2a) ^ data_i[14];
-    data_o[15] = (syndrome_o == 6'h32) ^ data_i[15];
-    data_o[16] = (syndrome_o == 6'h1c) ^ data_i[16];
-    data_o[17] = (syndrome_o == 6'h2c) ^ data_i[17];
-    data_o[18] = (syndrome_o == 6'h34) ^ data_i[18];
-    data_o[19] = (syndrome_o == 6'h38) ^ data_i[19];
-    data_o[20] = (syndrome_o == 6'h3b) ^ data_i[20];
-    data_o[21] = (syndrome_o == 6'h3d) ^ data_i[21];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-  end
-endmodule : prim_secded_28_22_dec
diff --git a/prim_secded_28_22_enc.sv b/prim_secded_28_22_enc.sv
deleted file mode 100644
index fcb3cead..00000000
--- a/prim_secded_28_22_enc.sv
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_28_22_enc (
-  input        [21:0] data_i,
-  output logic [27:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 28'(data_i);
-    data_o[22] = 1'b0 ^ ^(data_o & 28'h03003FF);
-    data_o[23] = 1'b0 ^ ^(data_o & 28'h010FC0F);
-    data_o[24] = 1'b0 ^ ^(data_o & 28'h0271C71);
-    data_o[25] = 1'b0 ^ ^(data_o & 28'h03B6592);
-    data_o[26] = 1'b0 ^ ^(data_o & 28'h03DAAA4);
-    data_o[27] = 1'b0 ^ ^(data_o & 28'h03ED348);
-  end
-
-endmodule : prim_secded_28_22_enc
diff --git a/prim_secded_39_32_dec.sv b/prim_secded_39_32_dec.sv
deleted file mode 100644
index 10ee733e..00000000
--- a/prim_secded_39_32_dec.sv
+++ /dev/null
@@ -1,62 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_39_32_dec (
-  input        [38:0] data_i,
-  output logic [31:0] data_o,
-  output logic [6:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 39'h012606BD25);
-    syndrome_o[1] = ^(data_i & 39'h02DEBA8050);
-    syndrome_o[2] = ^(data_i & 39'h04413D89AA);
-    syndrome_o[3] = ^(data_i & 39'h0831234ED1);
-    syndrome_o[4] = ^(data_i & 39'h10C2C1323B);
-    syndrome_o[5] = ^(data_i & 39'h202DCC624C);
-    syndrome_o[6] = ^(data_i & 39'h4098505586);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 7'h19) ^ data_i[0];
-    data_o[1] = (syndrome_o == 7'h54) ^ data_i[1];
-    data_o[2] = (syndrome_o == 7'h61) ^ data_i[2];
-    data_o[3] = (syndrome_o == 7'h34) ^ data_i[3];
-    data_o[4] = (syndrome_o == 7'h1a) ^ data_i[4];
-    data_o[5] = (syndrome_o == 7'h15) ^ data_i[5];
-    data_o[6] = (syndrome_o == 7'h2a) ^ data_i[6];
-    data_o[7] = (syndrome_o == 7'h4c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 7'h45) ^ data_i[8];
-    data_o[9] = (syndrome_o == 7'h38) ^ data_i[9];
-    data_o[10] = (syndrome_o == 7'h49) ^ data_i[10];
-    data_o[11] = (syndrome_o == 7'hd) ^ data_i[11];
-    data_o[12] = (syndrome_o == 7'h51) ^ data_i[12];
-    data_o[13] = (syndrome_o == 7'h31) ^ data_i[13];
-    data_o[14] = (syndrome_o == 7'h68) ^ data_i[14];
-    data_o[15] = (syndrome_o == 7'h7) ^ data_i[15];
-    data_o[16] = (syndrome_o == 7'h1c) ^ data_i[16];
-    data_o[17] = (syndrome_o == 7'hb) ^ data_i[17];
-    data_o[18] = (syndrome_o == 7'h25) ^ data_i[18];
-    data_o[19] = (syndrome_o == 7'h26) ^ data_i[19];
-    data_o[20] = (syndrome_o == 7'h46) ^ data_i[20];
-    data_o[21] = (syndrome_o == 7'he) ^ data_i[21];
-    data_o[22] = (syndrome_o == 7'h70) ^ data_i[22];
-    data_o[23] = (syndrome_o == 7'h32) ^ data_i[23];
-    data_o[24] = (syndrome_o == 7'h2c) ^ data_i[24];
-    data_o[25] = (syndrome_o == 7'h13) ^ data_i[25];
-    data_o[26] = (syndrome_o == 7'h23) ^ data_i[26];
-    data_o[27] = (syndrome_o == 7'h62) ^ data_i[27];
-    data_o[28] = (syndrome_o == 7'h4a) ^ data_i[28];
-    data_o[29] = (syndrome_o == 7'h29) ^ data_i[29];
-    data_o[30] = (syndrome_o == 7'h16) ^ data_i[30];
-    data_o[31] = (syndrome_o == 7'h52) ^ data_i[31];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-  end
-endmodule : prim_secded_39_32_dec
diff --git a/prim_secded_39_32_enc.sv b/prim_secded_39_32_enc.sv
deleted file mode 100644
index e26068e9..00000000
--- a/prim_secded_39_32_enc.sv
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_39_32_enc (
-  input        [31:0] data_i,
-  output logic [38:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 39'(data_i);
-    data_o[32] = 1'b0 ^ ^(data_o & 39'h002606BD25);
-    data_o[33] = 1'b0 ^ ^(data_o & 39'h00DEBA8050);
-    data_o[34] = 1'b0 ^ ^(data_o & 39'h00413D89AA);
-    data_o[35] = 1'b0 ^ ^(data_o & 39'h0031234ED1);
-    data_o[36] = 1'b0 ^ ^(data_o & 39'h00C2C1323B);
-    data_o[37] = 1'b0 ^ ^(data_o & 39'h002DCC624C);
-    data_o[38] = 1'b0 ^ ^(data_o & 39'h0098505586);
-  end
-
-endmodule : prim_secded_39_32_enc
diff --git a/prim_secded_64_57_dec.sv b/prim_secded_64_57_dec.sv
deleted file mode 100644
index dc1fd426..00000000
--- a/prim_secded_64_57_dec.sv
+++ /dev/null
@@ -1,87 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_64_57_dec (
-  input        [63:0] data_i,
-  output logic [56:0] data_o,
-  output logic [6:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 64'h0303FFF800007FFF);
-    syndrome_o[1] = ^(data_i & 64'h057C1FF801FF801F);
-    syndrome_o[2] = ^(data_i & 64'h09BDE1F87E0781E1);
-    syndrome_o[3] = ^(data_i & 64'h11DEEE3B8E388E22);
-    syndrome_o[4] = ^(data_i & 64'h21EF76CDB2C93244);
-    syndrome_o[5] = ^(data_i & 64'h41F7BB56D5525488);
-    syndrome_o[6] = ^(data_i & 64'h81FBDDA769A46910);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 7'h7) ^ data_i[0];
-    data_o[1] = (syndrome_o == 7'hb) ^ data_i[1];
-    data_o[2] = (syndrome_o == 7'h13) ^ data_i[2];
-    data_o[3] = (syndrome_o == 7'h23) ^ data_i[3];
-    data_o[4] = (syndrome_o == 7'h43) ^ data_i[4];
-    data_o[5] = (syndrome_o == 7'hd) ^ data_i[5];
-    data_o[6] = (syndrome_o == 7'h15) ^ data_i[6];
-    data_o[7] = (syndrome_o == 7'h25) ^ data_i[7];
-    data_o[8] = (syndrome_o == 7'h45) ^ data_i[8];
-    data_o[9] = (syndrome_o == 7'h19) ^ data_i[9];
-    data_o[10] = (syndrome_o == 7'h29) ^ data_i[10];
-    data_o[11] = (syndrome_o == 7'h49) ^ data_i[11];
-    data_o[12] = (syndrome_o == 7'h31) ^ data_i[12];
-    data_o[13] = (syndrome_o == 7'h51) ^ data_i[13];
-    data_o[14] = (syndrome_o == 7'h61) ^ data_i[14];
-    data_o[15] = (syndrome_o == 7'he) ^ data_i[15];
-    data_o[16] = (syndrome_o == 7'h16) ^ data_i[16];
-    data_o[17] = (syndrome_o == 7'h26) ^ data_i[17];
-    data_o[18] = (syndrome_o == 7'h46) ^ data_i[18];
-    data_o[19] = (syndrome_o == 7'h1a) ^ data_i[19];
-    data_o[20] = (syndrome_o == 7'h2a) ^ data_i[20];
-    data_o[21] = (syndrome_o == 7'h4a) ^ data_i[21];
-    data_o[22] = (syndrome_o == 7'h32) ^ data_i[22];
-    data_o[23] = (syndrome_o == 7'h52) ^ data_i[23];
-    data_o[24] = (syndrome_o == 7'h62) ^ data_i[24];
-    data_o[25] = (syndrome_o == 7'h1c) ^ data_i[25];
-    data_o[26] = (syndrome_o == 7'h2c) ^ data_i[26];
-    data_o[27] = (syndrome_o == 7'h4c) ^ data_i[27];
-    data_o[28] = (syndrome_o == 7'h34) ^ data_i[28];
-    data_o[29] = (syndrome_o == 7'h54) ^ data_i[29];
-    data_o[30] = (syndrome_o == 7'h64) ^ data_i[30];
-    data_o[31] = (syndrome_o == 7'h38) ^ data_i[31];
-    data_o[32] = (syndrome_o == 7'h58) ^ data_i[32];
-    data_o[33] = (syndrome_o == 7'h68) ^ data_i[33];
-    data_o[34] = (syndrome_o == 7'h70) ^ data_i[34];
-    data_o[35] = (syndrome_o == 7'h1f) ^ data_i[35];
-    data_o[36] = (syndrome_o == 7'h2f) ^ data_i[36];
-    data_o[37] = (syndrome_o == 7'h4f) ^ data_i[37];
-    data_o[38] = (syndrome_o == 7'h37) ^ data_i[38];
-    data_o[39] = (syndrome_o == 7'h57) ^ data_i[39];
-    data_o[40] = (syndrome_o == 7'h67) ^ data_i[40];
-    data_o[41] = (syndrome_o == 7'h3b) ^ data_i[41];
-    data_o[42] = (syndrome_o == 7'h5b) ^ data_i[42];
-    data_o[43] = (syndrome_o == 7'h6b) ^ data_i[43];
-    data_o[44] = (syndrome_o == 7'h73) ^ data_i[44];
-    data_o[45] = (syndrome_o == 7'h3d) ^ data_i[45];
-    data_o[46] = (syndrome_o == 7'h5d) ^ data_i[46];
-    data_o[47] = (syndrome_o == 7'h6d) ^ data_i[47];
-    data_o[48] = (syndrome_o == 7'h75) ^ data_i[48];
-    data_o[49] = (syndrome_o == 7'h79) ^ data_i[49];
-    data_o[50] = (syndrome_o == 7'h3e) ^ data_i[50];
-    data_o[51] = (syndrome_o == 7'h5e) ^ data_i[51];
-    data_o[52] = (syndrome_o == 7'h6e) ^ data_i[52];
-    data_o[53] = (syndrome_o == 7'h76) ^ data_i[53];
-    data_o[54] = (syndrome_o == 7'h7a) ^ data_i[54];
-    data_o[55] = (syndrome_o == 7'h7c) ^ data_i[55];
-    data_o[56] = (syndrome_o == 7'h7f) ^ data_i[56];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-  end
-endmodule : prim_secded_64_57_dec
diff --git a/prim_secded_64_57_enc.sv b/prim_secded_64_57_enc.sv
deleted file mode 100644
index 448cf02e..00000000
--- a/prim_secded_64_57_enc.sv
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_64_57_enc (
-  input        [56:0] data_i,
-  output logic [63:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 64'(data_i);
-    data_o[57] = 1'b0 ^ ^(data_o & 64'h0103FFF800007FFF);
-    data_o[58] = 1'b0 ^ ^(data_o & 64'h017C1FF801FF801F);
-    data_o[59] = 1'b0 ^ ^(data_o & 64'h01BDE1F87E0781E1);
-    data_o[60] = 1'b0 ^ ^(data_o & 64'h01DEEE3B8E388E22);
-    data_o[61] = 1'b0 ^ ^(data_o & 64'h01EF76CDB2C93244);
-    data_o[62] = 1'b0 ^ ^(data_o & 64'h01F7BB56D5525488);
-    data_o[63] = 1'b0 ^ ^(data_o & 64'h01FBDDA769A46910);
-  end
-
-endmodule : prim_secded_64_57_enc
diff --git a/prim_secded_72_64_dec.sv b/prim_secded_72_64_dec.sv
deleted file mode 100644
index 112a64fd..00000000
--- a/prim_secded_72_64_dec.sv
+++ /dev/null
@@ -1,95 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_72_64_dec (
-  input        [71:0] data_i,
-  output logic [63:0] data_o,
-  output logic [7:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 72'h01B9000000001FFFFF);
-    syndrome_o[1] = ^(data_i & 72'h025E00000FFFE0003F);
-    syndrome_o[2] = ^(data_i & 72'h0467003FF003E007C1);
-    syndrome_o[3] = ^(data_i & 72'h08CD0FC0F03C207842);
-    syndrome_o[4] = ^(data_i & 72'h10B671C711C4438884);
-    syndrome_o[5] = ^(data_i & 72'h20B5B65926488C9108);
-    syndrome_o[6] = ^(data_i & 72'h40CBDAAA4A91152210);
-    syndrome_o[7] = ^(data_i & 72'h807AED348D221A4420);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 8'h7) ^ data_i[0];
-    data_o[1] = (syndrome_o == 8'hb) ^ data_i[1];
-    data_o[2] = (syndrome_o == 8'h13) ^ data_i[2];
-    data_o[3] = (syndrome_o == 8'h23) ^ data_i[3];
-    data_o[4] = (syndrome_o == 8'h43) ^ data_i[4];
-    data_o[5] = (syndrome_o == 8'h83) ^ data_i[5];
-    data_o[6] = (syndrome_o == 8'hd) ^ data_i[6];
-    data_o[7] = (syndrome_o == 8'h15) ^ data_i[7];
-    data_o[8] = (syndrome_o == 8'h25) ^ data_i[8];
-    data_o[9] = (syndrome_o == 8'h45) ^ data_i[9];
-    data_o[10] = (syndrome_o == 8'h85) ^ data_i[10];
-    data_o[11] = (syndrome_o == 8'h19) ^ data_i[11];
-    data_o[12] = (syndrome_o == 8'h29) ^ data_i[12];
-    data_o[13] = (syndrome_o == 8'h49) ^ data_i[13];
-    data_o[14] = (syndrome_o == 8'h89) ^ data_i[14];
-    data_o[15] = (syndrome_o == 8'h31) ^ data_i[15];
-    data_o[16] = (syndrome_o == 8'h51) ^ data_i[16];
-    data_o[17] = (syndrome_o == 8'h91) ^ data_i[17];
-    data_o[18] = (syndrome_o == 8'h61) ^ data_i[18];
-    data_o[19] = (syndrome_o == 8'ha1) ^ data_i[19];
-    data_o[20] = (syndrome_o == 8'hc1) ^ data_i[20];
-    data_o[21] = (syndrome_o == 8'he) ^ data_i[21];
-    data_o[22] = (syndrome_o == 8'h16) ^ data_i[22];
-    data_o[23] = (syndrome_o == 8'h26) ^ data_i[23];
-    data_o[24] = (syndrome_o == 8'h46) ^ data_i[24];
-    data_o[25] = (syndrome_o == 8'h86) ^ data_i[25];
-    data_o[26] = (syndrome_o == 8'h1a) ^ data_i[26];
-    data_o[27] = (syndrome_o == 8'h2a) ^ data_i[27];
-    data_o[28] = (syndrome_o == 8'h4a) ^ data_i[28];
-    data_o[29] = (syndrome_o == 8'h8a) ^ data_i[29];
-    data_o[30] = (syndrome_o == 8'h32) ^ data_i[30];
-    data_o[31] = (syndrome_o == 8'h52) ^ data_i[31];
-    data_o[32] = (syndrome_o == 8'h92) ^ data_i[32];
-    data_o[33] = (syndrome_o == 8'h62) ^ data_i[33];
-    data_o[34] = (syndrome_o == 8'ha2) ^ data_i[34];
-    data_o[35] = (syndrome_o == 8'hc2) ^ data_i[35];
-    data_o[36] = (syndrome_o == 8'h1c) ^ data_i[36];
-    data_o[37] = (syndrome_o == 8'h2c) ^ data_i[37];
-    data_o[38] = (syndrome_o == 8'h4c) ^ data_i[38];
-    data_o[39] = (syndrome_o == 8'h8c) ^ data_i[39];
-    data_o[40] = (syndrome_o == 8'h34) ^ data_i[40];
-    data_o[41] = (syndrome_o == 8'h54) ^ data_i[41];
-    data_o[42] = (syndrome_o == 8'h94) ^ data_i[42];
-    data_o[43] = (syndrome_o == 8'h64) ^ data_i[43];
-    data_o[44] = (syndrome_o == 8'ha4) ^ data_i[44];
-    data_o[45] = (syndrome_o == 8'hc4) ^ data_i[45];
-    data_o[46] = (syndrome_o == 8'h38) ^ data_i[46];
-    data_o[47] = (syndrome_o == 8'h58) ^ data_i[47];
-    data_o[48] = (syndrome_o == 8'h98) ^ data_i[48];
-    data_o[49] = (syndrome_o == 8'h68) ^ data_i[49];
-    data_o[50] = (syndrome_o == 8'ha8) ^ data_i[50];
-    data_o[51] = (syndrome_o == 8'hc8) ^ data_i[51];
-    data_o[52] = (syndrome_o == 8'h70) ^ data_i[52];
-    data_o[53] = (syndrome_o == 8'hb0) ^ data_i[53];
-    data_o[54] = (syndrome_o == 8'hd0) ^ data_i[54];
-    data_o[55] = (syndrome_o == 8'he0) ^ data_i[55];
-    data_o[56] = (syndrome_o == 8'h6d) ^ data_i[56];
-    data_o[57] = (syndrome_o == 8'hd6) ^ data_i[57];
-    data_o[58] = (syndrome_o == 8'h3e) ^ data_i[58];
-    data_o[59] = (syndrome_o == 8'hcb) ^ data_i[59];
-    data_o[60] = (syndrome_o == 8'hb3) ^ data_i[60];
-    data_o[61] = (syndrome_o == 8'hb5) ^ data_i[61];
-    data_o[62] = (syndrome_o == 8'hce) ^ data_i[62];
-    data_o[63] = (syndrome_o == 8'h79) ^ data_i[63];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-  end
-endmodule : prim_secded_72_64_dec
diff --git a/prim_secded_72_64_enc.sv b/prim_secded_72_64_enc.sv
deleted file mode 100644
index 29b1f692..00000000
--- a/prim_secded_72_64_enc.sv
+++ /dev/null
@@ -1,24 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_72_64_enc (
-  input        [63:0] data_i,
-  output logic [71:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 72'(data_i);
-    data_o[64] = 1'b0 ^ ^(data_o & 72'h00B9000000001FFFFF);
-    data_o[65] = 1'b0 ^ ^(data_o & 72'h005E00000FFFE0003F);
-    data_o[66] = 1'b0 ^ ^(data_o & 72'h0067003FF003E007C1);
-    data_o[67] = 1'b0 ^ ^(data_o & 72'h00CD0FC0F03C207842);
-    data_o[68] = 1'b0 ^ ^(data_o & 72'h00B671C711C4438884);
-    data_o[69] = 1'b0 ^ ^(data_o & 72'h00B5B65926488C9108);
-    data_o[70] = 1'b0 ^ ^(data_o & 72'h00CBDAAA4A91152210);
-    data_o[71] = 1'b0 ^ ^(data_o & 72'h007AED348D221A4420);
-  end
-
-endmodule : prim_secded_72_64_enc
diff --git a/prim_secded_hamming_22_16_dec.sv b/prim_secded_hamming_22_16_dec.sv
deleted file mode 100644
index 135dc2fd..00000000
--- a/prim_secded_hamming_22_16_dec.sv
+++ /dev/null
@@ -1,45 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_hamming_22_16_dec (
-  input        [21:0] data_i,
-  output logic [15:0] data_o,
-  output logic [5:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 22'h01AD5B);
-    syndrome_o[1] = ^(data_i & 22'h02366D);
-    syndrome_o[2] = ^(data_i & 22'h04C78E);
-    syndrome_o[3] = ^(data_i & 22'h0807F0);
-    syndrome_o[4] = ^(data_i & 22'h10F800);
-    syndrome_o[5] = ^(data_i & 22'h3FFFFF);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 6'h23) ^ data_i[0];
-    data_o[1] = (syndrome_o == 6'h25) ^ data_i[1];
-    data_o[2] = (syndrome_o == 6'h26) ^ data_i[2];
-    data_o[3] = (syndrome_o == 6'h27) ^ data_i[3];
-    data_o[4] = (syndrome_o == 6'h29) ^ data_i[4];
-    data_o[5] = (syndrome_o == 6'h2a) ^ data_i[5];
-    data_o[6] = (syndrome_o == 6'h2b) ^ data_i[6];
-    data_o[7] = (syndrome_o == 6'h2c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 6'h2d) ^ data_i[8];
-    data_o[9] = (syndrome_o == 6'h2e) ^ data_i[9];
-    data_o[10] = (syndrome_o == 6'h2f) ^ data_i[10];
-    data_o[11] = (syndrome_o == 6'h31) ^ data_i[11];
-    data_o[12] = (syndrome_o == 6'h32) ^ data_i[12];
-    data_o[13] = (syndrome_o == 6'h33) ^ data_i[13];
-    data_o[14] = (syndrome_o == 6'h34) ^ data_i[14];
-    data_o[15] = (syndrome_o == 6'h35) ^ data_i[15];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = syndrome_o[5];
-    err_o[1] = |syndrome_o[4:0] & ~syndrome_o[5];
-  end
-endmodule : prim_secded_hamming_22_16_dec
diff --git a/prim_secded_hamming_22_16_enc.sv b/prim_secded_hamming_22_16_enc.sv
deleted file mode 100644
index 07cb5cf5..00000000
--- a/prim_secded_hamming_22_16_enc.sv
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_hamming_22_16_enc (
-  input        [15:0] data_i,
-  output logic [21:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 22'(data_i);
-    data_o[16] = 1'b0 ^ ^(data_o & 22'h00AD5B);
-    data_o[17] = 1'b0 ^ ^(data_o & 22'h00366D);
-    data_o[18] = 1'b0 ^ ^(data_o & 22'h00C78E);
-    data_o[19] = 1'b0 ^ ^(data_o & 22'h0007F0);
-    data_o[20] = 1'b0 ^ ^(data_o & 22'h00F800);
-    data_o[21] = 1'b0 ^ ^(data_o & 22'h1FFFFF);
-  end
-
-endmodule : prim_secded_hamming_22_16_enc
diff --git a/prim_secded_hamming_39_32_dec.sv b/prim_secded_hamming_39_32_dec.sv
deleted file mode 100644
index 1f41364f..00000000
--- a/prim_secded_hamming_39_32_dec.sv
+++ /dev/null
@@ -1,62 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_hamming_39_32_dec (
-  input        [38:0] data_i,
-  output logic [31:0] data_o,
-  output logic [6:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 39'h0156AAAD5B);
-    syndrome_o[1] = ^(data_i & 39'h029B33366D);
-    syndrome_o[2] = ^(data_i & 39'h04E3C3C78E);
-    syndrome_o[3] = ^(data_i & 39'h0803FC07F0);
-    syndrome_o[4] = ^(data_i & 39'h1003FFF800);
-    syndrome_o[5] = ^(data_i & 39'h20FC000000);
-    syndrome_o[6] = ^(data_i & 39'h7FFFFFFFFF);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 7'h43) ^ data_i[0];
-    data_o[1] = (syndrome_o == 7'h45) ^ data_i[1];
-    data_o[2] = (syndrome_o == 7'h46) ^ data_i[2];
-    data_o[3] = (syndrome_o == 7'h47) ^ data_i[3];
-    data_o[4] = (syndrome_o == 7'h49) ^ data_i[4];
-    data_o[5] = (syndrome_o == 7'h4a) ^ data_i[5];
-    data_o[6] = (syndrome_o == 7'h4b) ^ data_i[6];
-    data_o[7] = (syndrome_o == 7'h4c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 7'h4d) ^ data_i[8];
-    data_o[9] = (syndrome_o == 7'h4e) ^ data_i[9];
-    data_o[10] = (syndrome_o == 7'h4f) ^ data_i[10];
-    data_o[11] = (syndrome_o == 7'h51) ^ data_i[11];
-    data_o[12] = (syndrome_o == 7'h52) ^ data_i[12];
-    data_o[13] = (syndrome_o == 7'h53) ^ data_i[13];
-    data_o[14] = (syndrome_o == 7'h54) ^ data_i[14];
-    data_o[15] = (syndrome_o == 7'h55) ^ data_i[15];
-    data_o[16] = (syndrome_o == 7'h56) ^ data_i[16];
-    data_o[17] = (syndrome_o == 7'h57) ^ data_i[17];
-    data_o[18] = (syndrome_o == 7'h58) ^ data_i[18];
-    data_o[19] = (syndrome_o == 7'h59) ^ data_i[19];
-    data_o[20] = (syndrome_o == 7'h5a) ^ data_i[20];
-    data_o[21] = (syndrome_o == 7'h5b) ^ data_i[21];
-    data_o[22] = (syndrome_o == 7'h5c) ^ data_i[22];
-    data_o[23] = (syndrome_o == 7'h5d) ^ data_i[23];
-    data_o[24] = (syndrome_o == 7'h5e) ^ data_i[24];
-    data_o[25] = (syndrome_o == 7'h5f) ^ data_i[25];
-    data_o[26] = (syndrome_o == 7'h61) ^ data_i[26];
-    data_o[27] = (syndrome_o == 7'h62) ^ data_i[27];
-    data_o[28] = (syndrome_o == 7'h63) ^ data_i[28];
-    data_o[29] = (syndrome_o == 7'h64) ^ data_i[29];
-    data_o[30] = (syndrome_o == 7'h65) ^ data_i[30];
-    data_o[31] = (syndrome_o == 7'h66) ^ data_i[31];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = syndrome_o[6];
-    err_o[1] = |syndrome_o[5:0] & ~syndrome_o[6];
-  end
-endmodule : prim_secded_hamming_39_32_dec
diff --git a/prim_secded_hamming_39_32_enc.sv b/prim_secded_hamming_39_32_enc.sv
deleted file mode 100644
index c3dd434a..00000000
--- a/prim_secded_hamming_39_32_enc.sv
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_hamming_39_32_enc (
-  input        [31:0] data_i,
-  output logic [38:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 39'(data_i);
-    data_o[32] = 1'b0 ^ ^(data_o & 39'h0056AAAD5B);
-    data_o[33] = 1'b0 ^ ^(data_o & 39'h009B33366D);
-    data_o[34] = 1'b0 ^ ^(data_o & 39'h00E3C3C78E);
-    data_o[35] = 1'b0 ^ ^(data_o & 39'h0003FC07F0);
-    data_o[36] = 1'b0 ^ ^(data_o & 39'h0003FFF800);
-    data_o[37] = 1'b0 ^ ^(data_o & 39'h00FC000000);
-    data_o[38] = 1'b0 ^ ^(data_o & 39'h3FFFFFFFFF);
-  end
-
-endmodule : prim_secded_hamming_39_32_enc
diff --git a/prim_secded_hamming_72_64_dec.sv b/prim_secded_hamming_72_64_dec.sv
deleted file mode 100644
index 7eaaa40d..00000000
--- a/prim_secded_hamming_72_64_dec.sv
+++ /dev/null
@@ -1,95 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_hamming_72_64_dec (
-  input        [71:0] data_i,
-  output logic [63:0] data_o,
-  output logic [7:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 72'h01AB55555556AAAD5B);
-    syndrome_o[1] = ^(data_i & 72'h02CD9999999B33366D);
-    syndrome_o[2] = ^(data_i & 72'h04F1E1E1E1E3C3C78E);
-    syndrome_o[3] = ^(data_i & 72'h0801FE01FE03FC07F0);
-    syndrome_o[4] = ^(data_i & 72'h1001FFFE0003FFF800);
-    syndrome_o[5] = ^(data_i & 72'h2001FFFFFFFC000000);
-    syndrome_o[6] = ^(data_i & 72'h40FE00000000000000);
-    syndrome_o[7] = ^(data_i & 72'hFFFFFFFFFFFFFFFFFF);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 8'h83) ^ data_i[0];
-    data_o[1] = (syndrome_o == 8'h85) ^ data_i[1];
-    data_o[2] = (syndrome_o == 8'h86) ^ data_i[2];
-    data_o[3] = (syndrome_o == 8'h87) ^ data_i[3];
-    data_o[4] = (syndrome_o == 8'h89) ^ data_i[4];
-    data_o[5] = (syndrome_o == 8'h8a) ^ data_i[5];
-    data_o[6] = (syndrome_o == 8'h8b) ^ data_i[6];
-    data_o[7] = (syndrome_o == 8'h8c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 8'h8d) ^ data_i[8];
-    data_o[9] = (syndrome_o == 8'h8e) ^ data_i[9];
-    data_o[10] = (syndrome_o == 8'h8f) ^ data_i[10];
-    data_o[11] = (syndrome_o == 8'h91) ^ data_i[11];
-    data_o[12] = (syndrome_o == 8'h92) ^ data_i[12];
-    data_o[13] = (syndrome_o == 8'h93) ^ data_i[13];
-    data_o[14] = (syndrome_o == 8'h94) ^ data_i[14];
-    data_o[15] = (syndrome_o == 8'h95) ^ data_i[15];
-    data_o[16] = (syndrome_o == 8'h96) ^ data_i[16];
-    data_o[17] = (syndrome_o == 8'h97) ^ data_i[17];
-    data_o[18] = (syndrome_o == 8'h98) ^ data_i[18];
-    data_o[19] = (syndrome_o == 8'h99) ^ data_i[19];
-    data_o[20] = (syndrome_o == 8'h9a) ^ data_i[20];
-    data_o[21] = (syndrome_o == 8'h9b) ^ data_i[21];
-    data_o[22] = (syndrome_o == 8'h9c) ^ data_i[22];
-    data_o[23] = (syndrome_o == 8'h9d) ^ data_i[23];
-    data_o[24] = (syndrome_o == 8'h9e) ^ data_i[24];
-    data_o[25] = (syndrome_o == 8'h9f) ^ data_i[25];
-    data_o[26] = (syndrome_o == 8'ha1) ^ data_i[26];
-    data_o[27] = (syndrome_o == 8'ha2) ^ data_i[27];
-    data_o[28] = (syndrome_o == 8'ha3) ^ data_i[28];
-    data_o[29] = (syndrome_o == 8'ha4) ^ data_i[29];
-    data_o[30] = (syndrome_o == 8'ha5) ^ data_i[30];
-    data_o[31] = (syndrome_o == 8'ha6) ^ data_i[31];
-    data_o[32] = (syndrome_o == 8'ha7) ^ data_i[32];
-    data_o[33] = (syndrome_o == 8'ha8) ^ data_i[33];
-    data_o[34] = (syndrome_o == 8'ha9) ^ data_i[34];
-    data_o[35] = (syndrome_o == 8'haa) ^ data_i[35];
-    data_o[36] = (syndrome_o == 8'hab) ^ data_i[36];
-    data_o[37] = (syndrome_o == 8'hac) ^ data_i[37];
-    data_o[38] = (syndrome_o == 8'had) ^ data_i[38];
-    data_o[39] = (syndrome_o == 8'hae) ^ data_i[39];
-    data_o[40] = (syndrome_o == 8'haf) ^ data_i[40];
-    data_o[41] = (syndrome_o == 8'hb0) ^ data_i[41];
-    data_o[42] = (syndrome_o == 8'hb1) ^ data_i[42];
-    data_o[43] = (syndrome_o == 8'hb2) ^ data_i[43];
-    data_o[44] = (syndrome_o == 8'hb3) ^ data_i[44];
-    data_o[45] = (syndrome_o == 8'hb4) ^ data_i[45];
-    data_o[46] = (syndrome_o == 8'hb5) ^ data_i[46];
-    data_o[47] = (syndrome_o == 8'hb6) ^ data_i[47];
-    data_o[48] = (syndrome_o == 8'hb7) ^ data_i[48];
-    data_o[49] = (syndrome_o == 8'hb8) ^ data_i[49];
-    data_o[50] = (syndrome_o == 8'hb9) ^ data_i[50];
-    data_o[51] = (syndrome_o == 8'hba) ^ data_i[51];
-    data_o[52] = (syndrome_o == 8'hbb) ^ data_i[52];
-    data_o[53] = (syndrome_o == 8'hbc) ^ data_i[53];
-    data_o[54] = (syndrome_o == 8'hbd) ^ data_i[54];
-    data_o[55] = (syndrome_o == 8'hbe) ^ data_i[55];
-    data_o[56] = (syndrome_o == 8'hbf) ^ data_i[56];
-    data_o[57] = (syndrome_o == 8'hc1) ^ data_i[57];
-    data_o[58] = (syndrome_o == 8'hc2) ^ data_i[58];
-    data_o[59] = (syndrome_o == 8'hc3) ^ data_i[59];
-    data_o[60] = (syndrome_o == 8'hc4) ^ data_i[60];
-    data_o[61] = (syndrome_o == 8'hc5) ^ data_i[61];
-    data_o[62] = (syndrome_o == 8'hc6) ^ data_i[62];
-    data_o[63] = (syndrome_o == 8'hc7) ^ data_i[63];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = syndrome_o[7];
-    err_o[1] = |syndrome_o[6:0] & ~syndrome_o[7];
-  end
-endmodule : prim_secded_hamming_72_64_dec
diff --git a/prim_secded_hamming_72_64_enc.sv b/prim_secded_hamming_72_64_enc.sv
deleted file mode 100644
index c95181cd..00000000
--- a/prim_secded_hamming_72_64_enc.sv
+++ /dev/null
@@ -1,24 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_hamming_72_64_enc (
-  input        [63:0] data_i,
-  output logic [71:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 72'(data_i);
-    data_o[64] = 1'b0 ^ ^(data_o & 72'h00AB55555556AAAD5B);
-    data_o[65] = 1'b0 ^ ^(data_o & 72'h00CD9999999B33366D);
-    data_o[66] = 1'b0 ^ ^(data_o & 72'h00F1E1E1E1E3C3C78E);
-    data_o[67] = 1'b0 ^ ^(data_o & 72'h0001FE01FE03FC07F0);
-    data_o[68] = 1'b0 ^ ^(data_o & 72'h0001FFFE0003FFF800);
-    data_o[69] = 1'b0 ^ ^(data_o & 72'h0001FFFFFFFC000000);
-    data_o[70] = 1'b0 ^ ^(data_o & 72'h00FE00000000000000);
-    data_o[71] = 1'b0 ^ ^(data_o & 72'h7FFFFFFFFFFFFFFFFF);
-  end
-
-endmodule : prim_secded_hamming_72_64_enc
diff --git a/prim_secded_hamming_76_68_dec.sv b/prim_secded_hamming_76_68_dec.sv
deleted file mode 100644
index 418a2331..00000000
--- a/prim_secded_hamming_76_68_dec.sv
+++ /dev/null
@@ -1,99 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_hamming_76_68_dec (
-  input        [75:0] data_i,
-  output logic [67:0] data_o,
-  output logic [7:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 76'h01AAB55555556AAAD5B);
-    syndrome_o[1] = ^(data_i & 76'h02CCD9999999B33366D);
-    syndrome_o[2] = ^(data_i & 76'h040F1E1E1E1E3C3C78E);
-    syndrome_o[3] = ^(data_i & 76'h08F01FE01FE03FC07F0);
-    syndrome_o[4] = ^(data_i & 76'h10001FFFE0003FFF800);
-    syndrome_o[5] = ^(data_i & 76'h20001FFFFFFFC000000);
-    syndrome_o[6] = ^(data_i & 76'h40FFE00000000000000);
-    syndrome_o[7] = ^(data_i & 76'hFFFFFFFFFFFFFFFFFFF);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 8'h83) ^ data_i[0];
-    data_o[1] = (syndrome_o == 8'h85) ^ data_i[1];
-    data_o[2] = (syndrome_o == 8'h86) ^ data_i[2];
-    data_o[3] = (syndrome_o == 8'h87) ^ data_i[3];
-    data_o[4] = (syndrome_o == 8'h89) ^ data_i[4];
-    data_o[5] = (syndrome_o == 8'h8a) ^ data_i[5];
-    data_o[6] = (syndrome_o == 8'h8b) ^ data_i[6];
-    data_o[7] = (syndrome_o == 8'h8c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 8'h8d) ^ data_i[8];
-    data_o[9] = (syndrome_o == 8'h8e) ^ data_i[9];
-    data_o[10] = (syndrome_o == 8'h8f) ^ data_i[10];
-    data_o[11] = (syndrome_o == 8'h91) ^ data_i[11];
-    data_o[12] = (syndrome_o == 8'h92) ^ data_i[12];
-    data_o[13] = (syndrome_o == 8'h93) ^ data_i[13];
-    data_o[14] = (syndrome_o == 8'h94) ^ data_i[14];
-    data_o[15] = (syndrome_o == 8'h95) ^ data_i[15];
-    data_o[16] = (syndrome_o == 8'h96) ^ data_i[16];
-    data_o[17] = (syndrome_o == 8'h97) ^ data_i[17];
-    data_o[18] = (syndrome_o == 8'h98) ^ data_i[18];
-    data_o[19] = (syndrome_o == 8'h99) ^ data_i[19];
-    data_o[20] = (syndrome_o == 8'h9a) ^ data_i[20];
-    data_o[21] = (syndrome_o == 8'h9b) ^ data_i[21];
-    data_o[22] = (syndrome_o == 8'h9c) ^ data_i[22];
-    data_o[23] = (syndrome_o == 8'h9d) ^ data_i[23];
-    data_o[24] = (syndrome_o == 8'h9e) ^ data_i[24];
-    data_o[25] = (syndrome_o == 8'h9f) ^ data_i[25];
-    data_o[26] = (syndrome_o == 8'ha1) ^ data_i[26];
-    data_o[27] = (syndrome_o == 8'ha2) ^ data_i[27];
-    data_o[28] = (syndrome_o == 8'ha3) ^ data_i[28];
-    data_o[29] = (syndrome_o == 8'ha4) ^ data_i[29];
-    data_o[30] = (syndrome_o == 8'ha5) ^ data_i[30];
-    data_o[31] = (syndrome_o == 8'ha6) ^ data_i[31];
-    data_o[32] = (syndrome_o == 8'ha7) ^ data_i[32];
-    data_o[33] = (syndrome_o == 8'ha8) ^ data_i[33];
-    data_o[34] = (syndrome_o == 8'ha9) ^ data_i[34];
-    data_o[35] = (syndrome_o == 8'haa) ^ data_i[35];
-    data_o[36] = (syndrome_o == 8'hab) ^ data_i[36];
-    data_o[37] = (syndrome_o == 8'hac) ^ data_i[37];
-    data_o[38] = (syndrome_o == 8'had) ^ data_i[38];
-    data_o[39] = (syndrome_o == 8'hae) ^ data_i[39];
-    data_o[40] = (syndrome_o == 8'haf) ^ data_i[40];
-    data_o[41] = (syndrome_o == 8'hb0) ^ data_i[41];
-    data_o[42] = (syndrome_o == 8'hb1) ^ data_i[42];
-    data_o[43] = (syndrome_o == 8'hb2) ^ data_i[43];
-    data_o[44] = (syndrome_o == 8'hb3) ^ data_i[44];
-    data_o[45] = (syndrome_o == 8'hb4) ^ data_i[45];
-    data_o[46] = (syndrome_o == 8'hb5) ^ data_i[46];
-    data_o[47] = (syndrome_o == 8'hb6) ^ data_i[47];
-    data_o[48] = (syndrome_o == 8'hb7) ^ data_i[48];
-    data_o[49] = (syndrome_o == 8'hb8) ^ data_i[49];
-    data_o[50] = (syndrome_o == 8'hb9) ^ data_i[50];
-    data_o[51] = (syndrome_o == 8'hba) ^ data_i[51];
-    data_o[52] = (syndrome_o == 8'hbb) ^ data_i[52];
-    data_o[53] = (syndrome_o == 8'hbc) ^ data_i[53];
-    data_o[54] = (syndrome_o == 8'hbd) ^ data_i[54];
-    data_o[55] = (syndrome_o == 8'hbe) ^ data_i[55];
-    data_o[56] = (syndrome_o == 8'hbf) ^ data_i[56];
-    data_o[57] = (syndrome_o == 8'hc1) ^ data_i[57];
-    data_o[58] = (syndrome_o == 8'hc2) ^ data_i[58];
-    data_o[59] = (syndrome_o == 8'hc3) ^ data_i[59];
-    data_o[60] = (syndrome_o == 8'hc4) ^ data_i[60];
-    data_o[61] = (syndrome_o == 8'hc5) ^ data_i[61];
-    data_o[62] = (syndrome_o == 8'hc6) ^ data_i[62];
-    data_o[63] = (syndrome_o == 8'hc7) ^ data_i[63];
-    data_o[64] = (syndrome_o == 8'hc8) ^ data_i[64];
-    data_o[65] = (syndrome_o == 8'hc9) ^ data_i[65];
-    data_o[66] = (syndrome_o == 8'hca) ^ data_i[66];
-    data_o[67] = (syndrome_o == 8'hcb) ^ data_i[67];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = syndrome_o[7];
-    err_o[1] = |syndrome_o[6:0] & ~syndrome_o[7];
-  end
-endmodule : prim_secded_hamming_76_68_dec
diff --git a/prim_secded_hamming_76_68_enc.sv b/prim_secded_hamming_76_68_enc.sv
deleted file mode 100644
index 8cb1f70a..00000000
--- a/prim_secded_hamming_76_68_enc.sv
+++ /dev/null
@@ -1,24 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_hamming_76_68_enc (
-  input        [67:0] data_i,
-  output logic [75:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 76'(data_i);
-    data_o[68] = 1'b0 ^ ^(data_o & 76'h00AAB55555556AAAD5B);
-    data_o[69] = 1'b0 ^ ^(data_o & 76'h00CCD9999999B33366D);
-    data_o[70] = 1'b0 ^ ^(data_o & 76'h000F1E1E1E1E3C3C78E);
-    data_o[71] = 1'b0 ^ ^(data_o & 76'h00F01FE01FE03FC07F0);
-    data_o[72] = 1'b0 ^ ^(data_o & 76'h00001FFFE0003FFF800);
-    data_o[73] = 1'b0 ^ ^(data_o & 76'h00001FFFFFFFC000000);
-    data_o[74] = 1'b0 ^ ^(data_o & 76'h00FFE00000000000000);
-    data_o[75] = 1'b0 ^ ^(data_o & 76'h7FFFFFFFFFFFFFFFFFF);
-  end
-
-endmodule : prim_secded_hamming_76_68_enc
diff --git a/prim_secded_inv_22_16_dec.sv b/prim_secded_inv_22_16_dec.sv
deleted file mode 100644
index 5d53680e..00000000
--- a/prim_secded_inv_22_16_dec.sv
+++ /dev/null
@@ -1,45 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_22_16_dec (
-  input        [21:0] data_i,
-  output logic [15:0] data_o,
-  output logic [5:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 22'h2A0000) & 22'h01496E);
-    syndrome_o[1] = ^((data_i ^ 22'h2A0000) & 22'h02F20B);
-    syndrome_o[2] = ^((data_i ^ 22'h2A0000) & 22'h048ED8);
-    syndrome_o[3] = ^((data_i ^ 22'h2A0000) & 22'h087714);
-    syndrome_o[4] = ^((data_i ^ 22'h2A0000) & 22'h10ACA5);
-    syndrome_o[5] = ^((data_i ^ 22'h2A0000) & 22'h2011F3);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 6'h32) ^ data_i[0];
-    data_o[1] = (syndrome_o == 6'h23) ^ data_i[1];
-    data_o[2] = (syndrome_o == 6'h19) ^ data_i[2];
-    data_o[3] = (syndrome_o == 6'h7) ^ data_i[3];
-    data_o[4] = (syndrome_o == 6'h2c) ^ data_i[4];
-    data_o[5] = (syndrome_o == 6'h31) ^ data_i[5];
-    data_o[6] = (syndrome_o == 6'h25) ^ data_i[6];
-    data_o[7] = (syndrome_o == 6'h34) ^ data_i[7];
-    data_o[8] = (syndrome_o == 6'h29) ^ data_i[8];
-    data_o[9] = (syndrome_o == 6'he) ^ data_i[9];
-    data_o[10] = (syndrome_o == 6'h1c) ^ data_i[10];
-    data_o[11] = (syndrome_o == 6'h15) ^ data_i[11];
-    data_o[12] = (syndrome_o == 6'h2a) ^ data_i[12];
-    data_o[13] = (syndrome_o == 6'h1a) ^ data_i[13];
-    data_o[14] = (syndrome_o == 6'hb) ^ data_i[14];
-    data_o[15] = (syndrome_o == 6'h16) ^ data_i[15];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-  end
-endmodule : prim_secded_inv_22_16_dec
diff --git a/prim_secded_inv_22_16_enc.sv b/prim_secded_inv_22_16_enc.sv
deleted file mode 100644
index b738b3d2..00000000
--- a/prim_secded_inv_22_16_enc.sv
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_22_16_enc (
-  input        [15:0] data_i,
-  output logic [21:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 22'(data_i);
-    data_o[16] = 1'b0 ^ ^(data_o & 22'h00496E);
-    data_o[17] = 1'b1 ^ ^(data_o & 22'h00F20B);
-    data_o[18] = 1'b0 ^ ^(data_o & 22'h008ED8);
-    data_o[19] = 1'b1 ^ ^(data_o & 22'h007714);
-    data_o[20] = 1'b0 ^ ^(data_o & 22'h00ACA5);
-    data_o[21] = 1'b1 ^ ^(data_o & 22'h0011F3);
-  end
-
-endmodule : prim_secded_inv_22_16_enc
diff --git a/prim_secded_inv_28_22_dec.sv b/prim_secded_inv_28_22_dec.sv
deleted file mode 100644
index b54b6474..00000000
--- a/prim_secded_inv_28_22_dec.sv
+++ /dev/null
@@ -1,51 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_28_22_dec (
-  input        [27:0] data_i,
-  output logic [21:0] data_o,
-  output logic [5:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 28'hA800000) & 28'h07003FF);
-    syndrome_o[1] = ^((data_i ^ 28'hA800000) & 28'h090FC0F);
-    syndrome_o[2] = ^((data_i ^ 28'hA800000) & 28'h1271C71);
-    syndrome_o[3] = ^((data_i ^ 28'hA800000) & 28'h23B6592);
-    syndrome_o[4] = ^((data_i ^ 28'hA800000) & 28'h43DAAA4);
-    syndrome_o[5] = ^((data_i ^ 28'hA800000) & 28'h83ED348);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 6'h7) ^ data_i[0];
-    data_o[1] = (syndrome_o == 6'hb) ^ data_i[1];
-    data_o[2] = (syndrome_o == 6'h13) ^ data_i[2];
-    data_o[3] = (syndrome_o == 6'h23) ^ data_i[3];
-    data_o[4] = (syndrome_o == 6'hd) ^ data_i[4];
-    data_o[5] = (syndrome_o == 6'h15) ^ data_i[5];
-    data_o[6] = (syndrome_o == 6'h25) ^ data_i[6];
-    data_o[7] = (syndrome_o == 6'h19) ^ data_i[7];
-    data_o[8] = (syndrome_o == 6'h29) ^ data_i[8];
-    data_o[9] = (syndrome_o == 6'h31) ^ data_i[9];
-    data_o[10] = (syndrome_o == 6'he) ^ data_i[10];
-    data_o[11] = (syndrome_o == 6'h16) ^ data_i[11];
-    data_o[12] = (syndrome_o == 6'h26) ^ data_i[12];
-    data_o[13] = (syndrome_o == 6'h1a) ^ data_i[13];
-    data_o[14] = (syndrome_o == 6'h2a) ^ data_i[14];
-    data_o[15] = (syndrome_o == 6'h32) ^ data_i[15];
-    data_o[16] = (syndrome_o == 6'h1c) ^ data_i[16];
-    data_o[17] = (syndrome_o == 6'h2c) ^ data_i[17];
-    data_o[18] = (syndrome_o == 6'h34) ^ data_i[18];
-    data_o[19] = (syndrome_o == 6'h38) ^ data_i[19];
-    data_o[20] = (syndrome_o == 6'h3b) ^ data_i[20];
-    data_o[21] = (syndrome_o == 6'h3d) ^ data_i[21];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-  end
-endmodule : prim_secded_inv_28_22_dec
diff --git a/prim_secded_inv_28_22_enc.sv b/prim_secded_inv_28_22_enc.sv
deleted file mode 100644
index 2fcb7d38..00000000
--- a/prim_secded_inv_28_22_enc.sv
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_28_22_enc (
-  input        [21:0] data_i,
-  output logic [27:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 28'(data_i);
-    data_o[22] = 1'b0 ^ ^(data_o & 28'h03003FF);
-    data_o[23] = 1'b1 ^ ^(data_o & 28'h010FC0F);
-    data_o[24] = 1'b0 ^ ^(data_o & 28'h0271C71);
-    data_o[25] = 1'b1 ^ ^(data_o & 28'h03B6592);
-    data_o[26] = 1'b0 ^ ^(data_o & 28'h03DAAA4);
-    data_o[27] = 1'b1 ^ ^(data_o & 28'h03ED348);
-  end
-
-endmodule : prim_secded_inv_28_22_enc
diff --git a/prim_secded_inv_39_32_dec.sv b/prim_secded_inv_39_32_dec.sv
deleted file mode 100644
index a40a86cd..00000000
--- a/prim_secded_inv_39_32_dec.sv
+++ /dev/null
@@ -1,62 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_39_32_dec (
-  input        [38:0] data_i,
-  output logic [31:0] data_o,
-  output logic [6:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 39'h2A00000000) & 39'h012606BD25);
-    syndrome_o[1] = ^((data_i ^ 39'h2A00000000) & 39'h02DEBA8050);
-    syndrome_o[2] = ^((data_i ^ 39'h2A00000000) & 39'h04413D89AA);
-    syndrome_o[3] = ^((data_i ^ 39'h2A00000000) & 39'h0831234ED1);
-    syndrome_o[4] = ^((data_i ^ 39'h2A00000000) & 39'h10C2C1323B);
-    syndrome_o[5] = ^((data_i ^ 39'h2A00000000) & 39'h202DCC624C);
-    syndrome_o[6] = ^((data_i ^ 39'h2A00000000) & 39'h4098505586);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 7'h19) ^ data_i[0];
-    data_o[1] = (syndrome_o == 7'h54) ^ data_i[1];
-    data_o[2] = (syndrome_o == 7'h61) ^ data_i[2];
-    data_o[3] = (syndrome_o == 7'h34) ^ data_i[3];
-    data_o[4] = (syndrome_o == 7'h1a) ^ data_i[4];
-    data_o[5] = (syndrome_o == 7'h15) ^ data_i[5];
-    data_o[6] = (syndrome_o == 7'h2a) ^ data_i[6];
-    data_o[7] = (syndrome_o == 7'h4c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 7'h45) ^ data_i[8];
-    data_o[9] = (syndrome_o == 7'h38) ^ data_i[9];
-    data_o[10] = (syndrome_o == 7'h49) ^ data_i[10];
-    data_o[11] = (syndrome_o == 7'hd) ^ data_i[11];
-    data_o[12] = (syndrome_o == 7'h51) ^ data_i[12];
-    data_o[13] = (syndrome_o == 7'h31) ^ data_i[13];
-    data_o[14] = (syndrome_o == 7'h68) ^ data_i[14];
-    data_o[15] = (syndrome_o == 7'h7) ^ data_i[15];
-    data_o[16] = (syndrome_o == 7'h1c) ^ data_i[16];
-    data_o[17] = (syndrome_o == 7'hb) ^ data_i[17];
-    data_o[18] = (syndrome_o == 7'h25) ^ data_i[18];
-    data_o[19] = (syndrome_o == 7'h26) ^ data_i[19];
-    data_o[20] = (syndrome_o == 7'h46) ^ data_i[20];
-    data_o[21] = (syndrome_o == 7'he) ^ data_i[21];
-    data_o[22] = (syndrome_o == 7'h70) ^ data_i[22];
-    data_o[23] = (syndrome_o == 7'h32) ^ data_i[23];
-    data_o[24] = (syndrome_o == 7'h2c) ^ data_i[24];
-    data_o[25] = (syndrome_o == 7'h13) ^ data_i[25];
-    data_o[26] = (syndrome_o == 7'h23) ^ data_i[26];
-    data_o[27] = (syndrome_o == 7'h62) ^ data_i[27];
-    data_o[28] = (syndrome_o == 7'h4a) ^ data_i[28];
-    data_o[29] = (syndrome_o == 7'h29) ^ data_i[29];
-    data_o[30] = (syndrome_o == 7'h16) ^ data_i[30];
-    data_o[31] = (syndrome_o == 7'h52) ^ data_i[31];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-  end
-endmodule : prim_secded_inv_39_32_dec
diff --git a/prim_secded_inv_39_32_enc.sv b/prim_secded_inv_39_32_enc.sv
deleted file mode 100644
index e59d4879..00000000
--- a/prim_secded_inv_39_32_enc.sv
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_39_32_enc (
-  input        [31:0] data_i,
-  output logic [38:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 39'(data_i);
-    data_o[32] = 1'b0 ^ ^(data_o & 39'h002606BD25);
-    data_o[33] = 1'b1 ^ ^(data_o & 39'h00DEBA8050);
-    data_o[34] = 1'b0 ^ ^(data_o & 39'h00413D89AA);
-    data_o[35] = 1'b1 ^ ^(data_o & 39'h0031234ED1);
-    data_o[36] = 1'b0 ^ ^(data_o & 39'h00C2C1323B);
-    data_o[37] = 1'b1 ^ ^(data_o & 39'h002DCC624C);
-    data_o[38] = 1'b0 ^ ^(data_o & 39'h0098505586);
-  end
-
-endmodule : prim_secded_inv_39_32_enc
diff --git a/prim_secded_inv_64_57_dec.sv b/prim_secded_inv_64_57_dec.sv
deleted file mode 100644
index 6e34b502..00000000
--- a/prim_secded_inv_64_57_dec.sv
+++ /dev/null
@@ -1,87 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_64_57_dec (
-  input        [63:0] data_i,
-  output logic [56:0] data_o,
-  output logic [6:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 64'h5400000000000000) & 64'h0303FFF800007FFF);
-    syndrome_o[1] = ^((data_i ^ 64'h5400000000000000) & 64'h057C1FF801FF801F);
-    syndrome_o[2] = ^((data_i ^ 64'h5400000000000000) & 64'h09BDE1F87E0781E1);
-    syndrome_o[3] = ^((data_i ^ 64'h5400000000000000) & 64'h11DEEE3B8E388E22);
-    syndrome_o[4] = ^((data_i ^ 64'h5400000000000000) & 64'h21EF76CDB2C93244);
-    syndrome_o[5] = ^((data_i ^ 64'h5400000000000000) & 64'h41F7BB56D5525488);
-    syndrome_o[6] = ^((data_i ^ 64'h5400000000000000) & 64'h81FBDDA769A46910);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 7'h7) ^ data_i[0];
-    data_o[1] = (syndrome_o == 7'hb) ^ data_i[1];
-    data_o[2] = (syndrome_o == 7'h13) ^ data_i[2];
-    data_o[3] = (syndrome_o == 7'h23) ^ data_i[3];
-    data_o[4] = (syndrome_o == 7'h43) ^ data_i[4];
-    data_o[5] = (syndrome_o == 7'hd) ^ data_i[5];
-    data_o[6] = (syndrome_o == 7'h15) ^ data_i[6];
-    data_o[7] = (syndrome_o == 7'h25) ^ data_i[7];
-    data_o[8] = (syndrome_o == 7'h45) ^ data_i[8];
-    data_o[9] = (syndrome_o == 7'h19) ^ data_i[9];
-    data_o[10] = (syndrome_o == 7'h29) ^ data_i[10];
-    data_o[11] = (syndrome_o == 7'h49) ^ data_i[11];
-    data_o[12] = (syndrome_o == 7'h31) ^ data_i[12];
-    data_o[13] = (syndrome_o == 7'h51) ^ data_i[13];
-    data_o[14] = (syndrome_o == 7'h61) ^ data_i[14];
-    data_o[15] = (syndrome_o == 7'he) ^ data_i[15];
-    data_o[16] = (syndrome_o == 7'h16) ^ data_i[16];
-    data_o[17] = (syndrome_o == 7'h26) ^ data_i[17];
-    data_o[18] = (syndrome_o == 7'h46) ^ data_i[18];
-    data_o[19] = (syndrome_o == 7'h1a) ^ data_i[19];
-    data_o[20] = (syndrome_o == 7'h2a) ^ data_i[20];
-    data_o[21] = (syndrome_o == 7'h4a) ^ data_i[21];
-    data_o[22] = (syndrome_o == 7'h32) ^ data_i[22];
-    data_o[23] = (syndrome_o == 7'h52) ^ data_i[23];
-    data_o[24] = (syndrome_o == 7'h62) ^ data_i[24];
-    data_o[25] = (syndrome_o == 7'h1c) ^ data_i[25];
-    data_o[26] = (syndrome_o == 7'h2c) ^ data_i[26];
-    data_o[27] = (syndrome_o == 7'h4c) ^ data_i[27];
-    data_o[28] = (syndrome_o == 7'h34) ^ data_i[28];
-    data_o[29] = (syndrome_o == 7'h54) ^ data_i[29];
-    data_o[30] = (syndrome_o == 7'h64) ^ data_i[30];
-    data_o[31] = (syndrome_o == 7'h38) ^ data_i[31];
-    data_o[32] = (syndrome_o == 7'h58) ^ data_i[32];
-    data_o[33] = (syndrome_o == 7'h68) ^ data_i[33];
-    data_o[34] = (syndrome_o == 7'h70) ^ data_i[34];
-    data_o[35] = (syndrome_o == 7'h1f) ^ data_i[35];
-    data_o[36] = (syndrome_o == 7'h2f) ^ data_i[36];
-    data_o[37] = (syndrome_o == 7'h4f) ^ data_i[37];
-    data_o[38] = (syndrome_o == 7'h37) ^ data_i[38];
-    data_o[39] = (syndrome_o == 7'h57) ^ data_i[39];
-    data_o[40] = (syndrome_o == 7'h67) ^ data_i[40];
-    data_o[41] = (syndrome_o == 7'h3b) ^ data_i[41];
-    data_o[42] = (syndrome_o == 7'h5b) ^ data_i[42];
-    data_o[43] = (syndrome_o == 7'h6b) ^ data_i[43];
-    data_o[44] = (syndrome_o == 7'h73) ^ data_i[44];
-    data_o[45] = (syndrome_o == 7'h3d) ^ data_i[45];
-    data_o[46] = (syndrome_o == 7'h5d) ^ data_i[46];
-    data_o[47] = (syndrome_o == 7'h6d) ^ data_i[47];
-    data_o[48] = (syndrome_o == 7'h75) ^ data_i[48];
-    data_o[49] = (syndrome_o == 7'h79) ^ data_i[49];
-    data_o[50] = (syndrome_o == 7'h3e) ^ data_i[50];
-    data_o[51] = (syndrome_o == 7'h5e) ^ data_i[51];
-    data_o[52] = (syndrome_o == 7'h6e) ^ data_i[52];
-    data_o[53] = (syndrome_o == 7'h76) ^ data_i[53];
-    data_o[54] = (syndrome_o == 7'h7a) ^ data_i[54];
-    data_o[55] = (syndrome_o == 7'h7c) ^ data_i[55];
-    data_o[56] = (syndrome_o == 7'h7f) ^ data_i[56];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-  end
-endmodule : prim_secded_inv_64_57_dec
diff --git a/prim_secded_inv_64_57_enc.sv b/prim_secded_inv_64_57_enc.sv
deleted file mode 100644
index 21caaa6b..00000000
--- a/prim_secded_inv_64_57_enc.sv
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_64_57_enc (
-  input        [56:0] data_i,
-  output logic [63:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 64'(data_i);
-    data_o[57] = 1'b0 ^ ^(data_o & 64'h0103FFF800007FFF);
-    data_o[58] = 1'b1 ^ ^(data_o & 64'h017C1FF801FF801F);
-    data_o[59] = 1'b0 ^ ^(data_o & 64'h01BDE1F87E0781E1);
-    data_o[60] = 1'b1 ^ ^(data_o & 64'h01DEEE3B8E388E22);
-    data_o[61] = 1'b0 ^ ^(data_o & 64'h01EF76CDB2C93244);
-    data_o[62] = 1'b1 ^ ^(data_o & 64'h01F7BB56D5525488);
-    data_o[63] = 1'b0 ^ ^(data_o & 64'h01FBDDA769A46910);
-  end
-
-endmodule : prim_secded_inv_64_57_enc
diff --git a/prim_secded_inv_72_64_dec.sv b/prim_secded_inv_72_64_dec.sv
deleted file mode 100644
index aa4c5b59..00000000
--- a/prim_secded_inv_72_64_dec.sv
+++ /dev/null
@@ -1,95 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_72_64_dec (
-  input        [71:0] data_i,
-  output logic [63:0] data_o,
-  output logic [7:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 72'hAA0000000000000000) & 72'h01B9000000001FFFFF);
-    syndrome_o[1] = ^((data_i ^ 72'hAA0000000000000000) & 72'h025E00000FFFE0003F);
-    syndrome_o[2] = ^((data_i ^ 72'hAA0000000000000000) & 72'h0467003FF003E007C1);
-    syndrome_o[3] = ^((data_i ^ 72'hAA0000000000000000) & 72'h08CD0FC0F03C207842);
-    syndrome_o[4] = ^((data_i ^ 72'hAA0000000000000000) & 72'h10B671C711C4438884);
-    syndrome_o[5] = ^((data_i ^ 72'hAA0000000000000000) & 72'h20B5B65926488C9108);
-    syndrome_o[6] = ^((data_i ^ 72'hAA0000000000000000) & 72'h40CBDAAA4A91152210);
-    syndrome_o[7] = ^((data_i ^ 72'hAA0000000000000000) & 72'h807AED348D221A4420);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 8'h7) ^ data_i[0];
-    data_o[1] = (syndrome_o == 8'hb) ^ data_i[1];
-    data_o[2] = (syndrome_o == 8'h13) ^ data_i[2];
-    data_o[3] = (syndrome_o == 8'h23) ^ data_i[3];
-    data_o[4] = (syndrome_o == 8'h43) ^ data_i[4];
-    data_o[5] = (syndrome_o == 8'h83) ^ data_i[5];
-    data_o[6] = (syndrome_o == 8'hd) ^ data_i[6];
-    data_o[7] = (syndrome_o == 8'h15) ^ data_i[7];
-    data_o[8] = (syndrome_o == 8'h25) ^ data_i[8];
-    data_o[9] = (syndrome_o == 8'h45) ^ data_i[9];
-    data_o[10] = (syndrome_o == 8'h85) ^ data_i[10];
-    data_o[11] = (syndrome_o == 8'h19) ^ data_i[11];
-    data_o[12] = (syndrome_o == 8'h29) ^ data_i[12];
-    data_o[13] = (syndrome_o == 8'h49) ^ data_i[13];
-    data_o[14] = (syndrome_o == 8'h89) ^ data_i[14];
-    data_o[15] = (syndrome_o == 8'h31) ^ data_i[15];
-    data_o[16] = (syndrome_o == 8'h51) ^ data_i[16];
-    data_o[17] = (syndrome_o == 8'h91) ^ data_i[17];
-    data_o[18] = (syndrome_o == 8'h61) ^ data_i[18];
-    data_o[19] = (syndrome_o == 8'ha1) ^ data_i[19];
-    data_o[20] = (syndrome_o == 8'hc1) ^ data_i[20];
-    data_o[21] = (syndrome_o == 8'he) ^ data_i[21];
-    data_o[22] = (syndrome_o == 8'h16) ^ data_i[22];
-    data_o[23] = (syndrome_o == 8'h26) ^ data_i[23];
-    data_o[24] = (syndrome_o == 8'h46) ^ data_i[24];
-    data_o[25] = (syndrome_o == 8'h86) ^ data_i[25];
-    data_o[26] = (syndrome_o == 8'h1a) ^ data_i[26];
-    data_o[27] = (syndrome_o == 8'h2a) ^ data_i[27];
-    data_o[28] = (syndrome_o == 8'h4a) ^ data_i[28];
-    data_o[29] = (syndrome_o == 8'h8a) ^ data_i[29];
-    data_o[30] = (syndrome_o == 8'h32) ^ data_i[30];
-    data_o[31] = (syndrome_o == 8'h52) ^ data_i[31];
-    data_o[32] = (syndrome_o == 8'h92) ^ data_i[32];
-    data_o[33] = (syndrome_o == 8'h62) ^ data_i[33];
-    data_o[34] = (syndrome_o == 8'ha2) ^ data_i[34];
-    data_o[35] = (syndrome_o == 8'hc2) ^ data_i[35];
-    data_o[36] = (syndrome_o == 8'h1c) ^ data_i[36];
-    data_o[37] = (syndrome_o == 8'h2c) ^ data_i[37];
-    data_o[38] = (syndrome_o == 8'h4c) ^ data_i[38];
-    data_o[39] = (syndrome_o == 8'h8c) ^ data_i[39];
-    data_o[40] = (syndrome_o == 8'h34) ^ data_i[40];
-    data_o[41] = (syndrome_o == 8'h54) ^ data_i[41];
-    data_o[42] = (syndrome_o == 8'h94) ^ data_i[42];
-    data_o[43] = (syndrome_o == 8'h64) ^ data_i[43];
-    data_o[44] = (syndrome_o == 8'ha4) ^ data_i[44];
-    data_o[45] = (syndrome_o == 8'hc4) ^ data_i[45];
-    data_o[46] = (syndrome_o == 8'h38) ^ data_i[46];
-    data_o[47] = (syndrome_o == 8'h58) ^ data_i[47];
-    data_o[48] = (syndrome_o == 8'h98) ^ data_i[48];
-    data_o[49] = (syndrome_o == 8'h68) ^ data_i[49];
-    data_o[50] = (syndrome_o == 8'ha8) ^ data_i[50];
-    data_o[51] = (syndrome_o == 8'hc8) ^ data_i[51];
-    data_o[52] = (syndrome_o == 8'h70) ^ data_i[52];
-    data_o[53] = (syndrome_o == 8'hb0) ^ data_i[53];
-    data_o[54] = (syndrome_o == 8'hd0) ^ data_i[54];
-    data_o[55] = (syndrome_o == 8'he0) ^ data_i[55];
-    data_o[56] = (syndrome_o == 8'h6d) ^ data_i[56];
-    data_o[57] = (syndrome_o == 8'hd6) ^ data_i[57];
-    data_o[58] = (syndrome_o == 8'h3e) ^ data_i[58];
-    data_o[59] = (syndrome_o == 8'hcb) ^ data_i[59];
-    data_o[60] = (syndrome_o == 8'hb3) ^ data_i[60];
-    data_o[61] = (syndrome_o == 8'hb5) ^ data_i[61];
-    data_o[62] = (syndrome_o == 8'hce) ^ data_i[62];
-    data_o[63] = (syndrome_o == 8'h79) ^ data_i[63];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-  end
-endmodule : prim_secded_inv_72_64_dec
diff --git a/prim_secded_inv_72_64_enc.sv b/prim_secded_inv_72_64_enc.sv
deleted file mode 100644
index fcb93a4e..00000000
--- a/prim_secded_inv_72_64_enc.sv
+++ /dev/null
@@ -1,24 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_72_64_enc (
-  input        [63:0] data_i,
-  output logic [71:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 72'(data_i);
-    data_o[64] = 1'b0 ^ ^(data_o & 72'h00B9000000001FFFFF);
-    data_o[65] = 1'b1 ^ ^(data_o & 72'h005E00000FFFE0003F);
-    data_o[66] = 1'b0 ^ ^(data_o & 72'h0067003FF003E007C1);
-    data_o[67] = 1'b1 ^ ^(data_o & 72'h00CD0FC0F03C207842);
-    data_o[68] = 1'b0 ^ ^(data_o & 72'h00B671C711C4438884);
-    data_o[69] = 1'b1 ^ ^(data_o & 72'h00B5B65926488C9108);
-    data_o[70] = 1'b0 ^ ^(data_o & 72'h00CBDAAA4A91152210);
-    data_o[71] = 1'b1 ^ ^(data_o & 72'h007AED348D221A4420);
-  end
-
-endmodule : prim_secded_inv_72_64_enc
diff --git a/prim_secded_inv_hamming_22_16_dec.sv b/prim_secded_inv_hamming_22_16_dec.sv
deleted file mode 100644
index 0f077ee7..00000000
--- a/prim_secded_inv_hamming_22_16_dec.sv
+++ /dev/null
@@ -1,45 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_hamming_22_16_dec (
-  input        [21:0] data_i,
-  output logic [15:0] data_o,
-  output logic [5:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 22'h2A0000) & 22'h01AD5B);
-    syndrome_o[1] = ^((data_i ^ 22'h2A0000) & 22'h02366D);
-    syndrome_o[2] = ^((data_i ^ 22'h2A0000) & 22'h04C78E);
-    syndrome_o[3] = ^((data_i ^ 22'h2A0000) & 22'h0807F0);
-    syndrome_o[4] = ^((data_i ^ 22'h2A0000) & 22'h10F800);
-    syndrome_o[5] = ^((data_i ^ 22'h2A0000) & 22'h3FFFFF);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 6'h23) ^ data_i[0];
-    data_o[1] = (syndrome_o == 6'h25) ^ data_i[1];
-    data_o[2] = (syndrome_o == 6'h26) ^ data_i[2];
-    data_o[3] = (syndrome_o == 6'h27) ^ data_i[3];
-    data_o[4] = (syndrome_o == 6'h29) ^ data_i[4];
-    data_o[5] = (syndrome_o == 6'h2a) ^ data_i[5];
-    data_o[6] = (syndrome_o == 6'h2b) ^ data_i[6];
-    data_o[7] = (syndrome_o == 6'h2c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 6'h2d) ^ data_i[8];
-    data_o[9] = (syndrome_o == 6'h2e) ^ data_i[9];
-    data_o[10] = (syndrome_o == 6'h2f) ^ data_i[10];
-    data_o[11] = (syndrome_o == 6'h31) ^ data_i[11];
-    data_o[12] = (syndrome_o == 6'h32) ^ data_i[12];
-    data_o[13] = (syndrome_o == 6'h33) ^ data_i[13];
-    data_o[14] = (syndrome_o == 6'h34) ^ data_i[14];
-    data_o[15] = (syndrome_o == 6'h35) ^ data_i[15];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = syndrome_o[5];
-    err_o[1] = |syndrome_o[4:0] & ~syndrome_o[5];
-  end
-endmodule : prim_secded_inv_hamming_22_16_dec
diff --git a/prim_secded_inv_hamming_22_16_enc.sv b/prim_secded_inv_hamming_22_16_enc.sv
deleted file mode 100644
index 0fd23519..00000000
--- a/prim_secded_inv_hamming_22_16_enc.sv
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_hamming_22_16_enc (
-  input        [15:0] data_i,
-  output logic [21:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 22'(data_i);
-    data_o[16] = 1'b0 ^ ^(data_o & 22'h00AD5B);
-    data_o[17] = 1'b1 ^ ^(data_o & 22'h00366D);
-    data_o[18] = 1'b0 ^ ^(data_o & 22'h00C78E);
-    data_o[19] = 1'b1 ^ ^(data_o & 22'h0007F0);
-    data_o[20] = 1'b0 ^ ^(data_o & 22'h00F800);
-    data_o[21] = 1'b1 ^ ^(data_o & 22'h1FFFFF);
-  end
-
-endmodule : prim_secded_inv_hamming_22_16_enc
diff --git a/prim_secded_inv_hamming_39_32_dec.sv b/prim_secded_inv_hamming_39_32_dec.sv
deleted file mode 100644
index f65e86d5..00000000
--- a/prim_secded_inv_hamming_39_32_dec.sv
+++ /dev/null
@@ -1,62 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_hamming_39_32_dec (
-  input        [38:0] data_i,
-  output logic [31:0] data_o,
-  output logic [6:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 39'h2A00000000) & 39'h0156AAAD5B);
-    syndrome_o[1] = ^((data_i ^ 39'h2A00000000) & 39'h029B33366D);
-    syndrome_o[2] = ^((data_i ^ 39'h2A00000000) & 39'h04E3C3C78E);
-    syndrome_o[3] = ^((data_i ^ 39'h2A00000000) & 39'h0803FC07F0);
-    syndrome_o[4] = ^((data_i ^ 39'h2A00000000) & 39'h1003FFF800);
-    syndrome_o[5] = ^((data_i ^ 39'h2A00000000) & 39'h20FC000000);
-    syndrome_o[6] = ^((data_i ^ 39'h2A00000000) & 39'h7FFFFFFFFF);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 7'h43) ^ data_i[0];
-    data_o[1] = (syndrome_o == 7'h45) ^ data_i[1];
-    data_o[2] = (syndrome_o == 7'h46) ^ data_i[2];
-    data_o[3] = (syndrome_o == 7'h47) ^ data_i[3];
-    data_o[4] = (syndrome_o == 7'h49) ^ data_i[4];
-    data_o[5] = (syndrome_o == 7'h4a) ^ data_i[5];
-    data_o[6] = (syndrome_o == 7'h4b) ^ data_i[6];
-    data_o[7] = (syndrome_o == 7'h4c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 7'h4d) ^ data_i[8];
-    data_o[9] = (syndrome_o == 7'h4e) ^ data_i[9];
-    data_o[10] = (syndrome_o == 7'h4f) ^ data_i[10];
-    data_o[11] = (syndrome_o == 7'h51) ^ data_i[11];
-    data_o[12] = (syndrome_o == 7'h52) ^ data_i[12];
-    data_o[13] = (syndrome_o == 7'h53) ^ data_i[13];
-    data_o[14] = (syndrome_o == 7'h54) ^ data_i[14];
-    data_o[15] = (syndrome_o == 7'h55) ^ data_i[15];
-    data_o[16] = (syndrome_o == 7'h56) ^ data_i[16];
-    data_o[17] = (syndrome_o == 7'h57) ^ data_i[17];
-    data_o[18] = (syndrome_o == 7'h58) ^ data_i[18];
-    data_o[19] = (syndrome_o == 7'h59) ^ data_i[19];
-    data_o[20] = (syndrome_o == 7'h5a) ^ data_i[20];
-    data_o[21] = (syndrome_o == 7'h5b) ^ data_i[21];
-    data_o[22] = (syndrome_o == 7'h5c) ^ data_i[22];
-    data_o[23] = (syndrome_o == 7'h5d) ^ data_i[23];
-    data_o[24] = (syndrome_o == 7'h5e) ^ data_i[24];
-    data_o[25] = (syndrome_o == 7'h5f) ^ data_i[25];
-    data_o[26] = (syndrome_o == 7'h61) ^ data_i[26];
-    data_o[27] = (syndrome_o == 7'h62) ^ data_i[27];
-    data_o[28] = (syndrome_o == 7'h63) ^ data_i[28];
-    data_o[29] = (syndrome_o == 7'h64) ^ data_i[29];
-    data_o[30] = (syndrome_o == 7'h65) ^ data_i[30];
-    data_o[31] = (syndrome_o == 7'h66) ^ data_i[31];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = syndrome_o[6];
-    err_o[1] = |syndrome_o[5:0] & ~syndrome_o[6];
-  end
-endmodule : prim_secded_inv_hamming_39_32_dec
diff --git a/prim_secded_inv_hamming_39_32_enc.sv b/prim_secded_inv_hamming_39_32_enc.sv
deleted file mode 100644
index e939d4b9..00000000
--- a/prim_secded_inv_hamming_39_32_enc.sv
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_hamming_39_32_enc (
-  input        [31:0] data_i,
-  output logic [38:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 39'(data_i);
-    data_o[32] = 1'b0 ^ ^(data_o & 39'h0056AAAD5B);
-    data_o[33] = 1'b1 ^ ^(data_o & 39'h009B33366D);
-    data_o[34] = 1'b0 ^ ^(data_o & 39'h00E3C3C78E);
-    data_o[35] = 1'b1 ^ ^(data_o & 39'h0003FC07F0);
-    data_o[36] = 1'b0 ^ ^(data_o & 39'h0003FFF800);
-    data_o[37] = 1'b1 ^ ^(data_o & 39'h00FC000000);
-    data_o[38] = 1'b0 ^ ^(data_o & 39'h3FFFFFFFFF);
-  end
-
-endmodule : prim_secded_inv_hamming_39_32_enc
diff --git a/prim_secded_inv_hamming_72_64_dec.sv b/prim_secded_inv_hamming_72_64_dec.sv
deleted file mode 100644
index 99c2e5de..00000000
--- a/prim_secded_inv_hamming_72_64_dec.sv
+++ /dev/null
@@ -1,95 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_hamming_72_64_dec (
-  input        [71:0] data_i,
-  output logic [63:0] data_o,
-  output logic [7:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 72'hAA0000000000000000) & 72'h01AB55555556AAAD5B);
-    syndrome_o[1] = ^((data_i ^ 72'hAA0000000000000000) & 72'h02CD9999999B33366D);
-    syndrome_o[2] = ^((data_i ^ 72'hAA0000000000000000) & 72'h04F1E1E1E1E3C3C78E);
-    syndrome_o[3] = ^((data_i ^ 72'hAA0000000000000000) & 72'h0801FE01FE03FC07F0);
-    syndrome_o[4] = ^((data_i ^ 72'hAA0000000000000000) & 72'h1001FFFE0003FFF800);
-    syndrome_o[5] = ^((data_i ^ 72'hAA0000000000000000) & 72'h2001FFFFFFFC000000);
-    syndrome_o[6] = ^((data_i ^ 72'hAA0000000000000000) & 72'h40FE00000000000000);
-    syndrome_o[7] = ^((data_i ^ 72'hAA0000000000000000) & 72'hFFFFFFFFFFFFFFFFFF);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 8'h83) ^ data_i[0];
-    data_o[1] = (syndrome_o == 8'h85) ^ data_i[1];
-    data_o[2] = (syndrome_o == 8'h86) ^ data_i[2];
-    data_o[3] = (syndrome_o == 8'h87) ^ data_i[3];
-    data_o[4] = (syndrome_o == 8'h89) ^ data_i[4];
-    data_o[5] = (syndrome_o == 8'h8a) ^ data_i[5];
-    data_o[6] = (syndrome_o == 8'h8b) ^ data_i[6];
-    data_o[7] = (syndrome_o == 8'h8c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 8'h8d) ^ data_i[8];
-    data_o[9] = (syndrome_o == 8'h8e) ^ data_i[9];
-    data_o[10] = (syndrome_o == 8'h8f) ^ data_i[10];
-    data_o[11] = (syndrome_o == 8'h91) ^ data_i[11];
-    data_o[12] = (syndrome_o == 8'h92) ^ data_i[12];
-    data_o[13] = (syndrome_o == 8'h93) ^ data_i[13];
-    data_o[14] = (syndrome_o == 8'h94) ^ data_i[14];
-    data_o[15] = (syndrome_o == 8'h95) ^ data_i[15];
-    data_o[16] = (syndrome_o == 8'h96) ^ data_i[16];
-    data_o[17] = (syndrome_o == 8'h97) ^ data_i[17];
-    data_o[18] = (syndrome_o == 8'h98) ^ data_i[18];
-    data_o[19] = (syndrome_o == 8'h99) ^ data_i[19];
-    data_o[20] = (syndrome_o == 8'h9a) ^ data_i[20];
-    data_o[21] = (syndrome_o == 8'h9b) ^ data_i[21];
-    data_o[22] = (syndrome_o == 8'h9c) ^ data_i[22];
-    data_o[23] = (syndrome_o == 8'h9d) ^ data_i[23];
-    data_o[24] = (syndrome_o == 8'h9e) ^ data_i[24];
-    data_o[25] = (syndrome_o == 8'h9f) ^ data_i[25];
-    data_o[26] = (syndrome_o == 8'ha1) ^ data_i[26];
-    data_o[27] = (syndrome_o == 8'ha2) ^ data_i[27];
-    data_o[28] = (syndrome_o == 8'ha3) ^ data_i[28];
-    data_o[29] = (syndrome_o == 8'ha4) ^ data_i[29];
-    data_o[30] = (syndrome_o == 8'ha5) ^ data_i[30];
-    data_o[31] = (syndrome_o == 8'ha6) ^ data_i[31];
-    data_o[32] = (syndrome_o == 8'ha7) ^ data_i[32];
-    data_o[33] = (syndrome_o == 8'ha8) ^ data_i[33];
-    data_o[34] = (syndrome_o == 8'ha9) ^ data_i[34];
-    data_o[35] = (syndrome_o == 8'haa) ^ data_i[35];
-    data_o[36] = (syndrome_o == 8'hab) ^ data_i[36];
-    data_o[37] = (syndrome_o == 8'hac) ^ data_i[37];
-    data_o[38] = (syndrome_o == 8'had) ^ data_i[38];
-    data_o[39] = (syndrome_o == 8'hae) ^ data_i[39];
-    data_o[40] = (syndrome_o == 8'haf) ^ data_i[40];
-    data_o[41] = (syndrome_o == 8'hb0) ^ data_i[41];
-    data_o[42] = (syndrome_o == 8'hb1) ^ data_i[42];
-    data_o[43] = (syndrome_o == 8'hb2) ^ data_i[43];
-    data_o[44] = (syndrome_o == 8'hb3) ^ data_i[44];
-    data_o[45] = (syndrome_o == 8'hb4) ^ data_i[45];
-    data_o[46] = (syndrome_o == 8'hb5) ^ data_i[46];
-    data_o[47] = (syndrome_o == 8'hb6) ^ data_i[47];
-    data_o[48] = (syndrome_o == 8'hb7) ^ data_i[48];
-    data_o[49] = (syndrome_o == 8'hb8) ^ data_i[49];
-    data_o[50] = (syndrome_o == 8'hb9) ^ data_i[50];
-    data_o[51] = (syndrome_o == 8'hba) ^ data_i[51];
-    data_o[52] = (syndrome_o == 8'hbb) ^ data_i[52];
-    data_o[53] = (syndrome_o == 8'hbc) ^ data_i[53];
-    data_o[54] = (syndrome_o == 8'hbd) ^ data_i[54];
-    data_o[55] = (syndrome_o == 8'hbe) ^ data_i[55];
-    data_o[56] = (syndrome_o == 8'hbf) ^ data_i[56];
-    data_o[57] = (syndrome_o == 8'hc1) ^ data_i[57];
-    data_o[58] = (syndrome_o == 8'hc2) ^ data_i[58];
-    data_o[59] = (syndrome_o == 8'hc3) ^ data_i[59];
-    data_o[60] = (syndrome_o == 8'hc4) ^ data_i[60];
-    data_o[61] = (syndrome_o == 8'hc5) ^ data_i[61];
-    data_o[62] = (syndrome_o == 8'hc6) ^ data_i[62];
-    data_o[63] = (syndrome_o == 8'hc7) ^ data_i[63];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = syndrome_o[7];
-    err_o[1] = |syndrome_o[6:0] & ~syndrome_o[7];
-  end
-endmodule : prim_secded_inv_hamming_72_64_dec
diff --git a/prim_secded_inv_hamming_72_64_enc.sv b/prim_secded_inv_hamming_72_64_enc.sv
deleted file mode 100644
index a301e4b6..00000000
--- a/prim_secded_inv_hamming_72_64_enc.sv
+++ /dev/null
@@ -1,24 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_hamming_72_64_enc (
-  input        [63:0] data_i,
-  output logic [71:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 72'(data_i);
-    data_o[64] = 1'b0 ^ ^(data_o & 72'h00AB55555556AAAD5B);
-    data_o[65] = 1'b1 ^ ^(data_o & 72'h00CD9999999B33366D);
-    data_o[66] = 1'b0 ^ ^(data_o & 72'h00F1E1E1E1E3C3C78E);
-    data_o[67] = 1'b1 ^ ^(data_o & 72'h0001FE01FE03FC07F0);
-    data_o[68] = 1'b0 ^ ^(data_o & 72'h0001FFFE0003FFF800);
-    data_o[69] = 1'b1 ^ ^(data_o & 72'h0001FFFFFFFC000000);
-    data_o[70] = 1'b0 ^ ^(data_o & 72'h00FE00000000000000);
-    data_o[71] = 1'b1 ^ ^(data_o & 72'h7FFFFFFFFFFFFFFFFF);
-  end
-
-endmodule : prim_secded_inv_hamming_72_64_enc
diff --git a/prim_secded_inv_hamming_76_68_dec.sv b/prim_secded_inv_hamming_76_68_dec.sv
deleted file mode 100644
index c2aa75e4..00000000
--- a/prim_secded_inv_hamming_76_68_dec.sv
+++ /dev/null
@@ -1,99 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED decoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_hamming_76_68_dec (
-  input        [75:0] data_i,
-  output logic [67:0] data_o,
-  output logic [7:0] syndrome_o,
-  output logic [1:0] err_o
-);
-
-  always_comb begin : p_encode
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 76'hAA00000000000000000) & 76'h01AAB55555556AAAD5B);
-    syndrome_o[1] = ^((data_i ^ 76'hAA00000000000000000) & 76'h02CCD9999999B33366D);
-    syndrome_o[2] = ^((data_i ^ 76'hAA00000000000000000) & 76'h040F1E1E1E1E3C3C78E);
-    syndrome_o[3] = ^((data_i ^ 76'hAA00000000000000000) & 76'h08F01FE01FE03FC07F0);
-    syndrome_o[4] = ^((data_i ^ 76'hAA00000000000000000) & 76'h10001FFFE0003FFF800);
-    syndrome_o[5] = ^((data_i ^ 76'hAA00000000000000000) & 76'h20001FFFFFFFC000000);
-    syndrome_o[6] = ^((data_i ^ 76'hAA00000000000000000) & 76'h40FFE00000000000000);
-    syndrome_o[7] = ^((data_i ^ 76'hAA00000000000000000) & 76'hFFFFFFFFFFFFFFFFFFF);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 8'h83) ^ data_i[0];
-    data_o[1] = (syndrome_o == 8'h85) ^ data_i[1];
-    data_o[2] = (syndrome_o == 8'h86) ^ data_i[2];
-    data_o[3] = (syndrome_o == 8'h87) ^ data_i[3];
-    data_o[4] = (syndrome_o == 8'h89) ^ data_i[4];
-    data_o[5] = (syndrome_o == 8'h8a) ^ data_i[5];
-    data_o[6] = (syndrome_o == 8'h8b) ^ data_i[6];
-    data_o[7] = (syndrome_o == 8'h8c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 8'h8d) ^ data_i[8];
-    data_o[9] = (syndrome_o == 8'h8e) ^ data_i[9];
-    data_o[10] = (syndrome_o == 8'h8f) ^ data_i[10];
-    data_o[11] = (syndrome_o == 8'h91) ^ data_i[11];
-    data_o[12] = (syndrome_o == 8'h92) ^ data_i[12];
-    data_o[13] = (syndrome_o == 8'h93) ^ data_i[13];
-    data_o[14] = (syndrome_o == 8'h94) ^ data_i[14];
-    data_o[15] = (syndrome_o == 8'h95) ^ data_i[15];
-    data_o[16] = (syndrome_o == 8'h96) ^ data_i[16];
-    data_o[17] = (syndrome_o == 8'h97) ^ data_i[17];
-    data_o[18] = (syndrome_o == 8'h98) ^ data_i[18];
-    data_o[19] = (syndrome_o == 8'h99) ^ data_i[19];
-    data_o[20] = (syndrome_o == 8'h9a) ^ data_i[20];
-    data_o[21] = (syndrome_o == 8'h9b) ^ data_i[21];
-    data_o[22] = (syndrome_o == 8'h9c) ^ data_i[22];
-    data_o[23] = (syndrome_o == 8'h9d) ^ data_i[23];
-    data_o[24] = (syndrome_o == 8'h9e) ^ data_i[24];
-    data_o[25] = (syndrome_o == 8'h9f) ^ data_i[25];
-    data_o[26] = (syndrome_o == 8'ha1) ^ data_i[26];
-    data_o[27] = (syndrome_o == 8'ha2) ^ data_i[27];
-    data_o[28] = (syndrome_o == 8'ha3) ^ data_i[28];
-    data_o[29] = (syndrome_o == 8'ha4) ^ data_i[29];
-    data_o[30] = (syndrome_o == 8'ha5) ^ data_i[30];
-    data_o[31] = (syndrome_o == 8'ha6) ^ data_i[31];
-    data_o[32] = (syndrome_o == 8'ha7) ^ data_i[32];
-    data_o[33] = (syndrome_o == 8'ha8) ^ data_i[33];
-    data_o[34] = (syndrome_o == 8'ha9) ^ data_i[34];
-    data_o[35] = (syndrome_o == 8'haa) ^ data_i[35];
-    data_o[36] = (syndrome_o == 8'hab) ^ data_i[36];
-    data_o[37] = (syndrome_o == 8'hac) ^ data_i[37];
-    data_o[38] = (syndrome_o == 8'had) ^ data_i[38];
-    data_o[39] = (syndrome_o == 8'hae) ^ data_i[39];
-    data_o[40] = (syndrome_o == 8'haf) ^ data_i[40];
-    data_o[41] = (syndrome_o == 8'hb0) ^ data_i[41];
-    data_o[42] = (syndrome_o == 8'hb1) ^ data_i[42];
-    data_o[43] = (syndrome_o == 8'hb2) ^ data_i[43];
-    data_o[44] = (syndrome_o == 8'hb3) ^ data_i[44];
-    data_o[45] = (syndrome_o == 8'hb4) ^ data_i[45];
-    data_o[46] = (syndrome_o == 8'hb5) ^ data_i[46];
-    data_o[47] = (syndrome_o == 8'hb6) ^ data_i[47];
-    data_o[48] = (syndrome_o == 8'hb7) ^ data_i[48];
-    data_o[49] = (syndrome_o == 8'hb8) ^ data_i[49];
-    data_o[50] = (syndrome_o == 8'hb9) ^ data_i[50];
-    data_o[51] = (syndrome_o == 8'hba) ^ data_i[51];
-    data_o[52] = (syndrome_o == 8'hbb) ^ data_i[52];
-    data_o[53] = (syndrome_o == 8'hbc) ^ data_i[53];
-    data_o[54] = (syndrome_o == 8'hbd) ^ data_i[54];
-    data_o[55] = (syndrome_o == 8'hbe) ^ data_i[55];
-    data_o[56] = (syndrome_o == 8'hbf) ^ data_i[56];
-    data_o[57] = (syndrome_o == 8'hc1) ^ data_i[57];
-    data_o[58] = (syndrome_o == 8'hc2) ^ data_i[58];
-    data_o[59] = (syndrome_o == 8'hc3) ^ data_i[59];
-    data_o[60] = (syndrome_o == 8'hc4) ^ data_i[60];
-    data_o[61] = (syndrome_o == 8'hc5) ^ data_i[61];
-    data_o[62] = (syndrome_o == 8'hc6) ^ data_i[62];
-    data_o[63] = (syndrome_o == 8'hc7) ^ data_i[63];
-    data_o[64] = (syndrome_o == 8'hc8) ^ data_i[64];
-    data_o[65] = (syndrome_o == 8'hc9) ^ data_i[65];
-    data_o[66] = (syndrome_o == 8'hca) ^ data_i[66];
-    data_o[67] = (syndrome_o == 8'hcb) ^ data_i[67];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = syndrome_o[7];
-    err_o[1] = |syndrome_o[6:0] & ~syndrome_o[7];
-  end
-endmodule : prim_secded_inv_hamming_76_68_dec
diff --git a/prim_secded_inv_hamming_76_68_enc.sv b/prim_secded_inv_hamming_76_68_enc.sv
deleted file mode 100644
index fa075174..00000000
--- a/prim_secded_inv_hamming_76_68_enc.sv
+++ /dev/null
@@ -1,24 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED encoder generated by util/design/secded_gen.py
-
-module prim_secded_inv_hamming_76_68_enc (
-  input        [67:0] data_i,
-  output logic [75:0] data_o
-);
-
-  always_comb begin : p_encode
-    data_o = 76'(data_i);
-    data_o[68] = 1'b0 ^ ^(data_o & 76'h00AAB55555556AAAD5B);
-    data_o[69] = 1'b1 ^ ^(data_o & 76'h00CCD9999999B33366D);
-    data_o[70] = 1'b0 ^ ^(data_o & 76'h000F1E1E1E1E3C3C78E);
-    data_o[71] = 1'b1 ^ ^(data_o & 76'h00F01FE01FE03FC07F0);
-    data_o[72] = 1'b0 ^ ^(data_o & 76'h00001FFFE0003FFF800);
-    data_o[73] = 1'b1 ^ ^(data_o & 76'h00001FFFFFFFC000000);
-    data_o[74] = 1'b0 ^ ^(data_o & 76'h00FFE00000000000000);
-    data_o[75] = 1'b1 ^ ^(data_o & 76'h7FFFFFFFFFFFFFFFFFF);
-  end
-
-endmodule : prim_secded_inv_hamming_76_68_enc
diff --git a/prim_secded_pkg.sv b/prim_secded_pkg.sv
deleted file mode 100644
index 5f227e6e..00000000
--- a/prim_secded_pkg.sv
+++ /dev/null
@@ -1,1778 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// SECDED package generated by
-// util/design/secded_gen.py from util/design/data/secded_cfg.hjson
-
-package prim_secded_pkg;
-
-  typedef enum int {
-    SecdedNone,
-    Secded_22_16,
-    Secded_28_22,
-    Secded_39_32,
-    Secded_64_57,
-    Secded_72_64,
-    SecdedHamming_22_16,
-    SecdedHamming_39_32,
-    SecdedHamming_72_64,
-    SecdedHamming_76_68,
-    SecdedInv_22_16,
-    SecdedInv_28_22,
-    SecdedInv_39_32,
-    SecdedInv_64_57,
-    SecdedInv_72_64,
-    SecdedInvHamming_22_16,
-    SecdedInvHamming_39_32,
-    SecdedInvHamming_72_64,
-    SecdedInvHamming_76_68
-  } prim_secded_e;
-
-  function automatic int get_ecc_data_width(prim_secded_e ecc_type);
-    case (ecc_type)
-      Secded_22_16: return 16;
-      Secded_28_22: return 22;
-      Secded_39_32: return 32;
-      Secded_64_57: return 57;
-      Secded_72_64: return 64;
-      SecdedHamming_22_16: return 16;
-      SecdedHamming_39_32: return 32;
-      SecdedHamming_72_64: return 64;
-      SecdedHamming_76_68: return 68;
-      SecdedInv_22_16: return 16;
-      SecdedInv_28_22: return 22;
-      SecdedInv_39_32: return 32;
-      SecdedInv_64_57: return 57;
-      SecdedInv_72_64: return 64;
-      SecdedInvHamming_22_16: return 16;
-      SecdedInvHamming_39_32: return 32;
-      SecdedInvHamming_72_64: return 64;
-      SecdedInvHamming_76_68: return 68;
-      // Return a non-zero width to avoid VCS compile issues
-      default: return 32;
-    endcase
-  endfunction
-
-  function automatic int get_ecc_parity_width(prim_secded_e ecc_type);
-    case (ecc_type)
-      Secded_22_16: return 6;
-      Secded_28_22: return 6;
-      Secded_39_32: return 7;
-      Secded_64_57: return 7;
-      Secded_72_64: return 8;
-      SecdedHamming_22_16: return 6;
-      SecdedHamming_39_32: return 7;
-      SecdedHamming_72_64: return 8;
-      SecdedHamming_76_68: return 8;
-      SecdedInv_22_16: return 6;
-      SecdedInv_28_22: return 6;
-      SecdedInv_39_32: return 7;
-      SecdedInv_64_57: return 7;
-      SecdedInv_72_64: return 8;
-      SecdedInvHamming_22_16: return 6;
-      SecdedInvHamming_39_32: return 7;
-      SecdedInvHamming_72_64: return 8;
-      SecdedInvHamming_76_68: return 8;
-      default: return 0;
-    endcase
-  endfunction
-
-  parameter logic [5:0] Secded2216ZeroEcc = 6'h0;
-  parameter logic [21:0] Secded2216ZeroWord = 22'h0;
-
-  typedef struct packed {
-    logic [15:0] data;
-    logic [5:0] syndrome;
-    logic [1:0]  err;
-  } secded_22_16_t;
-
-  parameter logic [5:0] Secded2822ZeroEcc = 6'h0;
-  parameter logic [27:0] Secded2822ZeroWord = 28'h0;
-
-  typedef struct packed {
-    logic [21:0] data;
-    logic [5:0] syndrome;
-    logic [1:0]  err;
-  } secded_28_22_t;
-
-  parameter logic [6:0] Secded3932ZeroEcc = 7'h0;
-  parameter logic [38:0] Secded3932ZeroWord = 39'h0;
-
-  typedef struct packed {
-    logic [31:0] data;
-    logic [6:0] syndrome;
-    logic [1:0]  err;
-  } secded_39_32_t;
-
-  parameter logic [6:0] Secded6457ZeroEcc = 7'h0;
-  parameter logic [63:0] Secded6457ZeroWord = 64'h0;
-
-  typedef struct packed {
-    logic [56:0] data;
-    logic [6:0] syndrome;
-    logic [1:0]  err;
-  } secded_64_57_t;
-
-  parameter logic [7:0] Secded7264ZeroEcc = 8'h0;
-  parameter logic [71:0] Secded7264ZeroWord = 72'h0;
-
-  typedef struct packed {
-    logic [63:0] data;
-    logic [7:0] syndrome;
-    logic [1:0]  err;
-  } secded_72_64_t;
-
-  parameter logic [5:0] SecdedHamming2216ZeroEcc = 6'h0;
-  parameter logic [21:0] SecdedHamming2216ZeroWord = 22'h0;
-
-  typedef struct packed {
-    logic [15:0] data;
-    logic [5:0] syndrome;
-    logic [1:0]  err;
-  } secded_hamming_22_16_t;
-
-  parameter logic [6:0] SecdedHamming3932ZeroEcc = 7'h0;
-  parameter logic [38:0] SecdedHamming3932ZeroWord = 39'h0;
-
-  typedef struct packed {
-    logic [31:0] data;
-    logic [6:0] syndrome;
-    logic [1:0]  err;
-  } secded_hamming_39_32_t;
-
-  parameter logic [7:0] SecdedHamming7264ZeroEcc = 8'h0;
-  parameter logic [71:0] SecdedHamming7264ZeroWord = 72'h0;
-
-  typedef struct packed {
-    logic [63:0] data;
-    logic [7:0] syndrome;
-    logic [1:0]  err;
-  } secded_hamming_72_64_t;
-
-  parameter logic [7:0] SecdedHamming7668ZeroEcc = 8'h0;
-  parameter logic [75:0] SecdedHamming7668ZeroWord = 76'h0;
-
-  typedef struct packed {
-    logic [67:0] data;
-    logic [7:0] syndrome;
-    logic [1:0]  err;
-  } secded_hamming_76_68_t;
-
-  parameter logic [5:0] SecdedInv2216ZeroEcc = 6'h2A;
-  parameter logic [21:0] SecdedInv2216ZeroWord = 22'h2A0000;
-
-  typedef struct packed {
-    logic [15:0] data;
-    logic [5:0] syndrome;
-    logic [1:0]  err;
-  } secded_inv_22_16_t;
-
-  parameter logic [5:0] SecdedInv2822ZeroEcc = 6'h2A;
-  parameter logic [27:0] SecdedInv2822ZeroWord = 28'hA800000;
-
-  typedef struct packed {
-    logic [21:0] data;
-    logic [5:0] syndrome;
-    logic [1:0]  err;
-  } secded_inv_28_22_t;
-
-  parameter logic [6:0] SecdedInv3932ZeroEcc = 7'h2A;
-  parameter logic [38:0] SecdedInv3932ZeroWord = 39'h2A00000000;
-
-  typedef struct packed {
-    logic [31:0] data;
-    logic [6:0] syndrome;
-    logic [1:0]  err;
-  } secded_inv_39_32_t;
-
-  parameter logic [6:0] SecdedInv6457ZeroEcc = 7'h2A;
-  parameter logic [63:0] SecdedInv6457ZeroWord = 64'h5400000000000000;
-
-  typedef struct packed {
-    logic [56:0] data;
-    logic [6:0] syndrome;
-    logic [1:0]  err;
-  } secded_inv_64_57_t;
-
-  parameter logic [7:0] SecdedInv7264ZeroEcc = 8'hAA;
-  parameter logic [71:0] SecdedInv7264ZeroWord = 72'hAA0000000000000000;
-
-  typedef struct packed {
-    logic [63:0] data;
-    logic [7:0] syndrome;
-    logic [1:0]  err;
-  } secded_inv_72_64_t;
-
-  parameter logic [5:0] SecdedInvHamming2216ZeroEcc = 6'h2A;
-  parameter logic [21:0] SecdedInvHamming2216ZeroWord = 22'h2A0000;
-
-  typedef struct packed {
-    logic [15:0] data;
-    logic [5:0] syndrome;
-    logic [1:0]  err;
-  } secded_inv_hamming_22_16_t;
-
-  parameter logic [6:0] SecdedInvHamming3932ZeroEcc = 7'h2A;
-  parameter logic [38:0] SecdedInvHamming3932ZeroWord = 39'h2A00000000;
-
-  typedef struct packed {
-    logic [31:0] data;
-    logic [6:0] syndrome;
-    logic [1:0]  err;
-  } secded_inv_hamming_39_32_t;
-
-  parameter logic [7:0] SecdedInvHamming7264ZeroEcc = 8'hAA;
-  parameter logic [71:0] SecdedInvHamming7264ZeroWord = 72'hAA0000000000000000;
-
-  typedef struct packed {
-    logic [63:0] data;
-    logic [7:0] syndrome;
-    logic [1:0]  err;
-  } secded_inv_hamming_72_64_t;
-
-  parameter logic [7:0] SecdedInvHamming7668ZeroEcc = 8'hAA;
-  parameter logic [75:0] SecdedInvHamming7668ZeroWord = 76'hAA00000000000000000;
-
-  typedef struct packed {
-    logic [67:0] data;
-    logic [7:0] syndrome;
-    logic [1:0]  err;
-  } secded_inv_hamming_76_68_t;
-
-  function automatic logic [21:0]
-      prim_secded_22_16_enc (logic [15:0] data_i);
-    logic [21:0] data_o;
-    data_o = 22'(data_i);
-    data_o[16] = 1'b0 ^ ^(data_o & 22'h00496E);
-    data_o[17] = 1'b0 ^ ^(data_o & 22'h00F20B);
-    data_o[18] = 1'b0 ^ ^(data_o & 22'h008ED8);
-    data_o[19] = 1'b0 ^ ^(data_o & 22'h007714);
-    data_o[20] = 1'b0 ^ ^(data_o & 22'h00ACA5);
-    data_o[21] = 1'b0 ^ ^(data_o & 22'h0011F3);
-    return data_o;
-  endfunction
-
-  function automatic secded_22_16_t
-      prim_secded_22_16_dec (logic [21:0] data_i);
-    logic [15:0] data_o;
-    logic [5:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_22_16_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 22'h01496E);
-    syndrome_o[1] = ^(data_i & 22'h02F20B);
-    syndrome_o[2] = ^(data_i & 22'h048ED8);
-    syndrome_o[3] = ^(data_i & 22'h087714);
-    syndrome_o[4] = ^(data_i & 22'h10ACA5);
-    syndrome_o[5] = ^(data_i & 22'h2011F3);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 6'h32) ^ data_i[0];
-    data_o[1] = (syndrome_o == 6'h23) ^ data_i[1];
-    data_o[2] = (syndrome_o == 6'h19) ^ data_i[2];
-    data_o[3] = (syndrome_o == 6'h7) ^ data_i[3];
-    data_o[4] = (syndrome_o == 6'h2c) ^ data_i[4];
-    data_o[5] = (syndrome_o == 6'h31) ^ data_i[5];
-    data_o[6] = (syndrome_o == 6'h25) ^ data_i[6];
-    data_o[7] = (syndrome_o == 6'h34) ^ data_i[7];
-    data_o[8] = (syndrome_o == 6'h29) ^ data_i[8];
-    data_o[9] = (syndrome_o == 6'he) ^ data_i[9];
-    data_o[10] = (syndrome_o == 6'h1c) ^ data_i[10];
-    data_o[11] = (syndrome_o == 6'h15) ^ data_i[11];
-    data_o[12] = (syndrome_o == 6'h2a) ^ data_i[12];
-    data_o[13] = (syndrome_o == 6'h1a) ^ data_i[13];
-    data_o[14] = (syndrome_o == 6'hb) ^ data_i[14];
-    data_o[15] = (syndrome_o == 6'h16) ^ data_i[15];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [27:0]
-      prim_secded_28_22_enc (logic [21:0] data_i);
-    logic [27:0] data_o;
-    data_o = 28'(data_i);
-    data_o[22] = 1'b0 ^ ^(data_o & 28'h03003FF);
-    data_o[23] = 1'b0 ^ ^(data_o & 28'h010FC0F);
-    data_o[24] = 1'b0 ^ ^(data_o & 28'h0271C71);
-    data_o[25] = 1'b0 ^ ^(data_o & 28'h03B6592);
-    data_o[26] = 1'b0 ^ ^(data_o & 28'h03DAAA4);
-    data_o[27] = 1'b0 ^ ^(data_o & 28'h03ED348);
-    return data_o;
-  endfunction
-
-  function automatic secded_28_22_t
-      prim_secded_28_22_dec (logic [27:0] data_i);
-    logic [21:0] data_o;
-    logic [5:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_28_22_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 28'h07003FF);
-    syndrome_o[1] = ^(data_i & 28'h090FC0F);
-    syndrome_o[2] = ^(data_i & 28'h1271C71);
-    syndrome_o[3] = ^(data_i & 28'h23B6592);
-    syndrome_o[4] = ^(data_i & 28'h43DAAA4);
-    syndrome_o[5] = ^(data_i & 28'h83ED348);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 6'h7) ^ data_i[0];
-    data_o[1] = (syndrome_o == 6'hb) ^ data_i[1];
-    data_o[2] = (syndrome_o == 6'h13) ^ data_i[2];
-    data_o[3] = (syndrome_o == 6'h23) ^ data_i[3];
-    data_o[4] = (syndrome_o == 6'hd) ^ data_i[4];
-    data_o[5] = (syndrome_o == 6'h15) ^ data_i[5];
-    data_o[6] = (syndrome_o == 6'h25) ^ data_i[6];
-    data_o[7] = (syndrome_o == 6'h19) ^ data_i[7];
-    data_o[8] = (syndrome_o == 6'h29) ^ data_i[8];
-    data_o[9] = (syndrome_o == 6'h31) ^ data_i[9];
-    data_o[10] = (syndrome_o == 6'he) ^ data_i[10];
-    data_o[11] = (syndrome_o == 6'h16) ^ data_i[11];
-    data_o[12] = (syndrome_o == 6'h26) ^ data_i[12];
-    data_o[13] = (syndrome_o == 6'h1a) ^ data_i[13];
-    data_o[14] = (syndrome_o == 6'h2a) ^ data_i[14];
-    data_o[15] = (syndrome_o == 6'h32) ^ data_i[15];
-    data_o[16] = (syndrome_o == 6'h1c) ^ data_i[16];
-    data_o[17] = (syndrome_o == 6'h2c) ^ data_i[17];
-    data_o[18] = (syndrome_o == 6'h34) ^ data_i[18];
-    data_o[19] = (syndrome_o == 6'h38) ^ data_i[19];
-    data_o[20] = (syndrome_o == 6'h3b) ^ data_i[20];
-    data_o[21] = (syndrome_o == 6'h3d) ^ data_i[21];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [38:0]
-      prim_secded_39_32_enc (logic [31:0] data_i);
-    logic [38:0] data_o;
-    data_o = 39'(data_i);
-    data_o[32] = 1'b0 ^ ^(data_o & 39'h002606BD25);
-    data_o[33] = 1'b0 ^ ^(data_o & 39'h00DEBA8050);
-    data_o[34] = 1'b0 ^ ^(data_o & 39'h00413D89AA);
-    data_o[35] = 1'b0 ^ ^(data_o & 39'h0031234ED1);
-    data_o[36] = 1'b0 ^ ^(data_o & 39'h00C2C1323B);
-    data_o[37] = 1'b0 ^ ^(data_o & 39'h002DCC624C);
-    data_o[38] = 1'b0 ^ ^(data_o & 39'h0098505586);
-    return data_o;
-  endfunction
-
-  function automatic secded_39_32_t
-      prim_secded_39_32_dec (logic [38:0] data_i);
-    logic [31:0] data_o;
-    logic [6:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_39_32_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 39'h012606BD25);
-    syndrome_o[1] = ^(data_i & 39'h02DEBA8050);
-    syndrome_o[2] = ^(data_i & 39'h04413D89AA);
-    syndrome_o[3] = ^(data_i & 39'h0831234ED1);
-    syndrome_o[4] = ^(data_i & 39'h10C2C1323B);
-    syndrome_o[5] = ^(data_i & 39'h202DCC624C);
-    syndrome_o[6] = ^(data_i & 39'h4098505586);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 7'h19) ^ data_i[0];
-    data_o[1] = (syndrome_o == 7'h54) ^ data_i[1];
-    data_o[2] = (syndrome_o == 7'h61) ^ data_i[2];
-    data_o[3] = (syndrome_o == 7'h34) ^ data_i[3];
-    data_o[4] = (syndrome_o == 7'h1a) ^ data_i[4];
-    data_o[5] = (syndrome_o == 7'h15) ^ data_i[5];
-    data_o[6] = (syndrome_o == 7'h2a) ^ data_i[6];
-    data_o[7] = (syndrome_o == 7'h4c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 7'h45) ^ data_i[8];
-    data_o[9] = (syndrome_o == 7'h38) ^ data_i[9];
-    data_o[10] = (syndrome_o == 7'h49) ^ data_i[10];
-    data_o[11] = (syndrome_o == 7'hd) ^ data_i[11];
-    data_o[12] = (syndrome_o == 7'h51) ^ data_i[12];
-    data_o[13] = (syndrome_o == 7'h31) ^ data_i[13];
-    data_o[14] = (syndrome_o == 7'h68) ^ data_i[14];
-    data_o[15] = (syndrome_o == 7'h7) ^ data_i[15];
-    data_o[16] = (syndrome_o == 7'h1c) ^ data_i[16];
-    data_o[17] = (syndrome_o == 7'hb) ^ data_i[17];
-    data_o[18] = (syndrome_o == 7'h25) ^ data_i[18];
-    data_o[19] = (syndrome_o == 7'h26) ^ data_i[19];
-    data_o[20] = (syndrome_o == 7'h46) ^ data_i[20];
-    data_o[21] = (syndrome_o == 7'he) ^ data_i[21];
-    data_o[22] = (syndrome_o == 7'h70) ^ data_i[22];
-    data_o[23] = (syndrome_o == 7'h32) ^ data_i[23];
-    data_o[24] = (syndrome_o == 7'h2c) ^ data_i[24];
-    data_o[25] = (syndrome_o == 7'h13) ^ data_i[25];
-    data_o[26] = (syndrome_o == 7'h23) ^ data_i[26];
-    data_o[27] = (syndrome_o == 7'h62) ^ data_i[27];
-    data_o[28] = (syndrome_o == 7'h4a) ^ data_i[28];
-    data_o[29] = (syndrome_o == 7'h29) ^ data_i[29];
-    data_o[30] = (syndrome_o == 7'h16) ^ data_i[30];
-    data_o[31] = (syndrome_o == 7'h52) ^ data_i[31];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [63:0]
-      prim_secded_64_57_enc (logic [56:0] data_i);
-    logic [63:0] data_o;
-    data_o = 64'(data_i);
-    data_o[57] = 1'b0 ^ ^(data_o & 64'h0103FFF800007FFF);
-    data_o[58] = 1'b0 ^ ^(data_o & 64'h017C1FF801FF801F);
-    data_o[59] = 1'b0 ^ ^(data_o & 64'h01BDE1F87E0781E1);
-    data_o[60] = 1'b0 ^ ^(data_o & 64'h01DEEE3B8E388E22);
-    data_o[61] = 1'b0 ^ ^(data_o & 64'h01EF76CDB2C93244);
-    data_o[62] = 1'b0 ^ ^(data_o & 64'h01F7BB56D5525488);
-    data_o[63] = 1'b0 ^ ^(data_o & 64'h01FBDDA769A46910);
-    return data_o;
-  endfunction
-
-  function automatic secded_64_57_t
-      prim_secded_64_57_dec (logic [63:0] data_i);
-    logic [56:0] data_o;
-    logic [6:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_64_57_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 64'h0303FFF800007FFF);
-    syndrome_o[1] = ^(data_i & 64'h057C1FF801FF801F);
-    syndrome_o[2] = ^(data_i & 64'h09BDE1F87E0781E1);
-    syndrome_o[3] = ^(data_i & 64'h11DEEE3B8E388E22);
-    syndrome_o[4] = ^(data_i & 64'h21EF76CDB2C93244);
-    syndrome_o[5] = ^(data_i & 64'h41F7BB56D5525488);
-    syndrome_o[6] = ^(data_i & 64'h81FBDDA769A46910);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 7'h7) ^ data_i[0];
-    data_o[1] = (syndrome_o == 7'hb) ^ data_i[1];
-    data_o[2] = (syndrome_o == 7'h13) ^ data_i[2];
-    data_o[3] = (syndrome_o == 7'h23) ^ data_i[3];
-    data_o[4] = (syndrome_o == 7'h43) ^ data_i[4];
-    data_o[5] = (syndrome_o == 7'hd) ^ data_i[5];
-    data_o[6] = (syndrome_o == 7'h15) ^ data_i[6];
-    data_o[7] = (syndrome_o == 7'h25) ^ data_i[7];
-    data_o[8] = (syndrome_o == 7'h45) ^ data_i[8];
-    data_o[9] = (syndrome_o == 7'h19) ^ data_i[9];
-    data_o[10] = (syndrome_o == 7'h29) ^ data_i[10];
-    data_o[11] = (syndrome_o == 7'h49) ^ data_i[11];
-    data_o[12] = (syndrome_o == 7'h31) ^ data_i[12];
-    data_o[13] = (syndrome_o == 7'h51) ^ data_i[13];
-    data_o[14] = (syndrome_o == 7'h61) ^ data_i[14];
-    data_o[15] = (syndrome_o == 7'he) ^ data_i[15];
-    data_o[16] = (syndrome_o == 7'h16) ^ data_i[16];
-    data_o[17] = (syndrome_o == 7'h26) ^ data_i[17];
-    data_o[18] = (syndrome_o == 7'h46) ^ data_i[18];
-    data_o[19] = (syndrome_o == 7'h1a) ^ data_i[19];
-    data_o[20] = (syndrome_o == 7'h2a) ^ data_i[20];
-    data_o[21] = (syndrome_o == 7'h4a) ^ data_i[21];
-    data_o[22] = (syndrome_o == 7'h32) ^ data_i[22];
-    data_o[23] = (syndrome_o == 7'h52) ^ data_i[23];
-    data_o[24] = (syndrome_o == 7'h62) ^ data_i[24];
-    data_o[25] = (syndrome_o == 7'h1c) ^ data_i[25];
-    data_o[26] = (syndrome_o == 7'h2c) ^ data_i[26];
-    data_o[27] = (syndrome_o == 7'h4c) ^ data_i[27];
-    data_o[28] = (syndrome_o == 7'h34) ^ data_i[28];
-    data_o[29] = (syndrome_o == 7'h54) ^ data_i[29];
-    data_o[30] = (syndrome_o == 7'h64) ^ data_i[30];
-    data_o[31] = (syndrome_o == 7'h38) ^ data_i[31];
-    data_o[32] = (syndrome_o == 7'h58) ^ data_i[32];
-    data_o[33] = (syndrome_o == 7'h68) ^ data_i[33];
-    data_o[34] = (syndrome_o == 7'h70) ^ data_i[34];
-    data_o[35] = (syndrome_o == 7'h1f) ^ data_i[35];
-    data_o[36] = (syndrome_o == 7'h2f) ^ data_i[36];
-    data_o[37] = (syndrome_o == 7'h4f) ^ data_i[37];
-    data_o[38] = (syndrome_o == 7'h37) ^ data_i[38];
-    data_o[39] = (syndrome_o == 7'h57) ^ data_i[39];
-    data_o[40] = (syndrome_o == 7'h67) ^ data_i[40];
-    data_o[41] = (syndrome_o == 7'h3b) ^ data_i[41];
-    data_o[42] = (syndrome_o == 7'h5b) ^ data_i[42];
-    data_o[43] = (syndrome_o == 7'h6b) ^ data_i[43];
-    data_o[44] = (syndrome_o == 7'h73) ^ data_i[44];
-    data_o[45] = (syndrome_o == 7'h3d) ^ data_i[45];
-    data_o[46] = (syndrome_o == 7'h5d) ^ data_i[46];
-    data_o[47] = (syndrome_o == 7'h6d) ^ data_i[47];
-    data_o[48] = (syndrome_o == 7'h75) ^ data_i[48];
-    data_o[49] = (syndrome_o == 7'h79) ^ data_i[49];
-    data_o[50] = (syndrome_o == 7'h3e) ^ data_i[50];
-    data_o[51] = (syndrome_o == 7'h5e) ^ data_i[51];
-    data_o[52] = (syndrome_o == 7'h6e) ^ data_i[52];
-    data_o[53] = (syndrome_o == 7'h76) ^ data_i[53];
-    data_o[54] = (syndrome_o == 7'h7a) ^ data_i[54];
-    data_o[55] = (syndrome_o == 7'h7c) ^ data_i[55];
-    data_o[56] = (syndrome_o == 7'h7f) ^ data_i[56];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [71:0]
-      prim_secded_72_64_enc (logic [63:0] data_i);
-    logic [71:0] data_o;
-    data_o = 72'(data_i);
-    data_o[64] = 1'b0 ^ ^(data_o & 72'h00B9000000001FFFFF);
-    data_o[65] = 1'b0 ^ ^(data_o & 72'h005E00000FFFE0003F);
-    data_o[66] = 1'b0 ^ ^(data_o & 72'h0067003FF003E007C1);
-    data_o[67] = 1'b0 ^ ^(data_o & 72'h00CD0FC0F03C207842);
-    data_o[68] = 1'b0 ^ ^(data_o & 72'h00B671C711C4438884);
-    data_o[69] = 1'b0 ^ ^(data_o & 72'h00B5B65926488C9108);
-    data_o[70] = 1'b0 ^ ^(data_o & 72'h00CBDAAA4A91152210);
-    data_o[71] = 1'b0 ^ ^(data_o & 72'h007AED348D221A4420);
-    return data_o;
-  endfunction
-
-  function automatic secded_72_64_t
-      prim_secded_72_64_dec (logic [71:0] data_i);
-    logic [63:0] data_o;
-    logic [7:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_72_64_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 72'h01B9000000001FFFFF);
-    syndrome_o[1] = ^(data_i & 72'h025E00000FFFE0003F);
-    syndrome_o[2] = ^(data_i & 72'h0467003FF003E007C1);
-    syndrome_o[3] = ^(data_i & 72'h08CD0FC0F03C207842);
-    syndrome_o[4] = ^(data_i & 72'h10B671C711C4438884);
-    syndrome_o[5] = ^(data_i & 72'h20B5B65926488C9108);
-    syndrome_o[6] = ^(data_i & 72'h40CBDAAA4A91152210);
-    syndrome_o[7] = ^(data_i & 72'h807AED348D221A4420);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 8'h7) ^ data_i[0];
-    data_o[1] = (syndrome_o == 8'hb) ^ data_i[1];
-    data_o[2] = (syndrome_o == 8'h13) ^ data_i[2];
-    data_o[3] = (syndrome_o == 8'h23) ^ data_i[3];
-    data_o[4] = (syndrome_o == 8'h43) ^ data_i[4];
-    data_o[5] = (syndrome_o == 8'h83) ^ data_i[5];
-    data_o[6] = (syndrome_o == 8'hd) ^ data_i[6];
-    data_o[7] = (syndrome_o == 8'h15) ^ data_i[7];
-    data_o[8] = (syndrome_o == 8'h25) ^ data_i[8];
-    data_o[9] = (syndrome_o == 8'h45) ^ data_i[9];
-    data_o[10] = (syndrome_o == 8'h85) ^ data_i[10];
-    data_o[11] = (syndrome_o == 8'h19) ^ data_i[11];
-    data_o[12] = (syndrome_o == 8'h29) ^ data_i[12];
-    data_o[13] = (syndrome_o == 8'h49) ^ data_i[13];
-    data_o[14] = (syndrome_o == 8'h89) ^ data_i[14];
-    data_o[15] = (syndrome_o == 8'h31) ^ data_i[15];
-    data_o[16] = (syndrome_o == 8'h51) ^ data_i[16];
-    data_o[17] = (syndrome_o == 8'h91) ^ data_i[17];
-    data_o[18] = (syndrome_o == 8'h61) ^ data_i[18];
-    data_o[19] = (syndrome_o == 8'ha1) ^ data_i[19];
-    data_o[20] = (syndrome_o == 8'hc1) ^ data_i[20];
-    data_o[21] = (syndrome_o == 8'he) ^ data_i[21];
-    data_o[22] = (syndrome_o == 8'h16) ^ data_i[22];
-    data_o[23] = (syndrome_o == 8'h26) ^ data_i[23];
-    data_o[24] = (syndrome_o == 8'h46) ^ data_i[24];
-    data_o[25] = (syndrome_o == 8'h86) ^ data_i[25];
-    data_o[26] = (syndrome_o == 8'h1a) ^ data_i[26];
-    data_o[27] = (syndrome_o == 8'h2a) ^ data_i[27];
-    data_o[28] = (syndrome_o == 8'h4a) ^ data_i[28];
-    data_o[29] = (syndrome_o == 8'h8a) ^ data_i[29];
-    data_o[30] = (syndrome_o == 8'h32) ^ data_i[30];
-    data_o[31] = (syndrome_o == 8'h52) ^ data_i[31];
-    data_o[32] = (syndrome_o == 8'h92) ^ data_i[32];
-    data_o[33] = (syndrome_o == 8'h62) ^ data_i[33];
-    data_o[34] = (syndrome_o == 8'ha2) ^ data_i[34];
-    data_o[35] = (syndrome_o == 8'hc2) ^ data_i[35];
-    data_o[36] = (syndrome_o == 8'h1c) ^ data_i[36];
-    data_o[37] = (syndrome_o == 8'h2c) ^ data_i[37];
-    data_o[38] = (syndrome_o == 8'h4c) ^ data_i[38];
-    data_o[39] = (syndrome_o == 8'h8c) ^ data_i[39];
-    data_o[40] = (syndrome_o == 8'h34) ^ data_i[40];
-    data_o[41] = (syndrome_o == 8'h54) ^ data_i[41];
-    data_o[42] = (syndrome_o == 8'h94) ^ data_i[42];
-    data_o[43] = (syndrome_o == 8'h64) ^ data_i[43];
-    data_o[44] = (syndrome_o == 8'ha4) ^ data_i[44];
-    data_o[45] = (syndrome_o == 8'hc4) ^ data_i[45];
-    data_o[46] = (syndrome_o == 8'h38) ^ data_i[46];
-    data_o[47] = (syndrome_o == 8'h58) ^ data_i[47];
-    data_o[48] = (syndrome_o == 8'h98) ^ data_i[48];
-    data_o[49] = (syndrome_o == 8'h68) ^ data_i[49];
-    data_o[50] = (syndrome_o == 8'ha8) ^ data_i[50];
-    data_o[51] = (syndrome_o == 8'hc8) ^ data_i[51];
-    data_o[52] = (syndrome_o == 8'h70) ^ data_i[52];
-    data_o[53] = (syndrome_o == 8'hb0) ^ data_i[53];
-    data_o[54] = (syndrome_o == 8'hd0) ^ data_i[54];
-    data_o[55] = (syndrome_o == 8'he0) ^ data_i[55];
-    data_o[56] = (syndrome_o == 8'h6d) ^ data_i[56];
-    data_o[57] = (syndrome_o == 8'hd6) ^ data_i[57];
-    data_o[58] = (syndrome_o == 8'h3e) ^ data_i[58];
-    data_o[59] = (syndrome_o == 8'hcb) ^ data_i[59];
-    data_o[60] = (syndrome_o == 8'hb3) ^ data_i[60];
-    data_o[61] = (syndrome_o == 8'hb5) ^ data_i[61];
-    data_o[62] = (syndrome_o == 8'hce) ^ data_i[62];
-    data_o[63] = (syndrome_o == 8'h79) ^ data_i[63];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [21:0]
-      prim_secded_hamming_22_16_enc (logic [15:0] data_i);
-    logic [21:0] data_o;
-    data_o = 22'(data_i);
-    data_o[16] = 1'b0 ^ ^(data_o & 22'h00AD5B);
-    data_o[17] = 1'b0 ^ ^(data_o & 22'h00366D);
-    data_o[18] = 1'b0 ^ ^(data_o & 22'h00C78E);
-    data_o[19] = 1'b0 ^ ^(data_o & 22'h0007F0);
-    data_o[20] = 1'b0 ^ ^(data_o & 22'h00F800);
-    data_o[21] = 1'b0 ^ ^(data_o & 22'h1FFFFF);
-    return data_o;
-  endfunction
-
-  function automatic secded_hamming_22_16_t
-      prim_secded_hamming_22_16_dec (logic [21:0] data_i);
-    logic [15:0] data_o;
-    logic [5:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_hamming_22_16_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 22'h01AD5B);
-    syndrome_o[1] = ^(data_i & 22'h02366D);
-    syndrome_o[2] = ^(data_i & 22'h04C78E);
-    syndrome_o[3] = ^(data_i & 22'h0807F0);
-    syndrome_o[4] = ^(data_i & 22'h10F800);
-    syndrome_o[5] = ^(data_i & 22'h3FFFFF);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 6'h23) ^ data_i[0];
-    data_o[1] = (syndrome_o == 6'h25) ^ data_i[1];
-    data_o[2] = (syndrome_o == 6'h26) ^ data_i[2];
-    data_o[3] = (syndrome_o == 6'h27) ^ data_i[3];
-    data_o[4] = (syndrome_o == 6'h29) ^ data_i[4];
-    data_o[5] = (syndrome_o == 6'h2a) ^ data_i[5];
-    data_o[6] = (syndrome_o == 6'h2b) ^ data_i[6];
-    data_o[7] = (syndrome_o == 6'h2c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 6'h2d) ^ data_i[8];
-    data_o[9] = (syndrome_o == 6'h2e) ^ data_i[9];
-    data_o[10] = (syndrome_o == 6'h2f) ^ data_i[10];
-    data_o[11] = (syndrome_o == 6'h31) ^ data_i[11];
-    data_o[12] = (syndrome_o == 6'h32) ^ data_i[12];
-    data_o[13] = (syndrome_o == 6'h33) ^ data_i[13];
-    data_o[14] = (syndrome_o == 6'h34) ^ data_i[14];
-    data_o[15] = (syndrome_o == 6'h35) ^ data_i[15];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = syndrome_o[5];
-    err_o[1] = |syndrome_o[4:0] & ~syndrome_o[5];
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [38:0]
-      prim_secded_hamming_39_32_enc (logic [31:0] data_i);
-    logic [38:0] data_o;
-    data_o = 39'(data_i);
-    data_o[32] = 1'b0 ^ ^(data_o & 39'h0056AAAD5B);
-    data_o[33] = 1'b0 ^ ^(data_o & 39'h009B33366D);
-    data_o[34] = 1'b0 ^ ^(data_o & 39'h00E3C3C78E);
-    data_o[35] = 1'b0 ^ ^(data_o & 39'h0003FC07F0);
-    data_o[36] = 1'b0 ^ ^(data_o & 39'h0003FFF800);
-    data_o[37] = 1'b0 ^ ^(data_o & 39'h00FC000000);
-    data_o[38] = 1'b0 ^ ^(data_o & 39'h3FFFFFFFFF);
-    return data_o;
-  endfunction
-
-  function automatic secded_hamming_39_32_t
-      prim_secded_hamming_39_32_dec (logic [38:0] data_i);
-    logic [31:0] data_o;
-    logic [6:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_hamming_39_32_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 39'h0156AAAD5B);
-    syndrome_o[1] = ^(data_i & 39'h029B33366D);
-    syndrome_o[2] = ^(data_i & 39'h04E3C3C78E);
-    syndrome_o[3] = ^(data_i & 39'h0803FC07F0);
-    syndrome_o[4] = ^(data_i & 39'h1003FFF800);
-    syndrome_o[5] = ^(data_i & 39'h20FC000000);
-    syndrome_o[6] = ^(data_i & 39'h7FFFFFFFFF);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 7'h43) ^ data_i[0];
-    data_o[1] = (syndrome_o == 7'h45) ^ data_i[1];
-    data_o[2] = (syndrome_o == 7'h46) ^ data_i[2];
-    data_o[3] = (syndrome_o == 7'h47) ^ data_i[3];
-    data_o[4] = (syndrome_o == 7'h49) ^ data_i[4];
-    data_o[5] = (syndrome_o == 7'h4a) ^ data_i[5];
-    data_o[6] = (syndrome_o == 7'h4b) ^ data_i[6];
-    data_o[7] = (syndrome_o == 7'h4c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 7'h4d) ^ data_i[8];
-    data_o[9] = (syndrome_o == 7'h4e) ^ data_i[9];
-    data_o[10] = (syndrome_o == 7'h4f) ^ data_i[10];
-    data_o[11] = (syndrome_o == 7'h51) ^ data_i[11];
-    data_o[12] = (syndrome_o == 7'h52) ^ data_i[12];
-    data_o[13] = (syndrome_o == 7'h53) ^ data_i[13];
-    data_o[14] = (syndrome_o == 7'h54) ^ data_i[14];
-    data_o[15] = (syndrome_o == 7'h55) ^ data_i[15];
-    data_o[16] = (syndrome_o == 7'h56) ^ data_i[16];
-    data_o[17] = (syndrome_o == 7'h57) ^ data_i[17];
-    data_o[18] = (syndrome_o == 7'h58) ^ data_i[18];
-    data_o[19] = (syndrome_o == 7'h59) ^ data_i[19];
-    data_o[20] = (syndrome_o == 7'h5a) ^ data_i[20];
-    data_o[21] = (syndrome_o == 7'h5b) ^ data_i[21];
-    data_o[22] = (syndrome_o == 7'h5c) ^ data_i[22];
-    data_o[23] = (syndrome_o == 7'h5d) ^ data_i[23];
-    data_o[24] = (syndrome_o == 7'h5e) ^ data_i[24];
-    data_o[25] = (syndrome_o == 7'h5f) ^ data_i[25];
-    data_o[26] = (syndrome_o == 7'h61) ^ data_i[26];
-    data_o[27] = (syndrome_o == 7'h62) ^ data_i[27];
-    data_o[28] = (syndrome_o == 7'h63) ^ data_i[28];
-    data_o[29] = (syndrome_o == 7'h64) ^ data_i[29];
-    data_o[30] = (syndrome_o == 7'h65) ^ data_i[30];
-    data_o[31] = (syndrome_o == 7'h66) ^ data_i[31];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = syndrome_o[6];
-    err_o[1] = |syndrome_o[5:0] & ~syndrome_o[6];
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [71:0]
-      prim_secded_hamming_72_64_enc (logic [63:0] data_i);
-    logic [71:0] data_o;
-    data_o = 72'(data_i);
-    data_o[64] = 1'b0 ^ ^(data_o & 72'h00AB55555556AAAD5B);
-    data_o[65] = 1'b0 ^ ^(data_o & 72'h00CD9999999B33366D);
-    data_o[66] = 1'b0 ^ ^(data_o & 72'h00F1E1E1E1E3C3C78E);
-    data_o[67] = 1'b0 ^ ^(data_o & 72'h0001FE01FE03FC07F0);
-    data_o[68] = 1'b0 ^ ^(data_o & 72'h0001FFFE0003FFF800);
-    data_o[69] = 1'b0 ^ ^(data_o & 72'h0001FFFFFFFC000000);
-    data_o[70] = 1'b0 ^ ^(data_o & 72'h00FE00000000000000);
-    data_o[71] = 1'b0 ^ ^(data_o & 72'h7FFFFFFFFFFFFFFFFF);
-    return data_o;
-  endfunction
-
-  function automatic secded_hamming_72_64_t
-      prim_secded_hamming_72_64_dec (logic [71:0] data_i);
-    logic [63:0] data_o;
-    logic [7:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_hamming_72_64_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 72'h01AB55555556AAAD5B);
-    syndrome_o[1] = ^(data_i & 72'h02CD9999999B33366D);
-    syndrome_o[2] = ^(data_i & 72'h04F1E1E1E1E3C3C78E);
-    syndrome_o[3] = ^(data_i & 72'h0801FE01FE03FC07F0);
-    syndrome_o[4] = ^(data_i & 72'h1001FFFE0003FFF800);
-    syndrome_o[5] = ^(data_i & 72'h2001FFFFFFFC000000);
-    syndrome_o[6] = ^(data_i & 72'h40FE00000000000000);
-    syndrome_o[7] = ^(data_i & 72'hFFFFFFFFFFFFFFFFFF);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 8'h83) ^ data_i[0];
-    data_o[1] = (syndrome_o == 8'h85) ^ data_i[1];
-    data_o[2] = (syndrome_o == 8'h86) ^ data_i[2];
-    data_o[3] = (syndrome_o == 8'h87) ^ data_i[3];
-    data_o[4] = (syndrome_o == 8'h89) ^ data_i[4];
-    data_o[5] = (syndrome_o == 8'h8a) ^ data_i[5];
-    data_o[6] = (syndrome_o == 8'h8b) ^ data_i[6];
-    data_o[7] = (syndrome_o == 8'h8c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 8'h8d) ^ data_i[8];
-    data_o[9] = (syndrome_o == 8'h8e) ^ data_i[9];
-    data_o[10] = (syndrome_o == 8'h8f) ^ data_i[10];
-    data_o[11] = (syndrome_o == 8'h91) ^ data_i[11];
-    data_o[12] = (syndrome_o == 8'h92) ^ data_i[12];
-    data_o[13] = (syndrome_o == 8'h93) ^ data_i[13];
-    data_o[14] = (syndrome_o == 8'h94) ^ data_i[14];
-    data_o[15] = (syndrome_o == 8'h95) ^ data_i[15];
-    data_o[16] = (syndrome_o == 8'h96) ^ data_i[16];
-    data_o[17] = (syndrome_o == 8'h97) ^ data_i[17];
-    data_o[18] = (syndrome_o == 8'h98) ^ data_i[18];
-    data_o[19] = (syndrome_o == 8'h99) ^ data_i[19];
-    data_o[20] = (syndrome_o == 8'h9a) ^ data_i[20];
-    data_o[21] = (syndrome_o == 8'h9b) ^ data_i[21];
-    data_o[22] = (syndrome_o == 8'h9c) ^ data_i[22];
-    data_o[23] = (syndrome_o == 8'h9d) ^ data_i[23];
-    data_o[24] = (syndrome_o == 8'h9e) ^ data_i[24];
-    data_o[25] = (syndrome_o == 8'h9f) ^ data_i[25];
-    data_o[26] = (syndrome_o == 8'ha1) ^ data_i[26];
-    data_o[27] = (syndrome_o == 8'ha2) ^ data_i[27];
-    data_o[28] = (syndrome_o == 8'ha3) ^ data_i[28];
-    data_o[29] = (syndrome_o == 8'ha4) ^ data_i[29];
-    data_o[30] = (syndrome_o == 8'ha5) ^ data_i[30];
-    data_o[31] = (syndrome_o == 8'ha6) ^ data_i[31];
-    data_o[32] = (syndrome_o == 8'ha7) ^ data_i[32];
-    data_o[33] = (syndrome_o == 8'ha8) ^ data_i[33];
-    data_o[34] = (syndrome_o == 8'ha9) ^ data_i[34];
-    data_o[35] = (syndrome_o == 8'haa) ^ data_i[35];
-    data_o[36] = (syndrome_o == 8'hab) ^ data_i[36];
-    data_o[37] = (syndrome_o == 8'hac) ^ data_i[37];
-    data_o[38] = (syndrome_o == 8'had) ^ data_i[38];
-    data_o[39] = (syndrome_o == 8'hae) ^ data_i[39];
-    data_o[40] = (syndrome_o == 8'haf) ^ data_i[40];
-    data_o[41] = (syndrome_o == 8'hb0) ^ data_i[41];
-    data_o[42] = (syndrome_o == 8'hb1) ^ data_i[42];
-    data_o[43] = (syndrome_o == 8'hb2) ^ data_i[43];
-    data_o[44] = (syndrome_o == 8'hb3) ^ data_i[44];
-    data_o[45] = (syndrome_o == 8'hb4) ^ data_i[45];
-    data_o[46] = (syndrome_o == 8'hb5) ^ data_i[46];
-    data_o[47] = (syndrome_o == 8'hb6) ^ data_i[47];
-    data_o[48] = (syndrome_o == 8'hb7) ^ data_i[48];
-    data_o[49] = (syndrome_o == 8'hb8) ^ data_i[49];
-    data_o[50] = (syndrome_o == 8'hb9) ^ data_i[50];
-    data_o[51] = (syndrome_o == 8'hba) ^ data_i[51];
-    data_o[52] = (syndrome_o == 8'hbb) ^ data_i[52];
-    data_o[53] = (syndrome_o == 8'hbc) ^ data_i[53];
-    data_o[54] = (syndrome_o == 8'hbd) ^ data_i[54];
-    data_o[55] = (syndrome_o == 8'hbe) ^ data_i[55];
-    data_o[56] = (syndrome_o == 8'hbf) ^ data_i[56];
-    data_o[57] = (syndrome_o == 8'hc1) ^ data_i[57];
-    data_o[58] = (syndrome_o == 8'hc2) ^ data_i[58];
-    data_o[59] = (syndrome_o == 8'hc3) ^ data_i[59];
-    data_o[60] = (syndrome_o == 8'hc4) ^ data_i[60];
-    data_o[61] = (syndrome_o == 8'hc5) ^ data_i[61];
-    data_o[62] = (syndrome_o == 8'hc6) ^ data_i[62];
-    data_o[63] = (syndrome_o == 8'hc7) ^ data_i[63];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = syndrome_o[7];
-    err_o[1] = |syndrome_o[6:0] & ~syndrome_o[7];
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [75:0]
-      prim_secded_hamming_76_68_enc (logic [67:0] data_i);
-    logic [75:0] data_o;
-    data_o = 76'(data_i);
-    data_o[68] = 1'b0 ^ ^(data_o & 76'h00AAB55555556AAAD5B);
-    data_o[69] = 1'b0 ^ ^(data_o & 76'h00CCD9999999B33366D);
-    data_o[70] = 1'b0 ^ ^(data_o & 76'h000F1E1E1E1E3C3C78E);
-    data_o[71] = 1'b0 ^ ^(data_o & 76'h00F01FE01FE03FC07F0);
-    data_o[72] = 1'b0 ^ ^(data_o & 76'h00001FFFE0003FFF800);
-    data_o[73] = 1'b0 ^ ^(data_o & 76'h00001FFFFFFFC000000);
-    data_o[74] = 1'b0 ^ ^(data_o & 76'h00FFE00000000000000);
-    data_o[75] = 1'b0 ^ ^(data_o & 76'h7FFFFFFFFFFFFFFFFFF);
-    return data_o;
-  endfunction
-
-  function automatic secded_hamming_76_68_t
-      prim_secded_hamming_76_68_dec (logic [75:0] data_i);
-    logic [67:0] data_o;
-    logic [7:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_hamming_76_68_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^(data_i & 76'h01AAB55555556AAAD5B);
-    syndrome_o[1] = ^(data_i & 76'h02CCD9999999B33366D);
-    syndrome_o[2] = ^(data_i & 76'h040F1E1E1E1E3C3C78E);
-    syndrome_o[3] = ^(data_i & 76'h08F01FE01FE03FC07F0);
-    syndrome_o[4] = ^(data_i & 76'h10001FFFE0003FFF800);
-    syndrome_o[5] = ^(data_i & 76'h20001FFFFFFFC000000);
-    syndrome_o[6] = ^(data_i & 76'h40FFE00000000000000);
-    syndrome_o[7] = ^(data_i & 76'hFFFFFFFFFFFFFFFFFFF);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 8'h83) ^ data_i[0];
-    data_o[1] = (syndrome_o == 8'h85) ^ data_i[1];
-    data_o[2] = (syndrome_o == 8'h86) ^ data_i[2];
-    data_o[3] = (syndrome_o == 8'h87) ^ data_i[3];
-    data_o[4] = (syndrome_o == 8'h89) ^ data_i[4];
-    data_o[5] = (syndrome_o == 8'h8a) ^ data_i[5];
-    data_o[6] = (syndrome_o == 8'h8b) ^ data_i[6];
-    data_o[7] = (syndrome_o == 8'h8c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 8'h8d) ^ data_i[8];
-    data_o[9] = (syndrome_o == 8'h8e) ^ data_i[9];
-    data_o[10] = (syndrome_o == 8'h8f) ^ data_i[10];
-    data_o[11] = (syndrome_o == 8'h91) ^ data_i[11];
-    data_o[12] = (syndrome_o == 8'h92) ^ data_i[12];
-    data_o[13] = (syndrome_o == 8'h93) ^ data_i[13];
-    data_o[14] = (syndrome_o == 8'h94) ^ data_i[14];
-    data_o[15] = (syndrome_o == 8'h95) ^ data_i[15];
-    data_o[16] = (syndrome_o == 8'h96) ^ data_i[16];
-    data_o[17] = (syndrome_o == 8'h97) ^ data_i[17];
-    data_o[18] = (syndrome_o == 8'h98) ^ data_i[18];
-    data_o[19] = (syndrome_o == 8'h99) ^ data_i[19];
-    data_o[20] = (syndrome_o == 8'h9a) ^ data_i[20];
-    data_o[21] = (syndrome_o == 8'h9b) ^ data_i[21];
-    data_o[22] = (syndrome_o == 8'h9c) ^ data_i[22];
-    data_o[23] = (syndrome_o == 8'h9d) ^ data_i[23];
-    data_o[24] = (syndrome_o == 8'h9e) ^ data_i[24];
-    data_o[25] = (syndrome_o == 8'h9f) ^ data_i[25];
-    data_o[26] = (syndrome_o == 8'ha1) ^ data_i[26];
-    data_o[27] = (syndrome_o == 8'ha2) ^ data_i[27];
-    data_o[28] = (syndrome_o == 8'ha3) ^ data_i[28];
-    data_o[29] = (syndrome_o == 8'ha4) ^ data_i[29];
-    data_o[30] = (syndrome_o == 8'ha5) ^ data_i[30];
-    data_o[31] = (syndrome_o == 8'ha6) ^ data_i[31];
-    data_o[32] = (syndrome_o == 8'ha7) ^ data_i[32];
-    data_o[33] = (syndrome_o == 8'ha8) ^ data_i[33];
-    data_o[34] = (syndrome_o == 8'ha9) ^ data_i[34];
-    data_o[35] = (syndrome_o == 8'haa) ^ data_i[35];
-    data_o[36] = (syndrome_o == 8'hab) ^ data_i[36];
-    data_o[37] = (syndrome_o == 8'hac) ^ data_i[37];
-    data_o[38] = (syndrome_o == 8'had) ^ data_i[38];
-    data_o[39] = (syndrome_o == 8'hae) ^ data_i[39];
-    data_o[40] = (syndrome_o == 8'haf) ^ data_i[40];
-    data_o[41] = (syndrome_o == 8'hb0) ^ data_i[41];
-    data_o[42] = (syndrome_o == 8'hb1) ^ data_i[42];
-    data_o[43] = (syndrome_o == 8'hb2) ^ data_i[43];
-    data_o[44] = (syndrome_o == 8'hb3) ^ data_i[44];
-    data_o[45] = (syndrome_o == 8'hb4) ^ data_i[45];
-    data_o[46] = (syndrome_o == 8'hb5) ^ data_i[46];
-    data_o[47] = (syndrome_o == 8'hb6) ^ data_i[47];
-    data_o[48] = (syndrome_o == 8'hb7) ^ data_i[48];
-    data_o[49] = (syndrome_o == 8'hb8) ^ data_i[49];
-    data_o[50] = (syndrome_o == 8'hb9) ^ data_i[50];
-    data_o[51] = (syndrome_o == 8'hba) ^ data_i[51];
-    data_o[52] = (syndrome_o == 8'hbb) ^ data_i[52];
-    data_o[53] = (syndrome_o == 8'hbc) ^ data_i[53];
-    data_o[54] = (syndrome_o == 8'hbd) ^ data_i[54];
-    data_o[55] = (syndrome_o == 8'hbe) ^ data_i[55];
-    data_o[56] = (syndrome_o == 8'hbf) ^ data_i[56];
-    data_o[57] = (syndrome_o == 8'hc1) ^ data_i[57];
-    data_o[58] = (syndrome_o == 8'hc2) ^ data_i[58];
-    data_o[59] = (syndrome_o == 8'hc3) ^ data_i[59];
-    data_o[60] = (syndrome_o == 8'hc4) ^ data_i[60];
-    data_o[61] = (syndrome_o == 8'hc5) ^ data_i[61];
-    data_o[62] = (syndrome_o == 8'hc6) ^ data_i[62];
-    data_o[63] = (syndrome_o == 8'hc7) ^ data_i[63];
-    data_o[64] = (syndrome_o == 8'hc8) ^ data_i[64];
-    data_o[65] = (syndrome_o == 8'hc9) ^ data_i[65];
-    data_o[66] = (syndrome_o == 8'hca) ^ data_i[66];
-    data_o[67] = (syndrome_o == 8'hcb) ^ data_i[67];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = syndrome_o[7];
-    err_o[1] = |syndrome_o[6:0] & ~syndrome_o[7];
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [21:0]
-      prim_secded_inv_22_16_enc (logic [15:0] data_i);
-    logic [21:0] data_o;
-    data_o = 22'(data_i);
-    data_o[16] = 1'b0 ^ ^(data_o & 22'h00496E);
-    data_o[17] = 1'b1 ^ ^(data_o & 22'h00F20B);
-    data_o[18] = 1'b0 ^ ^(data_o & 22'h008ED8);
-    data_o[19] = 1'b1 ^ ^(data_o & 22'h007714);
-    data_o[20] = 1'b0 ^ ^(data_o & 22'h00ACA5);
-    data_o[21] = 1'b1 ^ ^(data_o & 22'h0011F3);
-    return data_o;
-  endfunction
-
-  function automatic secded_inv_22_16_t
-      prim_secded_inv_22_16_dec (logic [21:0] data_i);
-    logic [15:0] data_o;
-    logic [5:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_inv_22_16_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 22'h2A0000) & 22'h01496E);
-    syndrome_o[1] = ^((data_i ^ 22'h2A0000) & 22'h02F20B);
-    syndrome_o[2] = ^((data_i ^ 22'h2A0000) & 22'h048ED8);
-    syndrome_o[3] = ^((data_i ^ 22'h2A0000) & 22'h087714);
-    syndrome_o[4] = ^((data_i ^ 22'h2A0000) & 22'h10ACA5);
-    syndrome_o[5] = ^((data_i ^ 22'h2A0000) & 22'h2011F3);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 6'h32) ^ data_i[0];
-    data_o[1] = (syndrome_o == 6'h23) ^ data_i[1];
-    data_o[2] = (syndrome_o == 6'h19) ^ data_i[2];
-    data_o[3] = (syndrome_o == 6'h7) ^ data_i[3];
-    data_o[4] = (syndrome_o == 6'h2c) ^ data_i[4];
-    data_o[5] = (syndrome_o == 6'h31) ^ data_i[5];
-    data_o[6] = (syndrome_o == 6'h25) ^ data_i[6];
-    data_o[7] = (syndrome_o == 6'h34) ^ data_i[7];
-    data_o[8] = (syndrome_o == 6'h29) ^ data_i[8];
-    data_o[9] = (syndrome_o == 6'he) ^ data_i[9];
-    data_o[10] = (syndrome_o == 6'h1c) ^ data_i[10];
-    data_o[11] = (syndrome_o == 6'h15) ^ data_i[11];
-    data_o[12] = (syndrome_o == 6'h2a) ^ data_i[12];
-    data_o[13] = (syndrome_o == 6'h1a) ^ data_i[13];
-    data_o[14] = (syndrome_o == 6'hb) ^ data_i[14];
-    data_o[15] = (syndrome_o == 6'h16) ^ data_i[15];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [27:0]
-      prim_secded_inv_28_22_enc (logic [21:0] data_i);
-    logic [27:0] data_o;
-    data_o = 28'(data_i);
-    data_o[22] = 1'b0 ^ ^(data_o & 28'h03003FF);
-    data_o[23] = 1'b1 ^ ^(data_o & 28'h010FC0F);
-    data_o[24] = 1'b0 ^ ^(data_o & 28'h0271C71);
-    data_o[25] = 1'b1 ^ ^(data_o & 28'h03B6592);
-    data_o[26] = 1'b0 ^ ^(data_o & 28'h03DAAA4);
-    data_o[27] = 1'b1 ^ ^(data_o & 28'h03ED348);
-    return data_o;
-  endfunction
-
-  function automatic secded_inv_28_22_t
-      prim_secded_inv_28_22_dec (logic [27:0] data_i);
-    logic [21:0] data_o;
-    logic [5:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_inv_28_22_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 28'hA800000) & 28'h07003FF);
-    syndrome_o[1] = ^((data_i ^ 28'hA800000) & 28'h090FC0F);
-    syndrome_o[2] = ^((data_i ^ 28'hA800000) & 28'h1271C71);
-    syndrome_o[3] = ^((data_i ^ 28'hA800000) & 28'h23B6592);
-    syndrome_o[4] = ^((data_i ^ 28'hA800000) & 28'h43DAAA4);
-    syndrome_o[5] = ^((data_i ^ 28'hA800000) & 28'h83ED348);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 6'h7) ^ data_i[0];
-    data_o[1] = (syndrome_o == 6'hb) ^ data_i[1];
-    data_o[2] = (syndrome_o == 6'h13) ^ data_i[2];
-    data_o[3] = (syndrome_o == 6'h23) ^ data_i[3];
-    data_o[4] = (syndrome_o == 6'hd) ^ data_i[4];
-    data_o[5] = (syndrome_o == 6'h15) ^ data_i[5];
-    data_o[6] = (syndrome_o == 6'h25) ^ data_i[6];
-    data_o[7] = (syndrome_o == 6'h19) ^ data_i[7];
-    data_o[8] = (syndrome_o == 6'h29) ^ data_i[8];
-    data_o[9] = (syndrome_o == 6'h31) ^ data_i[9];
-    data_o[10] = (syndrome_o == 6'he) ^ data_i[10];
-    data_o[11] = (syndrome_o == 6'h16) ^ data_i[11];
-    data_o[12] = (syndrome_o == 6'h26) ^ data_i[12];
-    data_o[13] = (syndrome_o == 6'h1a) ^ data_i[13];
-    data_o[14] = (syndrome_o == 6'h2a) ^ data_i[14];
-    data_o[15] = (syndrome_o == 6'h32) ^ data_i[15];
-    data_o[16] = (syndrome_o == 6'h1c) ^ data_i[16];
-    data_o[17] = (syndrome_o == 6'h2c) ^ data_i[17];
-    data_o[18] = (syndrome_o == 6'h34) ^ data_i[18];
-    data_o[19] = (syndrome_o == 6'h38) ^ data_i[19];
-    data_o[20] = (syndrome_o == 6'h3b) ^ data_i[20];
-    data_o[21] = (syndrome_o == 6'h3d) ^ data_i[21];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [38:0]
-      prim_secded_inv_39_32_enc (logic [31:0] data_i);
-    logic [38:0] data_o;
-    data_o = 39'(data_i);
-    data_o[32] = 1'b0 ^ ^(data_o & 39'h002606BD25);
-    data_o[33] = 1'b1 ^ ^(data_o & 39'h00DEBA8050);
-    data_o[34] = 1'b0 ^ ^(data_o & 39'h00413D89AA);
-    data_o[35] = 1'b1 ^ ^(data_o & 39'h0031234ED1);
-    data_o[36] = 1'b0 ^ ^(data_o & 39'h00C2C1323B);
-    data_o[37] = 1'b1 ^ ^(data_o & 39'h002DCC624C);
-    data_o[38] = 1'b0 ^ ^(data_o & 39'h0098505586);
-    return data_o;
-  endfunction
-
-  function automatic secded_inv_39_32_t
-      prim_secded_inv_39_32_dec (logic [38:0] data_i);
-    logic [31:0] data_o;
-    logic [6:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_inv_39_32_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 39'h2A00000000) & 39'h012606BD25);
-    syndrome_o[1] = ^((data_i ^ 39'h2A00000000) & 39'h02DEBA8050);
-    syndrome_o[2] = ^((data_i ^ 39'h2A00000000) & 39'h04413D89AA);
-    syndrome_o[3] = ^((data_i ^ 39'h2A00000000) & 39'h0831234ED1);
-    syndrome_o[4] = ^((data_i ^ 39'h2A00000000) & 39'h10C2C1323B);
-    syndrome_o[5] = ^((data_i ^ 39'h2A00000000) & 39'h202DCC624C);
-    syndrome_o[6] = ^((data_i ^ 39'h2A00000000) & 39'h4098505586);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 7'h19) ^ data_i[0];
-    data_o[1] = (syndrome_o == 7'h54) ^ data_i[1];
-    data_o[2] = (syndrome_o == 7'h61) ^ data_i[2];
-    data_o[3] = (syndrome_o == 7'h34) ^ data_i[3];
-    data_o[4] = (syndrome_o == 7'h1a) ^ data_i[4];
-    data_o[5] = (syndrome_o == 7'h15) ^ data_i[5];
-    data_o[6] = (syndrome_o == 7'h2a) ^ data_i[6];
-    data_o[7] = (syndrome_o == 7'h4c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 7'h45) ^ data_i[8];
-    data_o[9] = (syndrome_o == 7'h38) ^ data_i[9];
-    data_o[10] = (syndrome_o == 7'h49) ^ data_i[10];
-    data_o[11] = (syndrome_o == 7'hd) ^ data_i[11];
-    data_o[12] = (syndrome_o == 7'h51) ^ data_i[12];
-    data_o[13] = (syndrome_o == 7'h31) ^ data_i[13];
-    data_o[14] = (syndrome_o == 7'h68) ^ data_i[14];
-    data_o[15] = (syndrome_o == 7'h7) ^ data_i[15];
-    data_o[16] = (syndrome_o == 7'h1c) ^ data_i[16];
-    data_o[17] = (syndrome_o == 7'hb) ^ data_i[17];
-    data_o[18] = (syndrome_o == 7'h25) ^ data_i[18];
-    data_o[19] = (syndrome_o == 7'h26) ^ data_i[19];
-    data_o[20] = (syndrome_o == 7'h46) ^ data_i[20];
-    data_o[21] = (syndrome_o == 7'he) ^ data_i[21];
-    data_o[22] = (syndrome_o == 7'h70) ^ data_i[22];
-    data_o[23] = (syndrome_o == 7'h32) ^ data_i[23];
-    data_o[24] = (syndrome_o == 7'h2c) ^ data_i[24];
-    data_o[25] = (syndrome_o == 7'h13) ^ data_i[25];
-    data_o[26] = (syndrome_o == 7'h23) ^ data_i[26];
-    data_o[27] = (syndrome_o == 7'h62) ^ data_i[27];
-    data_o[28] = (syndrome_o == 7'h4a) ^ data_i[28];
-    data_o[29] = (syndrome_o == 7'h29) ^ data_i[29];
-    data_o[30] = (syndrome_o == 7'h16) ^ data_i[30];
-    data_o[31] = (syndrome_o == 7'h52) ^ data_i[31];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [63:0]
-      prim_secded_inv_64_57_enc (logic [56:0] data_i);
-    logic [63:0] data_o;
-    data_o = 64'(data_i);
-    data_o[57] = 1'b0 ^ ^(data_o & 64'h0103FFF800007FFF);
-    data_o[58] = 1'b1 ^ ^(data_o & 64'h017C1FF801FF801F);
-    data_o[59] = 1'b0 ^ ^(data_o & 64'h01BDE1F87E0781E1);
-    data_o[60] = 1'b1 ^ ^(data_o & 64'h01DEEE3B8E388E22);
-    data_o[61] = 1'b0 ^ ^(data_o & 64'h01EF76CDB2C93244);
-    data_o[62] = 1'b1 ^ ^(data_o & 64'h01F7BB56D5525488);
-    data_o[63] = 1'b0 ^ ^(data_o & 64'h01FBDDA769A46910);
-    return data_o;
-  endfunction
-
-  function automatic secded_inv_64_57_t
-      prim_secded_inv_64_57_dec (logic [63:0] data_i);
-    logic [56:0] data_o;
-    logic [6:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_inv_64_57_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 64'h5400000000000000) & 64'h0303FFF800007FFF);
-    syndrome_o[1] = ^((data_i ^ 64'h5400000000000000) & 64'h057C1FF801FF801F);
-    syndrome_o[2] = ^((data_i ^ 64'h5400000000000000) & 64'h09BDE1F87E0781E1);
-    syndrome_o[3] = ^((data_i ^ 64'h5400000000000000) & 64'h11DEEE3B8E388E22);
-    syndrome_o[4] = ^((data_i ^ 64'h5400000000000000) & 64'h21EF76CDB2C93244);
-    syndrome_o[5] = ^((data_i ^ 64'h5400000000000000) & 64'h41F7BB56D5525488);
-    syndrome_o[6] = ^((data_i ^ 64'h5400000000000000) & 64'h81FBDDA769A46910);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 7'h7) ^ data_i[0];
-    data_o[1] = (syndrome_o == 7'hb) ^ data_i[1];
-    data_o[2] = (syndrome_o == 7'h13) ^ data_i[2];
-    data_o[3] = (syndrome_o == 7'h23) ^ data_i[3];
-    data_o[4] = (syndrome_o == 7'h43) ^ data_i[4];
-    data_o[5] = (syndrome_o == 7'hd) ^ data_i[5];
-    data_o[6] = (syndrome_o == 7'h15) ^ data_i[6];
-    data_o[7] = (syndrome_o == 7'h25) ^ data_i[7];
-    data_o[8] = (syndrome_o == 7'h45) ^ data_i[8];
-    data_o[9] = (syndrome_o == 7'h19) ^ data_i[9];
-    data_o[10] = (syndrome_o == 7'h29) ^ data_i[10];
-    data_o[11] = (syndrome_o == 7'h49) ^ data_i[11];
-    data_o[12] = (syndrome_o == 7'h31) ^ data_i[12];
-    data_o[13] = (syndrome_o == 7'h51) ^ data_i[13];
-    data_o[14] = (syndrome_o == 7'h61) ^ data_i[14];
-    data_o[15] = (syndrome_o == 7'he) ^ data_i[15];
-    data_o[16] = (syndrome_o == 7'h16) ^ data_i[16];
-    data_o[17] = (syndrome_o == 7'h26) ^ data_i[17];
-    data_o[18] = (syndrome_o == 7'h46) ^ data_i[18];
-    data_o[19] = (syndrome_o == 7'h1a) ^ data_i[19];
-    data_o[20] = (syndrome_o == 7'h2a) ^ data_i[20];
-    data_o[21] = (syndrome_o == 7'h4a) ^ data_i[21];
-    data_o[22] = (syndrome_o == 7'h32) ^ data_i[22];
-    data_o[23] = (syndrome_o == 7'h52) ^ data_i[23];
-    data_o[24] = (syndrome_o == 7'h62) ^ data_i[24];
-    data_o[25] = (syndrome_o == 7'h1c) ^ data_i[25];
-    data_o[26] = (syndrome_o == 7'h2c) ^ data_i[26];
-    data_o[27] = (syndrome_o == 7'h4c) ^ data_i[27];
-    data_o[28] = (syndrome_o == 7'h34) ^ data_i[28];
-    data_o[29] = (syndrome_o == 7'h54) ^ data_i[29];
-    data_o[30] = (syndrome_o == 7'h64) ^ data_i[30];
-    data_o[31] = (syndrome_o == 7'h38) ^ data_i[31];
-    data_o[32] = (syndrome_o == 7'h58) ^ data_i[32];
-    data_o[33] = (syndrome_o == 7'h68) ^ data_i[33];
-    data_o[34] = (syndrome_o == 7'h70) ^ data_i[34];
-    data_o[35] = (syndrome_o == 7'h1f) ^ data_i[35];
-    data_o[36] = (syndrome_o == 7'h2f) ^ data_i[36];
-    data_o[37] = (syndrome_o == 7'h4f) ^ data_i[37];
-    data_o[38] = (syndrome_o == 7'h37) ^ data_i[38];
-    data_o[39] = (syndrome_o == 7'h57) ^ data_i[39];
-    data_o[40] = (syndrome_o == 7'h67) ^ data_i[40];
-    data_o[41] = (syndrome_o == 7'h3b) ^ data_i[41];
-    data_o[42] = (syndrome_o == 7'h5b) ^ data_i[42];
-    data_o[43] = (syndrome_o == 7'h6b) ^ data_i[43];
-    data_o[44] = (syndrome_o == 7'h73) ^ data_i[44];
-    data_o[45] = (syndrome_o == 7'h3d) ^ data_i[45];
-    data_o[46] = (syndrome_o == 7'h5d) ^ data_i[46];
-    data_o[47] = (syndrome_o == 7'h6d) ^ data_i[47];
-    data_o[48] = (syndrome_o == 7'h75) ^ data_i[48];
-    data_o[49] = (syndrome_o == 7'h79) ^ data_i[49];
-    data_o[50] = (syndrome_o == 7'h3e) ^ data_i[50];
-    data_o[51] = (syndrome_o == 7'h5e) ^ data_i[51];
-    data_o[52] = (syndrome_o == 7'h6e) ^ data_i[52];
-    data_o[53] = (syndrome_o == 7'h76) ^ data_i[53];
-    data_o[54] = (syndrome_o == 7'h7a) ^ data_i[54];
-    data_o[55] = (syndrome_o == 7'h7c) ^ data_i[55];
-    data_o[56] = (syndrome_o == 7'h7f) ^ data_i[56];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [71:0]
-      prim_secded_inv_72_64_enc (logic [63:0] data_i);
-    logic [71:0] data_o;
-    data_o = 72'(data_i);
-    data_o[64] = 1'b0 ^ ^(data_o & 72'h00B9000000001FFFFF);
-    data_o[65] = 1'b1 ^ ^(data_o & 72'h005E00000FFFE0003F);
-    data_o[66] = 1'b0 ^ ^(data_o & 72'h0067003FF003E007C1);
-    data_o[67] = 1'b1 ^ ^(data_o & 72'h00CD0FC0F03C207842);
-    data_o[68] = 1'b0 ^ ^(data_o & 72'h00B671C711C4438884);
-    data_o[69] = 1'b1 ^ ^(data_o & 72'h00B5B65926488C9108);
-    data_o[70] = 1'b0 ^ ^(data_o & 72'h00CBDAAA4A91152210);
-    data_o[71] = 1'b1 ^ ^(data_o & 72'h007AED348D221A4420);
-    return data_o;
-  endfunction
-
-  function automatic secded_inv_72_64_t
-      prim_secded_inv_72_64_dec (logic [71:0] data_i);
-    logic [63:0] data_o;
-    logic [7:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_inv_72_64_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 72'hAA0000000000000000) & 72'h01B9000000001FFFFF);
-    syndrome_o[1] = ^((data_i ^ 72'hAA0000000000000000) & 72'h025E00000FFFE0003F);
-    syndrome_o[2] = ^((data_i ^ 72'hAA0000000000000000) & 72'h0467003FF003E007C1);
-    syndrome_o[3] = ^((data_i ^ 72'hAA0000000000000000) & 72'h08CD0FC0F03C207842);
-    syndrome_o[4] = ^((data_i ^ 72'hAA0000000000000000) & 72'h10B671C711C4438884);
-    syndrome_o[5] = ^((data_i ^ 72'hAA0000000000000000) & 72'h20B5B65926488C9108);
-    syndrome_o[6] = ^((data_i ^ 72'hAA0000000000000000) & 72'h40CBDAAA4A91152210);
-    syndrome_o[7] = ^((data_i ^ 72'hAA0000000000000000) & 72'h807AED348D221A4420);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 8'h7) ^ data_i[0];
-    data_o[1] = (syndrome_o == 8'hb) ^ data_i[1];
-    data_o[2] = (syndrome_o == 8'h13) ^ data_i[2];
-    data_o[3] = (syndrome_o == 8'h23) ^ data_i[3];
-    data_o[4] = (syndrome_o == 8'h43) ^ data_i[4];
-    data_o[5] = (syndrome_o == 8'h83) ^ data_i[5];
-    data_o[6] = (syndrome_o == 8'hd) ^ data_i[6];
-    data_o[7] = (syndrome_o == 8'h15) ^ data_i[7];
-    data_o[8] = (syndrome_o == 8'h25) ^ data_i[8];
-    data_o[9] = (syndrome_o == 8'h45) ^ data_i[9];
-    data_o[10] = (syndrome_o == 8'h85) ^ data_i[10];
-    data_o[11] = (syndrome_o == 8'h19) ^ data_i[11];
-    data_o[12] = (syndrome_o == 8'h29) ^ data_i[12];
-    data_o[13] = (syndrome_o == 8'h49) ^ data_i[13];
-    data_o[14] = (syndrome_o == 8'h89) ^ data_i[14];
-    data_o[15] = (syndrome_o == 8'h31) ^ data_i[15];
-    data_o[16] = (syndrome_o == 8'h51) ^ data_i[16];
-    data_o[17] = (syndrome_o == 8'h91) ^ data_i[17];
-    data_o[18] = (syndrome_o == 8'h61) ^ data_i[18];
-    data_o[19] = (syndrome_o == 8'ha1) ^ data_i[19];
-    data_o[20] = (syndrome_o == 8'hc1) ^ data_i[20];
-    data_o[21] = (syndrome_o == 8'he) ^ data_i[21];
-    data_o[22] = (syndrome_o == 8'h16) ^ data_i[22];
-    data_o[23] = (syndrome_o == 8'h26) ^ data_i[23];
-    data_o[24] = (syndrome_o == 8'h46) ^ data_i[24];
-    data_o[25] = (syndrome_o == 8'h86) ^ data_i[25];
-    data_o[26] = (syndrome_o == 8'h1a) ^ data_i[26];
-    data_o[27] = (syndrome_o == 8'h2a) ^ data_i[27];
-    data_o[28] = (syndrome_o == 8'h4a) ^ data_i[28];
-    data_o[29] = (syndrome_o == 8'h8a) ^ data_i[29];
-    data_o[30] = (syndrome_o == 8'h32) ^ data_i[30];
-    data_o[31] = (syndrome_o == 8'h52) ^ data_i[31];
-    data_o[32] = (syndrome_o == 8'h92) ^ data_i[32];
-    data_o[33] = (syndrome_o == 8'h62) ^ data_i[33];
-    data_o[34] = (syndrome_o == 8'ha2) ^ data_i[34];
-    data_o[35] = (syndrome_o == 8'hc2) ^ data_i[35];
-    data_o[36] = (syndrome_o == 8'h1c) ^ data_i[36];
-    data_o[37] = (syndrome_o == 8'h2c) ^ data_i[37];
-    data_o[38] = (syndrome_o == 8'h4c) ^ data_i[38];
-    data_o[39] = (syndrome_o == 8'h8c) ^ data_i[39];
-    data_o[40] = (syndrome_o == 8'h34) ^ data_i[40];
-    data_o[41] = (syndrome_o == 8'h54) ^ data_i[41];
-    data_o[42] = (syndrome_o == 8'h94) ^ data_i[42];
-    data_o[43] = (syndrome_o == 8'h64) ^ data_i[43];
-    data_o[44] = (syndrome_o == 8'ha4) ^ data_i[44];
-    data_o[45] = (syndrome_o == 8'hc4) ^ data_i[45];
-    data_o[46] = (syndrome_o == 8'h38) ^ data_i[46];
-    data_o[47] = (syndrome_o == 8'h58) ^ data_i[47];
-    data_o[48] = (syndrome_o == 8'h98) ^ data_i[48];
-    data_o[49] = (syndrome_o == 8'h68) ^ data_i[49];
-    data_o[50] = (syndrome_o == 8'ha8) ^ data_i[50];
-    data_o[51] = (syndrome_o == 8'hc8) ^ data_i[51];
-    data_o[52] = (syndrome_o == 8'h70) ^ data_i[52];
-    data_o[53] = (syndrome_o == 8'hb0) ^ data_i[53];
-    data_o[54] = (syndrome_o == 8'hd0) ^ data_i[54];
-    data_o[55] = (syndrome_o == 8'he0) ^ data_i[55];
-    data_o[56] = (syndrome_o == 8'h6d) ^ data_i[56];
-    data_o[57] = (syndrome_o == 8'hd6) ^ data_i[57];
-    data_o[58] = (syndrome_o == 8'h3e) ^ data_i[58];
-    data_o[59] = (syndrome_o == 8'hcb) ^ data_i[59];
-    data_o[60] = (syndrome_o == 8'hb3) ^ data_i[60];
-    data_o[61] = (syndrome_o == 8'hb5) ^ data_i[61];
-    data_o[62] = (syndrome_o == 8'hce) ^ data_i[62];
-    data_o[63] = (syndrome_o == 8'h79) ^ data_i[63];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = ^syndrome_o;
-    err_o[1] = ~err_o[0] & (|syndrome_o);
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [21:0]
-      prim_secded_inv_hamming_22_16_enc (logic [15:0] data_i);
-    logic [21:0] data_o;
-    data_o = 22'(data_i);
-    data_o[16] = 1'b0 ^ ^(data_o & 22'h00AD5B);
-    data_o[17] = 1'b1 ^ ^(data_o & 22'h00366D);
-    data_o[18] = 1'b0 ^ ^(data_o & 22'h00C78E);
-    data_o[19] = 1'b1 ^ ^(data_o & 22'h0007F0);
-    data_o[20] = 1'b0 ^ ^(data_o & 22'h00F800);
-    data_o[21] = 1'b1 ^ ^(data_o & 22'h1FFFFF);
-    return data_o;
-  endfunction
-
-  function automatic secded_inv_hamming_22_16_t
-      prim_secded_inv_hamming_22_16_dec (logic [21:0] data_i);
-    logic [15:0] data_o;
-    logic [5:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_inv_hamming_22_16_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 22'h2A0000) & 22'h01AD5B);
-    syndrome_o[1] = ^((data_i ^ 22'h2A0000) & 22'h02366D);
-    syndrome_o[2] = ^((data_i ^ 22'h2A0000) & 22'h04C78E);
-    syndrome_o[3] = ^((data_i ^ 22'h2A0000) & 22'h0807F0);
-    syndrome_o[4] = ^((data_i ^ 22'h2A0000) & 22'h10F800);
-    syndrome_o[5] = ^((data_i ^ 22'h2A0000) & 22'h3FFFFF);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 6'h23) ^ data_i[0];
-    data_o[1] = (syndrome_o == 6'h25) ^ data_i[1];
-    data_o[2] = (syndrome_o == 6'h26) ^ data_i[2];
-    data_o[3] = (syndrome_o == 6'h27) ^ data_i[3];
-    data_o[4] = (syndrome_o == 6'h29) ^ data_i[4];
-    data_o[5] = (syndrome_o == 6'h2a) ^ data_i[5];
-    data_o[6] = (syndrome_o == 6'h2b) ^ data_i[6];
-    data_o[7] = (syndrome_o == 6'h2c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 6'h2d) ^ data_i[8];
-    data_o[9] = (syndrome_o == 6'h2e) ^ data_i[9];
-    data_o[10] = (syndrome_o == 6'h2f) ^ data_i[10];
-    data_o[11] = (syndrome_o == 6'h31) ^ data_i[11];
-    data_o[12] = (syndrome_o == 6'h32) ^ data_i[12];
-    data_o[13] = (syndrome_o == 6'h33) ^ data_i[13];
-    data_o[14] = (syndrome_o == 6'h34) ^ data_i[14];
-    data_o[15] = (syndrome_o == 6'h35) ^ data_i[15];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = syndrome_o[5];
-    err_o[1] = |syndrome_o[4:0] & ~syndrome_o[5];
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [38:0]
-      prim_secded_inv_hamming_39_32_enc (logic [31:0] data_i);
-    logic [38:0] data_o;
-    data_o = 39'(data_i);
-    data_o[32] = 1'b0 ^ ^(data_o & 39'h0056AAAD5B);
-    data_o[33] = 1'b1 ^ ^(data_o & 39'h009B33366D);
-    data_o[34] = 1'b0 ^ ^(data_o & 39'h00E3C3C78E);
-    data_o[35] = 1'b1 ^ ^(data_o & 39'h0003FC07F0);
-    data_o[36] = 1'b0 ^ ^(data_o & 39'h0003FFF800);
-    data_o[37] = 1'b1 ^ ^(data_o & 39'h00FC000000);
-    data_o[38] = 1'b0 ^ ^(data_o & 39'h3FFFFFFFFF);
-    return data_o;
-  endfunction
-
-  function automatic secded_inv_hamming_39_32_t
-      prim_secded_inv_hamming_39_32_dec (logic [38:0] data_i);
-    logic [31:0] data_o;
-    logic [6:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_inv_hamming_39_32_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 39'h2A00000000) & 39'h0156AAAD5B);
-    syndrome_o[1] = ^((data_i ^ 39'h2A00000000) & 39'h029B33366D);
-    syndrome_o[2] = ^((data_i ^ 39'h2A00000000) & 39'h04E3C3C78E);
-    syndrome_o[3] = ^((data_i ^ 39'h2A00000000) & 39'h0803FC07F0);
-    syndrome_o[4] = ^((data_i ^ 39'h2A00000000) & 39'h1003FFF800);
-    syndrome_o[5] = ^((data_i ^ 39'h2A00000000) & 39'h20FC000000);
-    syndrome_o[6] = ^((data_i ^ 39'h2A00000000) & 39'h7FFFFFFFFF);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 7'h43) ^ data_i[0];
-    data_o[1] = (syndrome_o == 7'h45) ^ data_i[1];
-    data_o[2] = (syndrome_o == 7'h46) ^ data_i[2];
-    data_o[3] = (syndrome_o == 7'h47) ^ data_i[3];
-    data_o[4] = (syndrome_o == 7'h49) ^ data_i[4];
-    data_o[5] = (syndrome_o == 7'h4a) ^ data_i[5];
-    data_o[6] = (syndrome_o == 7'h4b) ^ data_i[6];
-    data_o[7] = (syndrome_o == 7'h4c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 7'h4d) ^ data_i[8];
-    data_o[9] = (syndrome_o == 7'h4e) ^ data_i[9];
-    data_o[10] = (syndrome_o == 7'h4f) ^ data_i[10];
-    data_o[11] = (syndrome_o == 7'h51) ^ data_i[11];
-    data_o[12] = (syndrome_o == 7'h52) ^ data_i[12];
-    data_o[13] = (syndrome_o == 7'h53) ^ data_i[13];
-    data_o[14] = (syndrome_o == 7'h54) ^ data_i[14];
-    data_o[15] = (syndrome_o == 7'h55) ^ data_i[15];
-    data_o[16] = (syndrome_o == 7'h56) ^ data_i[16];
-    data_o[17] = (syndrome_o == 7'h57) ^ data_i[17];
-    data_o[18] = (syndrome_o == 7'h58) ^ data_i[18];
-    data_o[19] = (syndrome_o == 7'h59) ^ data_i[19];
-    data_o[20] = (syndrome_o == 7'h5a) ^ data_i[20];
-    data_o[21] = (syndrome_o == 7'h5b) ^ data_i[21];
-    data_o[22] = (syndrome_o == 7'h5c) ^ data_i[22];
-    data_o[23] = (syndrome_o == 7'h5d) ^ data_i[23];
-    data_o[24] = (syndrome_o == 7'h5e) ^ data_i[24];
-    data_o[25] = (syndrome_o == 7'h5f) ^ data_i[25];
-    data_o[26] = (syndrome_o == 7'h61) ^ data_i[26];
-    data_o[27] = (syndrome_o == 7'h62) ^ data_i[27];
-    data_o[28] = (syndrome_o == 7'h63) ^ data_i[28];
-    data_o[29] = (syndrome_o == 7'h64) ^ data_i[29];
-    data_o[30] = (syndrome_o == 7'h65) ^ data_i[30];
-    data_o[31] = (syndrome_o == 7'h66) ^ data_i[31];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = syndrome_o[6];
-    err_o[1] = |syndrome_o[5:0] & ~syndrome_o[6];
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [71:0]
-      prim_secded_inv_hamming_72_64_enc (logic [63:0] data_i);
-    logic [71:0] data_o;
-    data_o = 72'(data_i);
-    data_o[64] = 1'b0 ^ ^(data_o & 72'h00AB55555556AAAD5B);
-    data_o[65] = 1'b1 ^ ^(data_o & 72'h00CD9999999B33366D);
-    data_o[66] = 1'b0 ^ ^(data_o & 72'h00F1E1E1E1E3C3C78E);
-    data_o[67] = 1'b1 ^ ^(data_o & 72'h0001FE01FE03FC07F0);
-    data_o[68] = 1'b0 ^ ^(data_o & 72'h0001FFFE0003FFF800);
-    data_o[69] = 1'b1 ^ ^(data_o & 72'h0001FFFFFFFC000000);
-    data_o[70] = 1'b0 ^ ^(data_o & 72'h00FE00000000000000);
-    data_o[71] = 1'b1 ^ ^(data_o & 72'h7FFFFFFFFFFFFFFFFF);
-    return data_o;
-  endfunction
-
-  function automatic secded_inv_hamming_72_64_t
-      prim_secded_inv_hamming_72_64_dec (logic [71:0] data_i);
-    logic [63:0] data_o;
-    logic [7:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_inv_hamming_72_64_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 72'hAA0000000000000000) & 72'h01AB55555556AAAD5B);
-    syndrome_o[1] = ^((data_i ^ 72'hAA0000000000000000) & 72'h02CD9999999B33366D);
-    syndrome_o[2] = ^((data_i ^ 72'hAA0000000000000000) & 72'h04F1E1E1E1E3C3C78E);
-    syndrome_o[3] = ^((data_i ^ 72'hAA0000000000000000) & 72'h0801FE01FE03FC07F0);
-    syndrome_o[4] = ^((data_i ^ 72'hAA0000000000000000) & 72'h1001FFFE0003FFF800);
-    syndrome_o[5] = ^((data_i ^ 72'hAA0000000000000000) & 72'h2001FFFFFFFC000000);
-    syndrome_o[6] = ^((data_i ^ 72'hAA0000000000000000) & 72'h40FE00000000000000);
-    syndrome_o[7] = ^((data_i ^ 72'hAA0000000000000000) & 72'hFFFFFFFFFFFFFFFFFF);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 8'h83) ^ data_i[0];
-    data_o[1] = (syndrome_o == 8'h85) ^ data_i[1];
-    data_o[2] = (syndrome_o == 8'h86) ^ data_i[2];
-    data_o[3] = (syndrome_o == 8'h87) ^ data_i[3];
-    data_o[4] = (syndrome_o == 8'h89) ^ data_i[4];
-    data_o[5] = (syndrome_o == 8'h8a) ^ data_i[5];
-    data_o[6] = (syndrome_o == 8'h8b) ^ data_i[6];
-    data_o[7] = (syndrome_o == 8'h8c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 8'h8d) ^ data_i[8];
-    data_o[9] = (syndrome_o == 8'h8e) ^ data_i[9];
-    data_o[10] = (syndrome_o == 8'h8f) ^ data_i[10];
-    data_o[11] = (syndrome_o == 8'h91) ^ data_i[11];
-    data_o[12] = (syndrome_o == 8'h92) ^ data_i[12];
-    data_o[13] = (syndrome_o == 8'h93) ^ data_i[13];
-    data_o[14] = (syndrome_o == 8'h94) ^ data_i[14];
-    data_o[15] = (syndrome_o == 8'h95) ^ data_i[15];
-    data_o[16] = (syndrome_o == 8'h96) ^ data_i[16];
-    data_o[17] = (syndrome_o == 8'h97) ^ data_i[17];
-    data_o[18] = (syndrome_o == 8'h98) ^ data_i[18];
-    data_o[19] = (syndrome_o == 8'h99) ^ data_i[19];
-    data_o[20] = (syndrome_o == 8'h9a) ^ data_i[20];
-    data_o[21] = (syndrome_o == 8'h9b) ^ data_i[21];
-    data_o[22] = (syndrome_o == 8'h9c) ^ data_i[22];
-    data_o[23] = (syndrome_o == 8'h9d) ^ data_i[23];
-    data_o[24] = (syndrome_o == 8'h9e) ^ data_i[24];
-    data_o[25] = (syndrome_o == 8'h9f) ^ data_i[25];
-    data_o[26] = (syndrome_o == 8'ha1) ^ data_i[26];
-    data_o[27] = (syndrome_o == 8'ha2) ^ data_i[27];
-    data_o[28] = (syndrome_o == 8'ha3) ^ data_i[28];
-    data_o[29] = (syndrome_o == 8'ha4) ^ data_i[29];
-    data_o[30] = (syndrome_o == 8'ha5) ^ data_i[30];
-    data_o[31] = (syndrome_o == 8'ha6) ^ data_i[31];
-    data_o[32] = (syndrome_o == 8'ha7) ^ data_i[32];
-    data_o[33] = (syndrome_o == 8'ha8) ^ data_i[33];
-    data_o[34] = (syndrome_o == 8'ha9) ^ data_i[34];
-    data_o[35] = (syndrome_o == 8'haa) ^ data_i[35];
-    data_o[36] = (syndrome_o == 8'hab) ^ data_i[36];
-    data_o[37] = (syndrome_o == 8'hac) ^ data_i[37];
-    data_o[38] = (syndrome_o == 8'had) ^ data_i[38];
-    data_o[39] = (syndrome_o == 8'hae) ^ data_i[39];
-    data_o[40] = (syndrome_o == 8'haf) ^ data_i[40];
-    data_o[41] = (syndrome_o == 8'hb0) ^ data_i[41];
-    data_o[42] = (syndrome_o == 8'hb1) ^ data_i[42];
-    data_o[43] = (syndrome_o == 8'hb2) ^ data_i[43];
-    data_o[44] = (syndrome_o == 8'hb3) ^ data_i[44];
-    data_o[45] = (syndrome_o == 8'hb4) ^ data_i[45];
-    data_o[46] = (syndrome_o == 8'hb5) ^ data_i[46];
-    data_o[47] = (syndrome_o == 8'hb6) ^ data_i[47];
-    data_o[48] = (syndrome_o == 8'hb7) ^ data_i[48];
-    data_o[49] = (syndrome_o == 8'hb8) ^ data_i[49];
-    data_o[50] = (syndrome_o == 8'hb9) ^ data_i[50];
-    data_o[51] = (syndrome_o == 8'hba) ^ data_i[51];
-    data_o[52] = (syndrome_o == 8'hbb) ^ data_i[52];
-    data_o[53] = (syndrome_o == 8'hbc) ^ data_i[53];
-    data_o[54] = (syndrome_o == 8'hbd) ^ data_i[54];
-    data_o[55] = (syndrome_o == 8'hbe) ^ data_i[55];
-    data_o[56] = (syndrome_o == 8'hbf) ^ data_i[56];
-    data_o[57] = (syndrome_o == 8'hc1) ^ data_i[57];
-    data_o[58] = (syndrome_o == 8'hc2) ^ data_i[58];
-    data_o[59] = (syndrome_o == 8'hc3) ^ data_i[59];
-    data_o[60] = (syndrome_o == 8'hc4) ^ data_i[60];
-    data_o[61] = (syndrome_o == 8'hc5) ^ data_i[61];
-    data_o[62] = (syndrome_o == 8'hc6) ^ data_i[62];
-    data_o[63] = (syndrome_o == 8'hc7) ^ data_i[63];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = syndrome_o[7];
-    err_o[1] = |syndrome_o[6:0] & ~syndrome_o[7];
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-  function automatic logic [75:0]
-      prim_secded_inv_hamming_76_68_enc (logic [67:0] data_i);
-    logic [75:0] data_o;
-    data_o = 76'(data_i);
-    data_o[68] = 1'b0 ^ ^(data_o & 76'h00AAB55555556AAAD5B);
-    data_o[69] = 1'b1 ^ ^(data_o & 76'h00CCD9999999B33366D);
-    data_o[70] = 1'b0 ^ ^(data_o & 76'h000F1E1E1E1E3C3C78E);
-    data_o[71] = 1'b1 ^ ^(data_o & 76'h00F01FE01FE03FC07F0);
-    data_o[72] = 1'b0 ^ ^(data_o & 76'h00001FFFE0003FFF800);
-    data_o[73] = 1'b1 ^ ^(data_o & 76'h00001FFFFFFFC000000);
-    data_o[74] = 1'b0 ^ ^(data_o & 76'h00FFE00000000000000);
-    data_o[75] = 1'b1 ^ ^(data_o & 76'h7FFFFFFFFFFFFFFFFFF);
-    return data_o;
-  endfunction
-
-  function automatic secded_inv_hamming_76_68_t
-      prim_secded_inv_hamming_76_68_dec (logic [75:0] data_i);
-    logic [67:0] data_o;
-    logic [7:0] syndrome_o;
-    logic [1:0]  err_o;
-
-    secded_inv_hamming_76_68_t dec;
-
-    // Syndrome calculation
-    syndrome_o[0] = ^((data_i ^ 76'hAA00000000000000000) & 76'h01AAB55555556AAAD5B);
-    syndrome_o[1] = ^((data_i ^ 76'hAA00000000000000000) & 76'h02CCD9999999B33366D);
-    syndrome_o[2] = ^((data_i ^ 76'hAA00000000000000000) & 76'h040F1E1E1E1E3C3C78E);
-    syndrome_o[3] = ^((data_i ^ 76'hAA00000000000000000) & 76'h08F01FE01FE03FC07F0);
-    syndrome_o[4] = ^((data_i ^ 76'hAA00000000000000000) & 76'h10001FFFE0003FFF800);
-    syndrome_o[5] = ^((data_i ^ 76'hAA00000000000000000) & 76'h20001FFFFFFFC000000);
-    syndrome_o[6] = ^((data_i ^ 76'hAA00000000000000000) & 76'h40FFE00000000000000);
-    syndrome_o[7] = ^((data_i ^ 76'hAA00000000000000000) & 76'hFFFFFFFFFFFFFFFFFFF);
-
-    // Corrected output calculation
-    data_o[0] = (syndrome_o == 8'h83) ^ data_i[0];
-    data_o[1] = (syndrome_o == 8'h85) ^ data_i[1];
-    data_o[2] = (syndrome_o == 8'h86) ^ data_i[2];
-    data_o[3] = (syndrome_o == 8'h87) ^ data_i[3];
-    data_o[4] = (syndrome_o == 8'h89) ^ data_i[4];
-    data_o[5] = (syndrome_o == 8'h8a) ^ data_i[5];
-    data_o[6] = (syndrome_o == 8'h8b) ^ data_i[6];
-    data_o[7] = (syndrome_o == 8'h8c) ^ data_i[7];
-    data_o[8] = (syndrome_o == 8'h8d) ^ data_i[8];
-    data_o[9] = (syndrome_o == 8'h8e) ^ data_i[9];
-    data_o[10] = (syndrome_o == 8'h8f) ^ data_i[10];
-    data_o[11] = (syndrome_o == 8'h91) ^ data_i[11];
-    data_o[12] = (syndrome_o == 8'h92) ^ data_i[12];
-    data_o[13] = (syndrome_o == 8'h93) ^ data_i[13];
-    data_o[14] = (syndrome_o == 8'h94) ^ data_i[14];
-    data_o[15] = (syndrome_o == 8'h95) ^ data_i[15];
-    data_o[16] = (syndrome_o == 8'h96) ^ data_i[16];
-    data_o[17] = (syndrome_o == 8'h97) ^ data_i[17];
-    data_o[18] = (syndrome_o == 8'h98) ^ data_i[18];
-    data_o[19] = (syndrome_o == 8'h99) ^ data_i[19];
-    data_o[20] = (syndrome_o == 8'h9a) ^ data_i[20];
-    data_o[21] = (syndrome_o == 8'h9b) ^ data_i[21];
-    data_o[22] = (syndrome_o == 8'h9c) ^ data_i[22];
-    data_o[23] = (syndrome_o == 8'h9d) ^ data_i[23];
-    data_o[24] = (syndrome_o == 8'h9e) ^ data_i[24];
-    data_o[25] = (syndrome_o == 8'h9f) ^ data_i[25];
-    data_o[26] = (syndrome_o == 8'ha1) ^ data_i[26];
-    data_o[27] = (syndrome_o == 8'ha2) ^ data_i[27];
-    data_o[28] = (syndrome_o == 8'ha3) ^ data_i[28];
-    data_o[29] = (syndrome_o == 8'ha4) ^ data_i[29];
-    data_o[30] = (syndrome_o == 8'ha5) ^ data_i[30];
-    data_o[31] = (syndrome_o == 8'ha6) ^ data_i[31];
-    data_o[32] = (syndrome_o == 8'ha7) ^ data_i[32];
-    data_o[33] = (syndrome_o == 8'ha8) ^ data_i[33];
-    data_o[34] = (syndrome_o == 8'ha9) ^ data_i[34];
-    data_o[35] = (syndrome_o == 8'haa) ^ data_i[35];
-    data_o[36] = (syndrome_o == 8'hab) ^ data_i[36];
-    data_o[37] = (syndrome_o == 8'hac) ^ data_i[37];
-    data_o[38] = (syndrome_o == 8'had) ^ data_i[38];
-    data_o[39] = (syndrome_o == 8'hae) ^ data_i[39];
-    data_o[40] = (syndrome_o == 8'haf) ^ data_i[40];
-    data_o[41] = (syndrome_o == 8'hb0) ^ data_i[41];
-    data_o[42] = (syndrome_o == 8'hb1) ^ data_i[42];
-    data_o[43] = (syndrome_o == 8'hb2) ^ data_i[43];
-    data_o[44] = (syndrome_o == 8'hb3) ^ data_i[44];
-    data_o[45] = (syndrome_o == 8'hb4) ^ data_i[45];
-    data_o[46] = (syndrome_o == 8'hb5) ^ data_i[46];
-    data_o[47] = (syndrome_o == 8'hb6) ^ data_i[47];
-    data_o[48] = (syndrome_o == 8'hb7) ^ data_i[48];
-    data_o[49] = (syndrome_o == 8'hb8) ^ data_i[49];
-    data_o[50] = (syndrome_o == 8'hb9) ^ data_i[50];
-    data_o[51] = (syndrome_o == 8'hba) ^ data_i[51];
-    data_o[52] = (syndrome_o == 8'hbb) ^ data_i[52];
-    data_o[53] = (syndrome_o == 8'hbc) ^ data_i[53];
-    data_o[54] = (syndrome_o == 8'hbd) ^ data_i[54];
-    data_o[55] = (syndrome_o == 8'hbe) ^ data_i[55];
-    data_o[56] = (syndrome_o == 8'hbf) ^ data_i[56];
-    data_o[57] = (syndrome_o == 8'hc1) ^ data_i[57];
-    data_o[58] = (syndrome_o == 8'hc2) ^ data_i[58];
-    data_o[59] = (syndrome_o == 8'hc3) ^ data_i[59];
-    data_o[60] = (syndrome_o == 8'hc4) ^ data_i[60];
-    data_o[61] = (syndrome_o == 8'hc5) ^ data_i[61];
-    data_o[62] = (syndrome_o == 8'hc6) ^ data_i[62];
-    data_o[63] = (syndrome_o == 8'hc7) ^ data_i[63];
-    data_o[64] = (syndrome_o == 8'hc8) ^ data_i[64];
-    data_o[65] = (syndrome_o == 8'hc9) ^ data_i[65];
-    data_o[66] = (syndrome_o == 8'hca) ^ data_i[66];
-    data_o[67] = (syndrome_o == 8'hcb) ^ data_i[67];
-
-    // err_o calc. bit0: single error, bit1: double error
-    err_o[0] = syndrome_o[7];
-    err_o[1] = |syndrome_o[6:0] & ~syndrome_o[7];
-
-    dec.data      = data_o;
-    dec.syndrome  = syndrome_o;
-    dec.err       = err_o;
-    return dec;
-
-  endfunction
-
-
-endpackage
diff --git a/prim_slicer.sv b/prim_slicer.sv
deleted file mode 100644
index 3c61669e..00000000
--- a/prim_slicer.sv
+++ /dev/null
@@ -1,32 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Slicer chops the incoming bitstring into OutW granularity.
-// It supports fractional InW/OutW which fills 0 at the end of message.
-
-`include "prim_assert.sv"
-
-module prim_slicer #(
-  parameter int InW = 64,
-  parameter int OutW = 8,
-
-  parameter int IndexW = 4
-) (
-  input        [IndexW-1:0] sel_i,
-  input        [InW-1:0]    data_i,
-  output logic [OutW-1:0]   data_o
-);
-
-  localparam int UnrollW = OutW*(2**IndexW);
-
-  logic [UnrollW-1:0] unrolled_data;
-
-  assign unrolled_data = UnrollW'(data_i);
-
-  assign data_o = unrolled_data[sel_i*OutW+:OutW];
-
-  `ASSERT_INIT(ValidWidth_A, InW <= OutW*(2**IndexW))
-
-endmodule
-
diff --git a/prim_sparse_fsm_flop.sv b/prim_sparse_fsm_flop.sv
deleted file mode 100644
index a327457f..00000000
--- a/prim_sparse_fsm_flop.sv
+++ /dev/null
@@ -1,56 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-
-`include "prim_assert.sv"
-
-module prim_sparse_fsm_flop #(
-  parameter type              StateEnumT = logic,
-  parameter int               Width      = 1,
-  parameter logic [Width-1:0] ResetValue = 0,
-  // This should only be disabled in special circumstances, for example
-  // in non-comportable IPs where an error does not trigger an alert.
-  parameter bit               EnableAlertTriggerSVA = 1
-) (
-  input                    clk_i,
-  input                    rst_ni,
-  input        [Width-1:0] state_i,
-  output logic [Width-1:0] state_o
-);
-
-  logic unused_err_o;
-
-  prim_flop #(
-    .Width(Width),
-    .ResetValue(ResetValue)
-  ) u_state_flop (
-    .clk_i,
-    .rst_ni,
-    .d_i(state_i),
-    .q_o(state_o)
-  );
-
-  `ifdef INC_ASSERT
-  assign unused_err_o = is_undefined_state(state_o);
-
-  function automatic logic is_undefined_state(logic [Width-1:0] sig);
-    for (int i = 0, StateEnumT t = t.first(); i < t.num(); i += 1, t = t.next()) begin
-      if (StateEnumT'(sig) === t) return 0;
-    end
-    return 1;
-  endfunction
-
-  `else
-    assign unused_err_o = 1'b0;
-  `endif
-
-  // If ASSERT_PRIM_FSM_ERROR_TRIGGER_ALERT is declared, the unused_assert_connected signal will
-  // be set to 1 and the below check will pass.
-  // If the assertion is not declared however, the statement below will fail.
-  `ifdef INC_ASSERT
-  logic unused_assert_connected;
-
-  `ASSERT_INIT_NET(AssertConnected_A, unused_assert_connected === 1'b1 || !EnableAlertTriggerSVA)
-  `endif
-
-endmodule
diff --git a/prim_sram_arbiter.sv b/prim_sram_arbiter.sv
deleted file mode 100644
index acb9b8a2..00000000
--- a/prim_sram_arbiter.sv
+++ /dev/null
@@ -1,153 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// N:1 SRAM arbiter
-//
-// Parameter
-//  N:  Number of requst port
-//  DW: Data width (SECDED is not included)
-//  Aw: Address width
-//  ArbiterImpl: can be either PPC or BINTREE.
-`include "prim_assert.sv"
-
-module prim_sram_arbiter #(
-  parameter int unsigned N  = 4,
-  parameter int unsigned SramDw = 32,
-  parameter int unsigned SramAw = 12,
-  parameter ArbiterImpl = "PPC",
-  parameter bit EnMask = 1'b 0 // Disable wmask if 0
-) (
-  input clk_i,
-  input rst_ni,
-
-  input        [     N-1:0] req_i,
-  input        [SramAw-1:0] req_addr_i [N],
-  input        [     N-1:0] req_write_i,
-  input        [SramDw-1:0] req_wdata_i[N],
-  input        [SramDw-1:0] req_wmask_i[N],
-  output logic [     N-1:0] gnt_o,
-
-  output logic [     N-1:0] rsp_rvalid_o,      // Pulse
-  output logic [SramDw-1:0] rsp_rdata_o[N],
-  output logic [       1:0] rsp_error_o[N],
-
-  // SRAM Interface
-  output logic              sram_req_o,
-  output logic [SramAw-1:0] sram_addr_o,
-  output logic              sram_write_o,
-  output logic [SramDw-1:0] sram_wdata_o,
-  output logic [SramDw-1:0] sram_wmask_o,
-  input                     sram_rvalid_i,
-  input        [SramDw-1:0] sram_rdata_i,
-  input        [1:0]        sram_rerror_i
-);
-
-  typedef struct packed {
-    logic write;
-    logic [SramAw-1:0] addr;
-    logic [SramDw-1:0] wdata;
-    logic [SramDw-1:0] wmask;
-  } req_t;
-
-  req_t req_packed [N];
-
-  for (genvar i = 0 ; i < N ; i++) begin : gen_reqs
-    assign req_packed[i] = {
-      req_write_i[i],
-      req_addr_i [i],
-      req_wdata_i[i],
-      (EnMask) ? req_wmask_i[i] : {SramDw{1'b1}}
-    };
-  end
-
-  localparam int ARB_DW = $bits(req_t);
-
-  req_t sram_packed;
-  assign sram_write_o = sram_packed.write;
-  assign sram_addr_o  = sram_packed.addr;
-  assign sram_wdata_o = sram_packed.wdata;
-  assign sram_wmask_o = (EnMask) ? sram_packed.wmask : {SramDw{1'b1}};
-
-  if (EnMask == 1'b 0) begin : g_unused
-    logic unused_wmask;
-
-    always_comb begin
-      unused_wmask = 1'b 1;
-      for (int unsigned i = 0 ; i < N ; i++) begin
-        unused_wmask ^= ^req_wmask_i[i];
-      end
-      unused_wmask ^= ^sram_packed.wmask;
-    end
-  end
-
-
-  if (ArbiterImpl == "PPC") begin : gen_arb_ppc
-    prim_arbiter_ppc #(
-      .N (N),
-      .DW(ARB_DW)
-    ) u_reqarb (
-      .clk_i,
-      .rst_ni,
-      .req_chk_i ( 1'b1        ),
-      .req_i,
-      .data_i    ( req_packed  ),
-      .gnt_o,
-      .idx_o     (             ),
-      .valid_o   ( sram_req_o  ),
-      .data_o    ( sram_packed ),
-      .ready_i   ( 1'b1        )
-    );
-  end else if (ArbiterImpl == "BINTREE") begin : gen_tree_arb
-    prim_arbiter_tree #(
-      .N (N),
-      .DW(ARB_DW)
-    ) u_reqarb (
-      .clk_i,
-      .rst_ni,
-      .req_chk_i ( 1'b1        ),
-      .req_i,
-      .data_i    ( req_packed  ),
-      .gnt_o,
-      .idx_o     (             ),
-      .valid_o   ( sram_req_o  ),
-      .data_o    ( sram_packed ),
-      .ready_i   ( 1'b1        )
-    );
-  end else begin : gen_unknown
-    `ASSERT_INIT(UnknownArbImpl_A, 0)
-  end
-
-
-  logic [N-1:0] steer;    // Steering sram_rvalid_i
-  logic sram_ack;         // Ack for rvalid. |sram_rvalid_i
-
-  assign sram_ack = sram_rvalid_i & (|steer);
-
-  // Request FIFO
-  prim_fifo_sync #(
-    .Width    (N),
-    .Pass     (1'b0),
-    .Depth    (4)        // Assume at most 4 pipelined
-  ) u_req_fifo (
-    .clk_i,
-    .rst_ni,
-    .clr_i    (1'b0),
-    .wvalid_i (sram_req_o & ~sram_write_o),  // Push only for read
-    .wready_o (),     // TODO: Generate Error
-    .wdata_i  (gnt_o),
-    .rvalid_o (),     // TODO; Generate error if sram_rvalid_i but rvalid==0
-    .rready_i (sram_ack),
-    .rdata_o  (steer),
-    .full_o   (),
-    .depth_o  ()     // Not used
-  );
-
-  assign rsp_rvalid_o = steer & {N{sram_rvalid_i}};
-
-  for (genvar i = 0 ; i < N ; i++) begin : gen_rsp
-    assign rsp_rdata_o[i] = sram_rdata_i;
-    assign rsp_error_o[i] = sram_rerror_i; // No SECDED yet
-  end
-
-endmodule
diff --git a/prim_subreg.sv b/prim_subreg.sv
deleted file mode 100644
index 103a948c..00000000
--- a/prim_subreg.sv
+++ /dev/null
@@ -1,82 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Register slice conforming to Comportibility guide.
-
-module prim_subreg
-  import prim_subreg_pkg::*;
-#(
-  parameter int            DW       = 32,
-  parameter sw_access_e    SwAccess = SwAccessRW,
-  parameter logic [DW-1:0] RESVAL   = '0    // reset value
-) (
-  input clk_i,
-  input rst_ni,
-
-  // From SW: valid for RW, WO, W1C, W1S, W0C, RC
-  // In case of RC, Top connects Read Pulse to we
-  input          we,
-  input [DW-1:0] wd,
-
-  // From HW: valid for HRW, HWO
-  input          de,
-  input [DW-1:0] d,
-
-  // output to HW and Reg Read
-  output logic          qe,
-  output logic [DW-1:0] q,
-  output logic [DW-1:0] qs
-);
-
-  logic          wr_en;
-  logic [DW-1:0] wr_data;
-
-  prim_subreg_arb #(
-    .DW       ( DW       ),
-    .SwAccess ( SwAccess )
-  ) wr_en_data_arb (
-    .we,
-    .wd,
-    .de,
-    .d,
-    .q,
-    .wr_en,
-    .wr_data
-  );
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      qe <= 1'b0;
-    end else begin
-      qe <= we;
-    end
-  end
-
-  logic wr_en_buf;
-  prim_buf #(
-    .Width(1)
-  ) u_wr_en_buf (
-    .in_i(wr_en),
-    .out_o(wr_en_buf)
-  );
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      q <= RESVAL;
-    end else if (wr_en_buf) begin
-      q <= wr_data;
-    end
-  end
-
-  logic [DW-1:0] q_buf;
-  prim_buf #(
-    .Width(DW)
-  ) u_q_buf (
-    .in_i(q),
-    .out_o(q_buf)
-  );
-
-  assign qs = q_buf;
-
-endmodule
diff --git a/prim_subreg_arb.sv b/prim_subreg_arb.sv
deleted file mode 100644
index 80033366..00000000
--- a/prim_subreg_arb.sv
+++ /dev/null
@@ -1,81 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Write enable and data arbitration logic for register slice conforming to Comportibility guide.
-
-module prim_subreg_arb
-  import prim_subreg_pkg::*;
-#(
-  parameter int         DW       = 32,
-  parameter sw_access_e SwAccess = SwAccessRW
-) (
-  // From SW: valid for RW, WO, W1C, W1S, W0C, RC.
-  // In case of RC, top connects read pulse to we.
-  input          we,
-  input [DW-1:0] wd,
-
-  // From HW: valid for HRW, HWO.
-  input          de,
-  input [DW-1:0] d,
-
-  // From register: actual reg value.
-  input [DW-1:0] q,
-
-  // To register: actual write enable and write data.
-  output logic          wr_en,
-  output logic [DW-1:0] wr_data
-);
-
-  if (SwAccess inside {SwAccessRW, SwAccessWO}) begin : gen_w
-    assign wr_en   = we | de;
-    assign wr_data = (we == 1'b1) ? wd : d; // SW higher priority
-    // Unused q - Prevent lint errors.
-    logic [DW-1:0] unused_q;
-    assign unused_q = q;
-  end else if (SwAccess == SwAccessRO) begin : gen_ro
-    assign wr_en   = de;
-    assign wr_data = d;
-    // Unused we, wd, q - Prevent lint errors.
-    logic          unused_we;
-    logic [DW-1:0] unused_wd;
-    logic [DW-1:0] unused_q;
-    assign unused_we = we;
-    assign unused_wd = wd;
-    assign unused_q  = q;
-  end else if (SwAccess == SwAccessW1S) begin : gen_w1s
-    // If SwAccess is W1S, then assume hw tries to clear.
-    // So, give a chance HW to clear when SW tries to set.
-    // If both try to set/clr at the same bit pos, SW wins.
-    assign wr_en   = we | de;
-    assign wr_data = (de ? d : q) | (we ? wd : '0);
-  end else if (SwAccess == SwAccessW1C) begin : gen_w1c
-    // If SwAccess is W1C, then assume hw tries to set.
-    // So, give a chance HW to set when SW tries to clear.
-    // If both try to set/clr at the same bit pos, SW wins.
-    assign wr_en   = we | de;
-    assign wr_data = (de ? d : q) & (we ? ~wd : '1);
-  end else if (SwAccess == SwAccessW0C) begin : gen_w0c
-    assign wr_en   = we | de;
-    assign wr_data = (de ? d : q) & (we ? wd : '1);
-  end else if (SwAccess == SwAccessRC) begin : gen_rc
-    // This swtype is not recommended but exists for compatibility.
-    // WARN: we signal is actually read signal not write enable.
-    assign wr_en  = we | de;
-    assign wr_data = (de ? d : q) & (we ? '0 : '1);
-    // Unused wd - Prevent lint errors.
-    logic [DW-1:0] unused_wd;
-    assign unused_wd = wd;
-  end else begin : gen_hw
-    assign wr_en   = de;
-    assign wr_data = d;
-    // Unused we, wd, q - Prevent lint errors.
-    logic          unused_we;
-    logic [DW-1:0] unused_wd;
-    logic [DW-1:0] unused_q;
-    assign unused_we = we;
-    assign unused_wd = wd;
-    assign unused_q  = q;
-  end
-
-endmodule
diff --git a/prim_subreg_async.sv b/prim_subreg_async.sv
deleted file mode 100644
index b9d1ae13..00000000
--- a/prim_subreg_async.sv
+++ /dev/null
@@ -1,85 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Asynchronous implementation of prim_subreg
-
-module prim_subreg_async
-  import prim_subreg_pkg::*;
-#(
-  parameter int            DW       = 32  ,
-  parameter sw_access_e    SwAccess = SwAccessRW,
-  parameter logic [DW-1:0] RESVAL   = '0    // Reset value
-) (
-  input clk_src_i,
-  input rst_src_ni,
-  input clk_dst_i,
-  input rst_dst_ni,
-
-  // destination sample pulse
-  input src_update_i,
-
-  // From SW: valid for RW, WO, W1C, W1S, W0C, RC
-  // In case of RC, Top connects Read Pulse to we
-  input          src_we_i,
-  input [DW-1:0] src_wd_i,
-
-  // From HW: valid for HRW, HWO
-  input          dst_de_i,
-  input [DW-1:0] dst_d_i,
-
-  // output to Reg Read
-  output logic          src_busy_o,
-  output logic [DW-1:0] src_qs_o,
-
-  // output to HW read
-  output logic          dst_qe_o,
-  // This output does not follow comportable convention to work with
-  // current DV assumptions.
-  output logic [DW-1:0] q
-);
-
-  logic dst_we;
-  logic [DW-1:0] dst_wdata;
-  logic [DW-1:0] q_int;
-
-  prim_subreg_cdc #(
-    .DW(DW),
-    .RESVAL(RESVAL)
-  ) u_reg_cdc (
-    .clk_src_i,
-    .rst_src_ni,
-    .clk_dst_i,
-    .rst_dst_ni,
-    .src_update_i,
-    .src_req_i(src_we_i),
-    // data that crosses domain
-    .src_data_i(src_wd_i),
-    // data readback to software
-    .src_data_o(src_qs_o),
-    .src_busy_o,
-    .dst_req_o(dst_we),
-    // hardware written data
-    .dst_data_i(q_int),
-    // data to write to hardware
-    .dst_data_o(dst_wdata)
-  );
-
-  prim_subreg #(
-    .DW(DW),
-    .SwAccess(SwAccess),
-    .RESVAL(RESVAL)
-  ) u_subreg (
-    .clk_i(clk_dst_i),
-    .rst_ni(rst_dst_ni),
-    .we(dst_we),
-    .wd(dst_wdata),
-    .de(dst_de_i),
-    .d(dst_d_i),
-    .qe(dst_qe_o),
-    .q(q_int),
-    .qs()
-  );
-  assign q = q_int;
-
-endmodule
diff --git a/prim_subreg_cdc.sv b/prim_subreg_cdc.sv
deleted file mode 100644
index 18618be8..00000000
--- a/prim_subreg_cdc.sv
+++ /dev/null
@@ -1,135 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Component handling register CDC
-
-`include "prim_assert.sv"
-
-module prim_subreg_cdc #(
-  parameter int            DW       = 32,
-  parameter logic [DW-1:0] RESVAL   = '0    // Reset value
-) (
-  input clk_src_i,
-  input rst_src_ni,
-  input clk_dst_i,
-  input rst_dst_ni,
-
-  input src_update_i,
-  input src_req_i,
-  input [DW-1:0] src_data_i,
-  output logic src_busy_o,
-  output logic [DW-1:0] src_data_o,
-
-  input [DW-1:0] dst_data_i,
-  output logic dst_req_o,
-  output logic [DW-1:0] dst_data_o
-);
-
-  ////////////////////////////
-  // Source domain
-  ////////////////////////////
-  logic src_ack;
-  logic src_busy_q;
-  logic [DW-1:0] src_q;
-
-  // busy indication back-pressures upstream if the register is accessed
-  // again.  The busy indication is also used as a "commit" indication for
-  // resolving software and hardware write conflicts
-  always_ff @(posedge clk_src_i or negedge rst_src_ni) begin
-    if (!rst_src_ni) begin
-      src_busy_q <= '0;
-    end else if (src_req_i) begin
-      src_busy_q <= 1'b1;
-    end else if (src_busy_q && src_ack) begin
-      src_busy_q <= 1'b0;
-    end
-  end
-
-  assign src_busy_o = src_busy_q;
-
-  // src_q acts as both the write holding register and the software read back
-  // register.
-  // When software performs a write, the write data is captured in src_q for
-  // CDC purposes.  When not performing a write, the src_q periodically
-  // samples the destination domain using the src_update_i indication.
-  //
-  // To resolve software and hardware conflicts, the process is as follows:
-  // When software issues a write, this module asserts "busy".  While busy,
-  // src_q does not sample the destination value.  Since the
-  // logic has committed to updating based on software command, there is an irreversible
-  // window from which hardware writes are ignored.  Once the busy window completes,
-  // the cdc portion then begins sampling once more.
-  //
-  // This is consistent with prim_subreg_arb where during software / hardware conflicts,
-  // software is always prioritized.  The main difference is the conflict resolution window
-  // is now larger instead of just one destination clock cycle.
-
-  logic busy;
-  assign busy = src_busy_q & !src_ack;
-
-  always_ff @(posedge clk_src_i or negedge rst_src_ni) begin
-    if (!rst_src_ni) begin
-      src_q <= RESVAL;
-    end else if (src_req_i && !busy) begin
-      src_q <= src_data_i;
-    end else if (src_busy_q && src_ack || src_update_i && !busy) begin
-      // sample data whenever a busy transaction finishes OR
-      // when an update pulse is seen.
-      // TODO: We should add a cover group to test different sync timings
-      // between src_ack and src_update. Ie, there can be 3 scearios:
-      // 1. update one cycle before ack
-      // 2. ack one cycle before update
-      // 3. update / ack on the same cycle
-      // During all 3 cases the read data should be correct
-      src_q <= dst_data_i;
-    end
-  end
-
-  // src_q is always updated in the clk_src domain.
-  // when performing an update to the destination domain, it is guaranteed
-  // to not change by protocol.
-  assign src_data_o = src_q;
-  assign dst_data_o = src_q;
-
-  ////////////////////////////
-  // CDC handling
-  ////////////////////////////
-  prim_sync_reqack u_prim_sync (
-    .clk_src_i,
-    .rst_src_ni,
-    .clk_dst_i,
-    .rst_dst_ni,
-    .req_chk_i(1'b0),
-    // prim_sync_reqack does not natively handle single
-    // pulse requests, so use src_busy to even it out.
-    .src_req_i(src_req_i | src_busy_q),
-    .src_ack_o(src_ack),
-    .dst_req_o(dst_req_o),
-    // immediately ack on destination once request is seen
-    .dst_ack_i(dst_req_o)
-  );
-
-  `ASSERT_KNOWN(SrcBusyKnown_A, src_busy_o, clk_src_i, !rst_src_ni)
-  `ASSERT_KNOWN(DstReqKnown_A, dst_req_o, clk_dst_i, !rst_dst_ni)
-
-  // If busy goes high, we must eventually see an ack
-  `ASSERT(HungHandShake_A, $rose(src_busy_o) |-> strong(##[0:$] src_ack), clk_src_i, !rst_src_ni)
-
-  `ifdef SIMULATION
-    logic async_flag;
-    always_ff @(posedge src_req_i or posedge dst_req_o or
-      negedge rst_src_ni or negedge rst_dst_ni) begin
-      if (!rst_src_ni && !rst_dst_ni) begin
-        async_flag <= '0;
-      end else if (src_req_i) begin
-        async_flag <= 1'b1;
-      end else if (dst_req_o) begin
-        async_flag <= 1'b0;
-      end
-    end
-    `ASSERT(ReqTimeout_A, $rose(async_flag) |-> strong(##[0:3] dst_req_o), clk_dst_i, !rst_dst_ni)
-  `endif
-
-
-endmodule // prim_subreg_cdc
diff --git a/prim_subreg_ext.sv b/prim_subreg_ext.sv
deleted file mode 100644
index 6db975d8..00000000
--- a/prim_subreg_ext.sv
+++ /dev/null
@@ -1,28 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Register slice conforming to Comportibility guide.
-
-module prim_subreg_ext #(
-  parameter int unsigned DW = 32
-) (
-  input          re,
-  input          we,
-  input [DW-1:0] wd,
-
-  input [DW-1:0] d,
-
-  // output to HW and Reg Read
-  output logic          qe,
-  output logic          qre,
-  output logic [DW-1:0] q,
-  output logic [DW-1:0] qs
-);
-
-  assign qs = d;
-  assign q = wd;
-  assign qe = we;
-  assign qre = re;
-
-endmodule
diff --git a/prim_subreg_ext_async.sv b/prim_subreg_ext_async.sv
deleted file mode 100644
index 7b8576e3..00000000
--- a/prim_subreg_ext_async.sv
+++ /dev/null
@@ -1,68 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Asynchronous implementation of prim_subreg_ext
-
-module prim_subreg_ext_async #(
-  parameter int unsigned DW = 32
-) (
-  input          clk_src_i,
-  input          rst_src_ni,
-  input          clk_dst_i,
-  input          rst_dst_ni,
-
-  // source domain signals
-  input          re,
-  input          we,
-  input [DW-1:0] wd,
-  input          src_update_i,
-  output logic   src_busy_o,
-
-  // destination domain signals
-  input [DW-1:0] d,
-
-  // outputs to destination domain
-  output logic          qe,
-  output logic          qre,
-  output logic [DW-1:0] q,
-
-  // outputs to source domain
-  output logic [DW-1:0] qs
-);
-
-  logic dst_req;
-  logic [DW-1:0] dst_wdata;
-  logic dst_we;
-  logic unused_src_we;
-
-  // Capture both data and write-enable
-  // write enable is needed to determine whether qe or qre should be generated
-  // in the desitnation domain.
-  prim_subreg_cdc #(
-    .DW(DW + 1)
-  ) u_reg_cdc (
-    .clk_src_i,
-    .rst_src_ni,
-    .clk_dst_i,
-    .rst_dst_ni,
-    .src_update_i,
-    .src_req_i(re | we),
-    .src_data_i({wd, we}),
-    .src_data_o({qs, unused_src_we}),
-    .src_busy_o,
-    .dst_req_o(dst_req),
-    .dst_data_i({d, 1'b0}),
-    .dst_data_o({dst_wdata, dst_we})
-  );
-
-  /////////////////////
-  // Destination domain
-  /////////////////////
-
-  assign qe  = dst_req ? dst_we    : '0;
-  assign qre = dst_req ? ~dst_we   : '0;
-  assign q   = dst_req ? dst_wdata : '0;
-
-
-endmodule
diff --git a/prim_subreg_pkg.sv b/prim_subreg_pkg.sv
deleted file mode 100644
index 6e1da043..00000000
--- a/prim_subreg_pkg.sv
+++ /dev/null
@@ -1,17 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-
-package prim_subreg_pkg;
-
-  // Register access specifier
-  typedef enum logic [2:0] {
-    SwAccessRW  = 3'd0, // Read-write
-    SwAccessRO  = 3'd1, // Read-only
-    SwAccessWO  = 3'd2, // Write-only
-    SwAccessW1C = 3'd3, // Write 1 to clear
-    SwAccessW1S = 3'd4, // Write 1 to set
-    SwAccessW0C = 3'd5, // Write 0 to clear
-    SwAccessRC  = 3'd6  // Read to clear. Do not use, only exists for compatibility.
-  } sw_access_e;
-endpackage
diff --git a/prim_subreg_shadow.sv b/prim_subreg_shadow.sv
deleted file mode 100644
index 37bad65f..00000000
--- a/prim_subreg_shadow.sv
+++ /dev/null
@@ -1,186 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Shadowed register slice conforming to Comportibility guide.
-
-`include "prim_assert.sv"
-
-module prim_subreg_shadow
-  import prim_subreg_pkg::*;
-#(
-  parameter int            DW       = 32,
-  parameter sw_access_e    SwAccess = SwAccessRW,
-  parameter logic [DW-1:0] RESVAL   = '0    // reset value
-) (
-  input clk_i,
-  input rst_ni,
-  input rst_shadowed_ni,
-
-  // From SW: valid for RW, WO, W1C, W1S, W0C, RC.
-  // SW reads clear phase unless SwAccess is RO.
-  input          re,
-  // In case of RC, top connects read pulse to we.
-  input          we,
-  input [DW-1:0] wd,
-
-  // From HW: valid for HRW, HWO.
-  input          de,
-  input [DW-1:0] d,
-
-  // Output to HW and Reg Read
-  output logic          qe,
-  output logic [DW-1:0] q,
-  output logic [DW-1:0] qs,
-
-  // Phase output to HW
-  output logic phase,
-
-  // Error conditions
-  output logic err_update,
-  output logic err_storage
-);
-
-  // Since the shadow register works with the 1's complement value,
-  // we need to invert the polarity of the SW access if it is either "W1S" or "W0C".
-  // W1C is forbidden since the W0S complement is not implemented.
-  `ASSERT_INIT(CheckSwAccessIsLegal_A,
-      SwAccess inside {SwAccessRW, SwAccessRO, SwAccessWO, SwAccessW1S, SwAccessW0C})
-  localparam sw_access_e InvertedSwAccess = (SwAccess == SwAccessW1S) ? SwAccessW0C :
-                                            (SwAccess == SwAccessW0C) ? SwAccessW1S : SwAccess;
-
-  // For the staging register, we set the SwAccess to RW in case of W1S and W0C in
-  // order to always capture the data value on the first write operation - no matter
-  // whether the data value will actually have an effect. That way, we can still capture
-  // inconsistent double writes which would otherwise be ignored due to the data value filtering
-  // effect that W1S and W0C can have.
-  localparam sw_access_e StagedSwAccess = (SwAccess == SwAccessW1S) ? SwAccessRW :
-                                          (SwAccess == SwAccessW0C) ? SwAccessRW : SwAccess;
-
-  // Subreg control signals
-  logic          phase_clear;
-  logic          phase_q;
-  logic          staged_we, shadow_we, committed_we;
-  logic          staged_de, shadow_de, committed_de;
-
-  // Subreg status and data signals
-  logic          committed_qe;
-  logic [DW-1:0] staged_q,  shadow_q,  committed_q;
-  logic [DW-1:0] committed_qs;
-
-  // Effective write enable and write data signals.
-  // These depend on we, de and wd, d, q as well as SwAccess.
-  logic          wr_en;
-  logic [DW-1:0] wr_data;
-
-  prim_subreg_arb #(
-    .DW       ( DW       ),
-    .SwAccess ( SwAccess )
-  ) wr_en_data_arb (
-    .we      ( we      ),
-    .wd      ( wd      ),
-    .de      ( de      ),
-    .d       ( d       ),
-    .q       ( q       ),
-    .wr_en   ( wr_en   ),
-    .wr_data ( wr_data )
-  );
-
-  // Phase clearing:
-  // - SW reads clear phase unless SwAccess is RO.
-  // - In case of RO, SW should not interfere with update process.
-  assign phase_clear = (SwAccess == SwAccessRO) ? 1'b0 : re;
-
-  // Phase tracker:
-  // - Reads from SW clear the phase back to 0.
-  // - Writes have priority (can come from SW or HW).
-  always_ff @(posedge clk_i or negedge rst_ni) begin : phase_reg
-    if (!rst_ni) begin
-      phase_q <= 1'b0;
-    end else if (wr_en && !err_storage) begin
-      phase_q <= ~phase_q;
-    end else if (phase_clear || err_storage) begin
-      phase_q <= 1'b0;
-    end
-  end
-
-  // The staged register:
-  // - Holds the 1's complement value.
-  // - Written in Phase 0.
-  // - Once storage error occurs, do not allow any further update until reset
-  assign staged_we = we & ~phase_q & ~err_storage;
-  assign staged_de = de & ~phase_q & ~err_storage;
-  prim_subreg #(
-    .DW       ( DW             ),
-    .SwAccess ( StagedSwAccess ),
-    .RESVAL   ( ~RESVAL        )
-  ) staged_reg (
-    .clk_i    ( clk_i     ),
-    .rst_ni   ( rst_ni    ),
-    .we       ( staged_we ),
-    .wd       ( ~wr_data  ),
-    .de       ( staged_de ),
-    .d        ( ~d        ),
-    .qe       (           ),
-    .q        ( staged_q  ),
-    .qs       (           )
-  );
-
-  // The shadow register:
-  // - Holds the 1's complement value.
-  // - Written in Phase 1.
-  // - Writes are ignored in case of update errors.
-  // - Gets the value from the staged register.
-  // - Once storage error occurs, do not allow any further update until reset
-  assign shadow_we = we & phase_q & ~err_update & ~err_storage;
-  assign shadow_de = de & phase_q & ~err_update & ~err_storage;
-  prim_subreg #(
-    .DW       ( DW               ),
-    .SwAccess ( InvertedSwAccess ),
-    .RESVAL   ( ~RESVAL          )
-  ) shadow_reg (
-    .clk_i    ( clk_i           ),
-    .rst_ni   ( rst_shadowed_ni ),
-    .we       ( shadow_we       ),
-    .wd       ( staged_q        ),
-    .de       ( shadow_de       ),
-    .d        ( staged_q        ),
-    .qe       (                 ),
-    .q        ( shadow_q        ),
-    .qs       (                 )
-  );
-
-  // The committed register:
-  // - Written in Phase 1.
-  // - Writes are ignored in case of update errors.
-  assign committed_we = shadow_we;
-  assign committed_de = shadow_de;
-  prim_subreg #(
-    .DW       ( DW       ),
-    .SwAccess ( SwAccess ),
-    .RESVAL   ( RESVAL   )
-  ) committed_reg (
-    .clk_i    ( clk_i        ),
-    .rst_ni   ( rst_ni       ),
-    .we       ( committed_we ),
-    .wd       ( wr_data      ),
-    .de       ( committed_de ),
-    .d        ( d            ),
-    .qe       ( committed_qe ),
-    .q        ( committed_q  ),
-    .qs       ( committed_qs )
-  );
-
-  // Output phase for hwext.
-  assign phase = phase_q;
-
-  // Error detection - all bits must match.
-  assign err_update  = (~staged_q != wr_data) ? phase_q & wr_en : 1'b0;
-  assign err_storage = (~shadow_q != committed_q);
-
-  // Remaining output assignments
-  assign qe = committed_qe;
-  assign q  = committed_q;
-  assign qs = committed_qs;
-
-endmodule
diff --git a/prim_subst_perm.sv b/prim_subst_perm.sv
deleted file mode 100644
index e75e3d6f..00000000
--- a/prim_subst_perm.sv
+++ /dev/null
@@ -1,92 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// This is a simple data diffusion primitive that is constructed in a similar fashion
-// as the PRESENT cipher (i.e. it uses a substitution/permutation network). Note however
-// that this is **not** cryptographically secure. The main purpose of this primitive is to
-// provide a cheap diffusion mechanism for arbitrarily sized vectors.
-//
-// See also: prim_prince, prim_present, prim_cipher_pkg
-
-module prim_subst_perm #(
-  parameter int DataWidth = 64,
-  parameter int NumRounds = 31,
-  parameter bit Decrypt   = 0    // 0: encrypt, 1: decrypt
-) (
-  input        [DataWidth-1:0] data_i,
-  input        [DataWidth-1:0] key_i,
-  output logic [DataWidth-1:0] data_o
-);
-
-  //////////////
-  // datapath //
-  //////////////
-
-  // The "split_var" hint that we pass to verilator here tells it to schedule the different parts of
-  // data_state separately. This avoids an UNOPTFLAT error where it would otherwise see a dependency
-  // chain
-  //
-  //    data_state -> data_state_sbox -> data_state
-  //
-  logic [NumRounds:0][DataWidth-1:0] data_state /* verilator split_var */;
-
-  // initialize
-  assign data_state[0] = data_i;
-
-  for (genvar r = 0; r < NumRounds; r++) begin : gen_round
-    logic [DataWidth-1:0] data_state_sbox, data_state_flipped;
-    ////////////////////////////////
-    // decryption pass, performs inverse permutation and sbox
-    if (Decrypt) begin : gen_dec
-      always_comb begin : p_dec
-        data_state_sbox = data_state[r] ^ key_i;
-        // Reverse odd/even grouping
-        data_state_flipped = data_state_sbox;
-        for (int k = 0; k < DataWidth/2; k++) begin
-          data_state_flipped[k * 2]     = data_state_sbox[k];
-          data_state_flipped[k * 2 + 1] = data_state_sbox[k + DataWidth/2];
-        end
-        // Flip vector
-        for (int k = 0; k < DataWidth; k++) begin
-          data_state_sbox[DataWidth - 1 - k] = data_state_flipped[k];
-        end
-        // Inverse SBox layer
-        for (int k = 0; k < DataWidth/4; k++) begin
-          data_state_sbox[k*4 +: 4] = prim_cipher_pkg::PRESENT_SBOX4_INV[data_state_sbox[k*4 +: 4]];
-        end
-        data_state[r + 1] = data_state_sbox;
-      end
-    ////////////////////////////////
-    // encryption pass
-    end else begin : gen_enc
-      always_comb begin : p_enc
-        data_state_sbox = data_state[r] ^ key_i;
-        // This SBox layer is aligned to nibbles, so the uppermost bits may not be affected by this.
-        // However, the permutation below ensures that these bits get shuffled to a different
-        // position when performing multiple rounds.
-        for (int k = 0; k < DataWidth/4; k++) begin
-          data_state_sbox[k*4 +: 4] = prim_cipher_pkg::PRESENT_SBOX4[data_state_sbox[k*4 +: 4]];
-        end
-        // Flip the vector to move the MSB positions into the LSB positions
-        for (int k = 0; k < DataWidth; k++) begin
-          data_state_flipped[DataWidth - 1 - k] = data_state_sbox[k];
-        end
-        // Regroup bits such that all even indices are stacked up first, followed by all odd
-        // indices. Note that if the Width is odd, this is still ok, since
-        // the uppermost bit just stays in place in that case.
-        data_state_sbox = data_state_flipped;
-        for (int k = 0; k < DataWidth/2; k++) begin
-          data_state_sbox[k]               = data_state_flipped[k * 2];
-          data_state_sbox[k + DataWidth/2] = data_state_flipped[k * 2 + 1];
-        end
-        data_state[r + 1] = data_state_sbox;
-      end
-    end // gen_enc
-    ////////////////////////////////
-  end // gen_round
-
-  // finalize
-  assign data_o = data_state[NumRounds] ^ key_i;
-
-endmodule : prim_subst_perm
diff --git a/prim_sum_tree.sv b/prim_sum_tree.sv
deleted file mode 100644
index 1d4559ff..00000000
--- a/prim_sum_tree.sv
+++ /dev/null
@@ -1,119 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Based on prim_max_tree, this module implements an explicit binary tree to find the
-// sum of this inputs. The solution has O(N) area and O(log(N)) delay complexity, and
-// thus scales well with many input sources.
-//
-// Note that only input values marked as "valid" are respected in the maximum computation.
-// Invalid values are treated as 0.
-//
-
-`include "prim_assert.sv"
-
-module prim_sum_tree #(
-  parameter int NumSrc = 32,
-  parameter int Width = 8
-) (
-  // The module is combinational - the clock and reset are only used for assertions.
-  input                         clk_i,
-  input                         rst_ni,
-  input [NumSrc-1:0][Width-1:0] values_i,    // Input values
-  input [NumSrc-1:0]            valid_i,     // Input valid bits
-  output logic [Width-1:0]      sum_value_o, // Summation result
-  output logic                  sum_valid_o  // Whether any of the inputs is valid
-);
-
-  ///////////////////////
-  // Binary tree logic //
-  ///////////////////////
-
-  // This only works with 2 or more sources.
-  `ASSERT_INIT(NumSources_A, NumSrc >= 2)
-
-  // Align to powers of 2 for simplicity.
-  // A full binary tree with N levels has 2**N + 2**N-1 nodes.
-  localparam int NumLevels = $clog2(NumSrc);
-  logic [2**(NumLevels+1)-2:0]               vld_tree;
-  logic [2**(NumLevels+1)-2:0][Width-1:0]    sum_tree;
-
-  for (genvar level = 0; level < NumLevels+1; level++) begin : gen_tree
-    //
-    // level+1   C0   C1   <- "Base1" points to the first node on "level+1",
-    //            \  /         these nodes are the children of the nodes one level below
-    // level       Pa      <- "Base0", points to the first node on "level",
-    //                         these nodes are the parents of the nodes one level above
-    //
-    // hence we have the following indices for the paPa, C0, C1 nodes:
-    // Pa = 2**level     - 1 + offset       = Base0 + offset
-    // C0 = 2**(level+1) - 1 + 2*offset     = Base1 + 2*offset
-    // C1 = 2**(level+1) - 1 + 2*offset + 1 = Base1 + 2*offset + 1
-    //
-    localparam int Base0 = (2**level)-1;
-    localparam int Base1 = (2**(level+1))-1;
-
-    for (genvar offset = 0; offset < 2**level; offset++) begin : gen_level
-      localparam int Pa = Base0 + offset;
-      localparam int C0 = Base1 + 2*offset;
-      localparam int C1 = Base1 + 2*offset + 1;
-
-      // This assigns the input values, their corresponding IDs and valid signals to the tree leafs.
-      if (level == NumLevels) begin : gen_leafs
-        if (offset < NumSrc) begin : gen_assign
-          assign vld_tree[Pa] = valid_i[offset];
-          assign sum_tree[Pa] = values_i[offset];
-        end else begin : gen_tie_off
-          assign vld_tree[Pa] = '0;
-          assign sum_tree[Pa] = '0;
-        end
-      // This creates the node assignments.
-      end else begin : gen_nodes
-        logic [Width-1:0] node_sum; // Local helper variable
-        // In case only one of the parents is valid, forward that one
-        // In case both parents are valid, forward the one with higher value
-        assign node_sum = (vld_tree[C0] & vld_tree[C1]) ? sum_tree[C1] + sum_tree[C0] :
-                          (vld_tree[C0])                ? sum_tree[C0] :
-                          (vld_tree[C1])                ? sum_tree[C1] :
-                          {Width'(0)};
-
-        // Forwarding muxes
-        // Note: these ternaries have triggered a synthesis bug in Vivado versions older
-        // than 2020.2. If the problem resurfaces again, have a look at issue #1408.
-        assign vld_tree[Pa] = vld_tree[C1] | vld_tree[C0];
-        assign sum_tree[Pa] = node_sum;
-      end
-    end : gen_level
-  end : gen_tree
-
-
-  // The results can be found at the tree root
-  assign sum_valid_o = vld_tree[0];
-  assign sum_value_o = sum_tree[0];
-
-  ////////////////
-  // Assertions //
-  ////////////////
-
-`ifdef INC_ASSERT
-  // Helper functions for assertions below.
-  function automatic logic [Width-1:0] sum_value (input logic [NumSrc-1:0][Width-1:0] values_i,
-                                                  input logic [NumSrc-1:0]            valid_i);
-    logic [Width-1:0] sum = '0;
-    for (int k = 0; k < NumSrc; k++) begin
-      if (valid_i[k]) begin
-        sum += values_i[k];
-      end
-    end
-    return sum;
-  endfunction : sum_value
-
-  logic [Width-1:0] sum_value_exp;
-  assign sum_value_exp = sum_value(values_i, valid_i);
-
-  `ASSERT(ValidInImpliesValidOut_A, |valid_i === sum_valid_o)
-  `ASSERT(SumComputation_A, sum_valid_o |-> sum_value_o == sum_value_exp)
-  `ASSERT(SumComputationInvalid_A, !sum_valid_o |-> sum_value_o == '0)
-`endif
-
-endmodule : prim_sum_tree
diff --git a/prim_sync_reqack.sv b/prim_sync_reqack.sv
deleted file mode 100644
index b2d036ae..00000000
--- a/prim_sync_reqack.sv
+++ /dev/null
@@ -1,180 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// REQ/ACK synchronizer
-//
-// This module synchronizes a REQ/ACK handshake across a clock domain crossing.
-// Both domains will see a handshake with the duration of one clock cycle.
-//
-// Notes:
-// - Once asserted, the source (SRC) domain is not allowed to de-assert REQ without ACK.
-// - The destination (DST) domain is not allowed to send an ACK without a REQ.
-// - This module works both when syncing from a faster to a slower clock domain and vice versa.
-// - Internally, this module uses a non-return-to-zero, two-phase handshake protocol. Assuming the
-//   DST domain responds with an ACK immediately, the latency from asserting the REQ in the
-//   SRC domain is:
-//   - 1 source + 2 destination clock cycles until the handshake is performed in the DST domain,
-//   - 1 source + 2 destination + 1 destination + 2 source clock cycles until the handshake is
-//     performed in the SRC domain.
-//
-// For further information, see Section 8.2.4 in H. Kaeslin, "Top-Down Digital VLSI Design: From
-// Architecture to Gate-Level Circuits and FPGAs", 2015.
-
-`include "prim_assert.sv"
-
-module prim_sync_reqack (
-  input  clk_src_i,       // REQ side, SRC domain
-  input  rst_src_ni,      // REQ side, SRC domain
-  input  clk_dst_i,       // ACK side, DST domain
-  input  rst_dst_ni,      // ACK side, DST domain
-
-  input  logic req_chk_i, // Used for gating assertions. Drive to 1 during normal operation.
-
-  input  logic src_req_i, // REQ side, SRC domain
-  output logic src_ack_o, // REQ side, SRC domain
-  output logic dst_req_o, // ACK side, DST domain
-  input  logic dst_ack_i  // ACK side, DST domain
-);
-
-  // req_chk_i is used for gating assertions only.
-  logic unused_req_chk;
-  assign unused_req_chk = req_chk_i;
-
-  // Types
-  typedef enum logic {
-    EVEN, ODD
-  } sync_reqack_fsm_e;
-
-  // Signals
-  sync_reqack_fsm_e src_fsm_ns, src_fsm_cs;
-  sync_reqack_fsm_e dst_fsm_ns, dst_fsm_cs;
-  logic src_req_d, src_req_q, src_ack;
-  logic dst_ack_d, dst_ack_q, dst_req;
-  logic src_handshake, dst_handshake;
-
-  assign src_handshake = src_req_i & src_ack_o;
-  assign dst_handshake = dst_req_o & dst_ack_i;
-
-  // Move REQ over to DST domain.
-  prim_flop_2sync #(
-    .Width(1)
-  ) req_sync (
-    .clk_i  (clk_dst_i),
-    .rst_ni (rst_dst_ni),
-    .d_i    (src_req_q),
-    .q_o    (dst_req)
-  );
-
-  // Move ACK over to SRC domain.
-  prim_flop_2sync #(
-    .Width(1)
-  ) ack_sync (
-    .clk_i  (clk_src_i),
-    .rst_ni (rst_src_ni),
-    .d_i    (dst_ack_q),
-    .q_o    (src_ack)
-  );
-
-  // REQ-side FSM (SRC domain)
-  always_comb begin : src_fsm
-    src_fsm_ns = src_fsm_cs;
-
-    // By default, we keep the internal REQ value and don't ACK.
-    src_req_d = src_req_q;
-    src_ack_o = 1'b0;
-
-    unique case (src_fsm_cs)
-
-      EVEN: begin
-        // Simply forward REQ and ACK.
-        src_req_d = src_req_i;
-        src_ack_o = src_ack;
-
-        // The handshake is done for exactly 1 clock cycle.
-        if (src_handshake) begin
-          src_fsm_ns = ODD;
-        end
-      end
-
-      ODD: begin
-        // Internal REQ and ACK have inverted meaning now. If src_req_i is high again, this signals
-        // a new transaction.
-        src_req_d = ~src_req_i;
-        src_ack_o = ~src_ack;
-
-        // The handshake is done for exactly 1 clock cycle.
-        if (src_handshake) begin
-          src_fsm_ns = EVEN;
-        end
-      end
-
-      default: ;
-    endcase
-  end
-
-  // ACK-side FSM (DST domain)
-  always_comb begin : dst_fsm
-    dst_fsm_ns = dst_fsm_cs;
-
-    // By default, we don't REQ and keep the internal ACK.
-    dst_req_o = 1'b0;
-    dst_ack_d = dst_ack_q;
-
-    unique case (dst_fsm_cs)
-
-      EVEN: begin
-        // Simply forward REQ and ACK.
-        dst_req_o = dst_req;
-        dst_ack_d = dst_ack_i;
-
-        // The handshake is done for exactly 1 clock cycle.
-        if (dst_handshake) begin
-          dst_fsm_ns = ODD;
-        end
-      end
-
-      ODD: begin
-        // Internal REQ and ACK have inverted meaning now. If dst_req goes low, this signals a new
-        // transaction.
-        dst_req_o = ~dst_req;
-        dst_ack_d = ~dst_ack_i;
-
-        // The handshake is done for exactly 1 clock cycle.
-        if (dst_handshake) begin
-          dst_fsm_ns = EVEN;
-        end
-      end
-
-      default: ;
-    endcase
-  end
-
-  // Registers
-  always_ff @(posedge clk_src_i or negedge rst_src_ni) begin
-    if (!rst_src_ni) begin
-      src_fsm_cs <= EVEN;
-      src_req_q  <= 1'b0;
-    end else begin
-      src_fsm_cs <= src_fsm_ns;
-      src_req_q  <= src_req_d;
-    end
-  end
-  always_ff @(posedge clk_dst_i or negedge rst_dst_ni) begin
-    if (!rst_dst_ni) begin
-      dst_fsm_cs <= EVEN;
-      dst_ack_q  <= 1'b0;
-    end else begin
-      dst_fsm_cs <= dst_fsm_ns;
-      dst_ack_q  <= dst_ack_d;
-    end
-  end
-
-  // SRC domain can only de-assert REQ after receiving ACK.
-  `ASSERT(SyncReqAckHoldReq, $fell(src_req_i) |->
-      $fell(src_ack_o), clk_src_i, !rst_src_ni || !req_chk_i)
-
-  // DST domain cannot assert ACK without REQ.
-  `ASSERT(SyncReqAckAckNeedsReq, dst_ack_i |-> dst_req_o, clk_dst_i, !rst_dst_ni)
-
-endmodule
diff --git a/prim_sync_reqack_data.sv b/prim_sync_reqack_data.sv
deleted file mode 100644
index 840d86d8..00000000
--- a/prim_sync_reqack_data.sv
+++ /dev/null
@@ -1,130 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// REQ/ACK synchronizer with associated data.
-//
-// This module synchronizes a REQ/ACK handshake with associated data across a clock domain
-// crossing (CDC). Both domains will see a handshake with the duration of one clock cycle. By
-// default, the data itself is not registered. The main purpose of feeding the data through this
-// module to have an anchor point for waiving CDC violations. If the data is configured to flow
-// from the destination (DST) to the source (SRC) domain, an additional register stage can be
-// inserted for data buffering.
-//
-// Under the hood, this module uses a prim_sync_reqack primitive for synchronizing the
-// REQ/ACK handshake. See prim_sync_reqack.sv for more details.
-
-`include "prim_assert.sv"
-
-module prim_sync_reqack_data #(
-  parameter int unsigned Width       = 1,
-  parameter bit          DataSrc2Dst = 1'b1, // Direction of data flow: 1'b1 = SRC to DST,
-                                             //                         1'b0 = DST to SRC
-  parameter bit          DataReg     = 1'b0  // Enable optional register stage for data,
-                                             // only usable with DataSrc2Dst == 1'b0.
-) (
-  input  clk_src_i,       // REQ side, SRC domain
-  input  rst_src_ni,      // REQ side, SRC domain
-  input  clk_dst_i,       // ACK side, DST domain
-  input  rst_dst_ni,      // ACK side, DST domain
-
-  input  logic req_chk_i, // Used for gating assertions. Drive to 1 during normal operation.
-
-  input  logic src_req_i, // REQ side, SRC domain
-  output logic src_ack_o, // REQ side, SRC domain
-  output logic dst_req_o, // ACK side, DST domain
-  input  logic dst_ack_i, // ACK side, DST domain
-
-  input  logic [Width-1:0] data_i,
-  output logic [Width-1:0] data_o
-);
-
-  ////////////////////////////////////
-  // REQ/ACK synchronizer primitive //
-  ////////////////////////////////////
-  prim_sync_reqack u_prim_sync_reqack (
-    .clk_src_i,
-    .rst_src_ni,
-    .clk_dst_i,
-    .rst_dst_ni,
-
-    .req_chk_i,
-
-    .src_req_i,
-    .src_ack_o,
-    .dst_req_o,
-    .dst_ack_i
-  );
-
-  /////////////////////////
-  // Data register stage //
-  /////////////////////////
-  // Optional - Only relevant if the data flows from DST to SRC. In this case, it must be ensured
-  // that the data remains stable until the ACK becomes visible in the SRC domain.
-  //
-  // Note that for larger data widths, it is recommended to adjust the data sender to hold the data
-  // stable until the next REQ in order to save the cost of this register stage.
-  if (DataSrc2Dst == 1'b0 && DataReg == 1'b1) begin : gen_data_reg
-    logic             data_we;
-    logic [Width-1:0] data_d, data_q;
-
-    // Sample the data when seing the REQ/ACK handshake in the DST domain.
-    assign data_we = dst_req_o & dst_ack_i;
-    assign data_d  = data_i;
-    always_ff @(posedge clk_dst_i or negedge rst_dst_ni) begin
-      if (!rst_dst_ni) begin
-        data_q <= '0;
-      end else if (data_we) begin
-        data_q <= data_d;
-      end
-    end
-    assign data_o = data_q;
-
-  end else begin : gen_no_data_reg
-    // Just feed through the data.
-    assign data_o = data_i;
-  end
-
-  ////////////////
-  // Assertions //
-  ////////////////
-  if (DataSrc2Dst == 1'b1) begin : gen_assert_data_src2dst
-    // SRC domain cannot change data while waiting for ACK.
-    `ASSERT(SyncReqAckDataHoldSrc2Dst, !$stable(data_i) |->
-        (!src_req_i || (src_req_i && src_ack_o)),
-        clk_src_i, !rst_src_ni)
-
-    // Register stage cannot be used.
-    `ASSERT_INIT(SyncReqAckDataReg, DataSrc2Dst && !DataReg)
-
-  end else if (DataSrc2Dst == 1'b0 && DataReg == 1'b0) begin : gen_assert_data_dst2src
-    // DST domain shall not change data while waiting for SRC domain to latch it (together with
-    // receiving ACK). It takes 2 SRC cycles for ACK to cross over from DST to SRC, and 1 SRC cycle
-    // for the next REQ to cross over from SRC to DST.
-    //
-    // Denote the src clock where REQ & ACK as time zero. The data flowing through the CDC could be
-    // corrupted if data_o was not stable over the previous 2 clock cycles (so we want to check time
-    // points -2, -1 and 0). Moreover, the DST domain cannot know that it is allowed to change value
-    // until at least one more SRC cycle (the time taken for REQ to cross back from SRC to DST).
-    //
-    // To make this assertion, we will sample at each of 4 time points (-2, -1, 0 and +1), asserting
-    // that data_o is equal at each of these times. Note this won't detect glitches at intermediate
-    // timepoints.
-    //
-    // The SVAs below are designed not to consume time, which means that they can be disabled with
-    // an $assertoff(..) and won't linger to fail later. This wouldn't work properly if we used
-    // something like |=> instead of the $past(...) function. That means that we have to trigger at
-    // the "end" of the window. To make sure we don't miss a situation where the value changed at
-    // time -1 (causing corruption), but reset was asserted between time 0 and 1, we split the
-    // assertion into two pieces. The first (SyncReqAckDataHoldDst2SrcA) checks that data doesn't
-    // change in a way that could cause data corruption. The second (SyncReqAckDataHoldDst2SrcB)
-    // checks that the DST side doesn't do anything that it shouldn't know is safe.
-    `ASSERT(SyncReqAckDataHoldDst2SrcA,
-            src_req_i && src_ack_o |-> $past(data_o, 2) == data_o && $past(data_o) == data_o,
-            clk_src_i, !rst_src_ni)
-    `ASSERT(SyncReqAckDataHoldDst2SrcB,
-            $past(src_req_i && src_ack_o) |-> $past(data_o) == data_o,
-            clk_src_i, !rst_src_ni)
-  end
-
-endmodule
diff --git a/prim_sync_slow_fast.sv b/prim_sync_slow_fast.sv
deleted file mode 100644
index 8bffa1d5..00000000
--- a/prim_sync_slow_fast.sv
+++ /dev/null
@@ -1,59 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// Slow to fast clock synchronizer
-// This module is designed to be used for efficient sampling of signals from a slow clock to a much
-// faster clock.
-//
-// The data is captured into flops on the negative edge of the slow clock (when the data should be
-// stable). Because the slow clock passes through a two-flop synchronizer, the ratio of clock speeds
-// needs to be high to guarantee that the data will be stable when sampled.
-//
-// A ratio of at-least 10:1 in clock speeds is recommended.
-
-module prim_sync_slow_fast #(
-  parameter int unsigned Width = 32
-) (
-  input  logic             clk_slow_i,
-  input  logic             clk_fast_i,
-  input  logic             rst_fast_ni,
-  input  logic [Width-1:0] wdata_i,    // Slow domain
-  output logic [Width-1:0] rdata_o     // Fast domain
-);
-
-  logic             sync_clk_slow, sync_clk_slow_q;
-  logic             wdata_en;
-  logic [Width-1:0] wdata_q;
-
-  // Synchronize the slow clock to the fast domain
-  prim_flop_2sync #(.Width(1)) sync_slow_clk (
-    .clk_i    (clk_fast_i),
-    .rst_ni   (rst_fast_ni),
-    .d_i      (clk_slow_i),
-    .q_o      (sync_clk_slow));
-
-  // Register the synchronized clk
-  always_ff @(posedge clk_fast_i or negedge rst_fast_ni) begin
-    if (!rst_fast_ni) begin
-      sync_clk_slow_q <= 1'b0;
-    end else begin
-      sync_clk_slow_q <= sync_clk_slow;
-    end
-  end
-
-  // Find the negative edge of the synchronized slow clk
-  assign wdata_en = sync_clk_slow_q & !sync_clk_slow;
-
-  // Sample the slow data on the negative edge
-  always_ff @(posedge clk_fast_i or negedge rst_fast_ni) begin
-    if (!rst_fast_ni) begin
-      wdata_q <= '0;
-    end else if (wdata_en) begin
-      wdata_q <= wdata_i;
-    end
-  end
-
-  assign rdata_o = wdata_q;
-
-endmodule
diff --git a/prim_util_get_scramble_params.svh b/prim_util_get_scramble_params.svh
deleted file mode 100644
index d9efc28e..00000000
--- a/prim_util_get_scramble_params.svh
+++ /dev/null
@@ -1,36 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-
-`ifndef SYNTHESIS
-  export "DPI-C" function simutil_get_scramble_key;
-
-  function int simutil_get_scramble_key(output bit [127:0] val);
-    if (!key_valid_i) begin
-      return 0;
-    end
-
-    if (DataKeyWidth != 128) begin
-      return 0;
-    end
-
-    val = key_i;
-    return 1;
-  endfunction
-
-  export "DPI-C" function simutil_get_scramble_nonce;
-
-  function int simutil_get_scramble_nonce(output bit [319:0] nonce);
-    if (!key_valid_i) begin
-      return 0;
-    end
-
-    if (NonceWidth > 320) begin
-      return 0;
-    end
-
-    nonce = '0;
-    nonce[NonceWidth-1:0] = nonce_i;
-    return 1;
-  endfunction
-`endif
diff --git a/prim_util_memload.svh b/prim_util_memload.svh
deleted file mode 100644
index 8d56cab9..00000000
--- a/prim_util_memload.svh
+++ /dev/null
@@ -1,82 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-
-/**
- * Memory loader for simulation
- *
- * Include this file in a memory primitive to load a memory array from
- * simulation.
- *
- * Requirements:
- * - A memory array named `mem`.
- * - A parameter `Width` giving the memory width (word size) in bit.
- * - A parameter `Depth` giving the memory depth in words.
- * - A parameter `MemInitFile` with a file path of a VMEM file to be loaded into
- *   the memory if not empty.
- *
- * Note this works with memories up to a maximum width of 312 bits. Should this maximum width be
- * increased all of the `simutil_set_mem` and `simutil_get_mem` call sites must be found (e.g. using
- * git grep) and adjusted appropriately.
- */
-
-`ifndef SYNTHESIS
-  // Task for loading 'mem' with SystemVerilog system task $readmemh()
-  export "DPI-C" task simutil_memload;
-
-  task simutil_memload;
-    input string file;
-    $readmemh(file, mem);
-  endtask
-
-  // Function for setting a specific element in |mem|
-  // Returns 1 (true) for success, 0 (false) for errors.
-  export "DPI-C" function simutil_set_mem;
-
-  function int simutil_set_mem(input int index, input bit [311:0] val);
-
-    // Function will only work for memories <= 312 bits
-    if (Width > 312) begin
-      return 0;
-    end
-
-    if (index >= Depth) begin
-      return 0;
-    end
-
-    mem[index] = val[Width-1:0];
-    return 1;
-  endfunction
-
-  // Function for getting a specific element in |mem|
-  export "DPI-C" function simutil_get_mem;
-
-  function int simutil_get_mem(input int index, output bit [311:0] val);
-
-    // Function will only work for memories <= 312 bits
-    if (Width > 312) begin
-      return 0;
-    end
-
-    if (index >= Depth) begin
-      return 0;
-    end
-
-    val = 0;
-    val[Width-1:0] = mem[index];
-    return 1;
-  endfunction
-`endif
-
-initial begin
-  logic show_mem_paths;
-
-  // Print the hierarchical path to the memory to help make formal connectivity checks easy.
-  void'($value$plusargs("show_mem_paths=%0b", show_mem_paths));
-  if (show_mem_paths) $display("%m");
-
-  if (MemInitFile != "") begin : gen_meminit
-      $display("Initializing memory %m from file '%s'.", MemInitFile);
-      $readmemh(MemInitFile, mem);
-  end
-end
diff --git a/prim_util_pkg.sv b/prim_util_pkg.sv
deleted file mode 100644
index 36960c65..00000000
--- a/prim_util_pkg.sv
+++ /dev/null
@@ -1,89 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-
-
-/**
- * Utility functions
- */
-package prim_util_pkg;
-  /**
-   * Math function: $clog2 as specified in Verilog-2005
-   *
-   * Do not use this function if $clog2() is available.
-   *
-   * clog2 =          0        for value == 0
-   *         ceil(log2(value)) for value >= 1
-   *
-   * This implementation is a synthesizable variant of the $clog2 function as
-   * specified in the Verilog-2005 standard (IEEE 1364-2005).
-   *
-   * To quote the standard:
-   *   The system function $clog2 shall return the ceiling of the log
-   *   base 2 of the argument (the log rounded up to an integer
-   *   value). The argument can be an integer or an arbitrary sized
-   *   vector value. The argument shall be treated as an unsigned
-   *   value, and an argument value of 0 shall produce a result of 0.
-   */
-  function automatic integer _clog2(integer value);
-    integer result;
-    // Use an intermediate value to avoid assigning to an input port, which produces a warning in
-    // Synopsys DC.
-    integer v = value;
-    v = v - 1;
-    for (result = 0; v > 0; result++) begin
-      v = v >> 1;
-    end
-    return result;
-  endfunction
-
-
-  /**
-   * Math function: Number of bits needed to address |value| items.
-   *
-   *                  0        for value == 0
-   * vbits =          1        for value == 1
-   *         ceil(log2(value)) for value > 1
-   *
-   *
-   * The primary use case for this function is the definition of registers/arrays
-   * which are wide enough to contain |value| items.
-   *
-   * This function identical to $clog2() for all input values except the value 1;
-   * it could be considered an "enhanced" $clog2() function.
-   *
-   *
-   * Example 1:
-   *   parameter Items = 1;
-   *   localparam ItemsWidth = vbits(Items); // 1
-   *   logic [ItemsWidth-1:0] item_register; // items_register is now [0:0]
-   *
-   * Example 2:
-   *   parameter Items = 64;
-   *   localparam ItemsWidth = vbits(Items); // 6
-   *   logic [ItemsWidth-1:0] item_register; // items_register is now [5:0]
-   *
-   * Note: If you want to store the number "value" inside a register, you need
-   * a register with size vbits(value + 1), since you also need to store
-   * the number 0.
-   *
-   * Example 3:
-   *   logic [vbits(64)-1:0]     store_64_logic_values; // width is [5:0]
-   *   logic [vbits(64 + 1)-1:0] store_number_64;       // width is [6:0]
-   */
-  function automatic integer vbits(integer value);
-`ifdef XCELIUM
-    // The use of system functions was not allowed here in Verilog-2001, but is
-    // valid since (System)Verilog-2005, which is also when $clog2() first
-    // appeared.
-    // Xcelium < 19.10 does not yet support the use of $clog2() here, fall back
-    // to an implementation without a system function. Remove this workaround
-    // if we require a newer Xcelium version.
-    // See #2579 and #2597.
-    return (value == 1) ? 1 : _clog2(value);
-`else
-    return (value == 1) ? 1 : $clog2(value);
-`endif
-  endfunction
-
-endpackage
diff --git a/prim_xoshiro256pp.sv b/prim_xoshiro256pp.sv
deleted file mode 100644
index 39307e5a..00000000
--- a/prim_xoshiro256pp.sv
+++ /dev/null
@@ -1,87 +0,0 @@
-// Copyright lowRISC contributors.
-// Licensed under the Apache License, Version 2.0, see LICENSE for details.
-// SPDX-License-Identifier: Apache-2.0
-//
-// This module implements XoShiRo256++ PRNG
-//
-// Additional Entropy input to XOR fresh entropy into the state.
-// Lockup protection that reseeds the generator if it falls into the all-zero state.
-//
-// Refs: [1] D. Blackman and S. Vigna, Scrambled Linear Pseudorndom Number Generators
-//           https://arxiv.org/pdf/1805.01407.pdf
-//       [2] https://prng.di.unimi.it/
-//       [3] https://en.wikipedia.org/wiki/Xorshift#xoshiro_and_xoroshiro
-
-`include "prim_assert.sv"
-
-module prim_xoshiro256pp #(
-  // Output width, must be a multiple of 64
-  parameter int unsigned       OutputDw       = 64,
-  // PRNG reset state, must be nonzero!
-  parameter logic [255:0]      DefaultSeed    = 256'(1'b1),
-
-  parameter int unsigned NumStages = OutputDw / 64 // derived parameter
-) (
-  input  logic                  clk_i,
-  input  logic                  rst_ni,
-  input  logic                  seed_en_i,    // load external seed into the state
-  input  logic [255:0]          seed_i,       // external seed input
-  input  logic                  xoshiro_en_i, // enables the PRNG
-  input  logic [255:0]          entropy_i,    // additional entropy to be XOR'ed into the state
-  output logic [OutputDw-1:0]   data_o,       // PRNG output
-  output logic                  all_zero_o   // alert signal indicates the all-zero state
-);
-
-  logic [255:0] unrolled_state [NumStages+1];
-  logic [63:0] mid [NumStages];
-
-  logic lockup;
-  logic [255:0] xoshiro_d, xoshiro_q, next_xoshiro_state;
-
-  function automatic logic [255:0] state_update (input logic [255:0] data_in);
-    logic [63:0] a_in, b_in, c_in, d_in;
-    logic [63:0] a_out, b_out, c_out, d_out;
-    a_in = data_in[255:192];
-    b_in = data_in[191:128];
-    c_in = data_in[127:64];
-    d_in = data_in[63:0];
-    a_out = a_in ^ b_in ^ d_in;
-    b_out = a_in ^ b_in ^ c_in;
-    c_out = a_in ^ (b_in << 17) ^ c_in;
-    d_out = {d_in[18:0], d_in[63:19]} ^ {b_in[18:0], b_in[63:19]};
-    return {a_out, b_out, c_out, d_out};
-  endfunction: state_update
-
-  assign unrolled_state[0] = xoshiro_q;
-
-  for (genvar k = 0; k < NumStages; k++) begin : gen_state_functions
-    // State update function
-    assign unrolled_state[k+1] = state_update(unrolled_state[k]);
-    // State output function
-    assign mid[k] = unrolled_state[k][255:192] + unrolled_state[k][63:0];
-    assign data_o[(k+1)*64-1:k*64] = {mid[k][40:0], mid[k][63:41]} + unrolled_state[k][255:192];
-  end
-
-  assign next_xoshiro_state = entropy_i ^ unrolled_state[NumStages];
-  assign xoshiro_d = (seed_en_i)              ? seed_i             :
-                     (xoshiro_en_i && lockup) ? DefaultSeed        :
-                     (xoshiro_en_i)           ? next_xoshiro_state : xoshiro_q;
-
-  always_ff @(posedge clk_i or negedge rst_ni) begin : reg_state
-    if (!rst_ni) begin
-      xoshiro_q <= DefaultSeed;
-    end else begin
-      xoshiro_q <= xoshiro_d;
-    end
-  end
-
-  // lockup condition is all-zero
-  assign lockup = ~(|xoshiro_q);
-
-  // Indicate that the state is all zeros.
-  assign all_zero_o = lockup;
-
-  // check that seed is not all-zero
-  `ASSERT_INIT(DefaultSeedNzCheck_A, |DefaultSeed)
-
-endmodule
-- 
2.34.1

