/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : tmrg_files/gpioTMR.sv                                                                  *
 *                                                                                                  *
 * user    : michaero                                                                               *
 * host    : camellia.ee.ethz.ch                                                                    *
 * date    : 22/08/2025 20:09:47                                                                    *
 *                                                                                                  *
 * workdir : /scratch/michaero/git/croc/rtl/gpio                                                    *
 * cmd     : /home/michaero/.local/bin/tmrg tmrg_src/sync.sv gpio_reg_top.sv gpio.sv --top-module=gpio *
 *           --tmr-dir=tmrg_files                                                                   *
 * tmrg rev: 7e2935137fada05d9957c7acbad06f9f466f5f7e                                               *
 *                                                                                                  *
 * src file: gpio.sv                                                                                *
 *           Git SHA           : c45c846f2648ab3f2bc44d19725c4e0e745d558f (MM gpio.sv)              *
 *           Modification time : 2025-08-22 20:09:45.569042                                         *
 *           File Size         : 6840                                                               *
 *           MD5 hash          : cfe415003fff4d95ab110f2a8c5bc67a                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module gpioTMR #(
  parameter obi_pkg::obi_cfg_t ObiCfg = obi_pkg::ObiDefaultConfig,
  parameter type obi_req_t         = logic,
  parameter type obi_rsp_t         = logic,
  parameter int NrSyncStages = 2,
  parameter int unsigned GpioCount = 16
) (
  input logic clk_i,
  input logic rst_ni,
  input logic [GpioCount - 1:0] gpio_i,
  output logic [GpioCount - 1:0] gpio_o,
  output logic [GpioCount - 1:0] gpio_out_en_o,
  output logic [GpioCount - 1:0] gpio_in_sync_oA,
  output logic [GpioCount - 1:0] gpio_in_sync_oB,
  output logic [GpioCount - 1:0] gpio_in_sync_oC,
  output logic interrupt_oA,
  output logic interrupt_oB,
  output logic interrupt_oC,
  input obi_req_t obi_req_iA,
  input obi_req_t obi_req_iB,
  input obi_req_t obi_req_iC,
  output obi_rsp_t obi_rsp_oA,
  output obi_rsp_t obi_rsp_oB,
  output obi_rsp_t obi_rsp_oC,
  output tmrError,
  output tmrErrorA,
  output tmrErrorB,
  output tmrErrorC
);
import gpio_reg_pkg::*;
wire rst_niC;
wire rst_niB;
wire rst_niA;
wire [ (GpioCount-1) :0] gpio_iC;
wire [ (GpioCount-1) :0] gpio_iB;
wire [ (GpioCount-1) :0] gpio_iA;
wire clk_iC;
wire clk_iB;
wire clk_iA;
wor serial_qTmrErrorC;
wor i_synctmrErrorC;
wor i_reg_filetmrErrorC;
wor serial_qTmrErrorB;
wor i_synctmrErrorB;
wor i_reg_filetmrErrorB;
wor serial_qTmrErrorA;
wor i_synctmrErrorA;
wor i_reg_filetmrErrorA;
wor reg2hwTmrError;
wor is_outputTmrError;
wire gpio_reg2hw_t [ (GpioCount-1) :0] reg2hw;
wire [ (GpioCount-1) :0] is_output;
gpio_reg2hw_t [GpioCount - 1:0] reg2hwA;
gpio_reg2hw_t [GpioCount - 1:0] reg2hwB;
gpio_reg2hw_t [GpioCount - 1:0] reg2hwC;
gpio_hw2reg_t [GpioCount - 1:0] hw2regA;
gpio_hw2reg_t [GpioCount - 1:0] hw2regB;
gpio_hw2reg_t [GpioCount - 1:0] hw2regC;
logic [GpioCount - 1:0] gpio_in_syncA;
logic [GpioCount - 1:0] gpio_in_syncB;
logic [GpioCount - 1:0] gpio_in_syncC;
logic [GpioCount - 1:0] gpio_edgeA;
logic [GpioCount - 1:0] gpio_edgeB;
logic [GpioCount - 1:0] gpio_edgeC;
logic [GpioCount - 1:0] gpio_intrptA;
logic [GpioCount - 1:0] gpio_intrptB;
logic [GpioCount - 1:0] gpio_intrptC;
logic gpio_intrpt_pendingA;
logic gpio_intrpt_pendingB;
logic gpio_intrpt_pendingC;

gpio_reg_topTMR #(.obi_req_t(obi_req_t), .obi_rsp_t(obi_rsp_t), .GpioCount(GpioCount)) i_reg_file (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .obi_req_iA(obi_req_iA),
    .obi_req_iB(obi_req_iB),
    .obi_req_iC(obi_req_iC),
    .obi_rsp_oA(obi_rsp_oA),
    .obi_rsp_oB(obi_rsp_oB),
    .obi_rsp_oC(obi_rsp_oC),
    .reg2hwA(reg2hwA),
    .reg2hwB(reg2hwB),
    .reg2hwC(reg2hwC),
    .hw2regA(hw2regA),
    .hw2regB(hw2regB),
    .hw2regC(hw2regC),
    .tmrErrorA(i_reg_filetmrErrorA),
    .tmrErrorB(i_reg_filetmrErrorB),
    .tmrErrorC(i_reg_filetmrErrorC)
  );
assign gpio_in_sync_oA = gpio_in_syncA;
assign gpio_in_sync_oB = gpio_in_syncB;
assign gpio_in_sync_oC = gpio_in_syncC;
logic [GpioCount - 1:0] serial_dA;
logic [GpioCount - 1:0] serial_dB;
logic [GpioCount - 1:0] serial_dC;
logic [GpioCount - 1:0] serial_qA;
logic [GpioCount - 1:0] serial_qB;
logic [GpioCount - 1:0] serial_qC;
logic [GpioCount - 1:0] serial_qVotedA;
logic [GpioCount - 1:0] serial_qVotedB;
logic [GpioCount - 1:0] serial_qVotedC;
logic [GpioCount - 1:0] is_inputA;
logic [GpioCount - 1:0] is_inputB;
logic [GpioCount - 1:0] is_inputC;
logic [GpioCount - 1:0] is_outputA;
logic [GpioCount - 1:0] is_outputB;
logic [GpioCount - 1:0] is_outputC;
for(genvar idx = 0; idx<GpioCount; idx++)
  begin : gen_gpios
logic f_edgeA;
logic f_edgeB;
logic f_edgeC;
logic r_edgeA;
logic r_edgeB;
logic r_edgeC;

    syncTMR #(.STAGES(NrSyncStages)) i_sync (
        .clk_i(clk_i),
        .rst_ni(rst_ni),
        .serial_iA(gpio_iA[idx]),
        .serial_iB(gpio_iB[idx]),
        .serial_iC(gpio_iC[idx]),
        .serial_oA(serial_dA[idx]),
        .serial_oB(serial_dB[idx]),
        .serial_oC(serial_dC[idx]),
        .tmrErrorA(i_synctmrErrorA),
        .tmrErrorB(i_synctmrErrorB),
        .tmrErrorC(i_synctmrErrorC)
      );

    always_ff @( posedge clk_iA or negedge rst_niA )
      begin
        if (!rst_niA)
          begin
            serial_qA[idx] <= '0;
          end
        else
          begin
            serial_qA[idx] <= serial_dA[idx];
          end
      end

    always_ff @( posedge clk_iB or negedge rst_niB )
      begin
        if (!rst_niB)
          begin
            serial_qB[idx] <= '0;
          end
        else
          begin
            serial_qB[idx] <= serial_dB[idx];
          end
      end

    always_ff @( posedge clk_iC or negedge rst_niC )
      begin
        if (!rst_niC)
          begin
            serial_qC[idx] <= '0;
          end
        else
          begin
            serial_qC[idx] <= serial_dC[idx];
          end
      end
    assign f_edgeA =  (~ serial_dA[idx] ) &serial_qVotedA[idx];
    assign f_edgeB =  (~ serial_dB[idx] ) &serial_qVotedB[idx];
    assign f_edgeC =  (~ serial_dC[idx] ) &serial_qVotedC[idx];
    assign r_edgeA = serial_dA[idx]& (~ serial_qVotedA[idx] ) ;
    assign r_edgeB = serial_dB[idx]& (~ serial_qVotedB[idx] ) ;
    assign r_edgeC = serial_dC[idx]& (~ serial_qVotedC[idx] ) ;
    assign gpio_edgeA[idx] = reg2hwA[idx].intrpt_edge ? r_edgeA : f_edgeA;
    assign gpio_edgeB[idx] = reg2hwB[idx].intrpt_edge ? r_edgeB : f_edgeB;
    assign gpio_edgeC[idx] = reg2hwC[idx].intrpt_edge ? r_edgeC : f_edgeC;
    assign gpio_in_syncA[idx] = serial_qVotedA[idx];
    assign gpio_in_syncB[idx] = serial_qVotedB[idx];
    assign gpio_in_syncC[idx] = serial_qVotedC[idx];
    assign is_inputA[idx] = reg2hwA[idx].en&~reg2hwA[idx].dir;
    assign is_inputB[idx] = reg2hwB[idx].en&~reg2hwB[idx].dir;
    assign is_inputC[idx] = reg2hwC[idx].en&~reg2hwC[idx].dir;
    assign is_outputA[idx] = reg2hwA[idx].en&reg2hwA[idx].dir;
    assign is_outputB[idx] = reg2hwB[idx].en&reg2hwB[idx].dir;
    assign is_outputC[idx] = reg2hwC[idx].en&reg2hwC[idx].dir;
    assign hw2regA[idx].sync_in = gpio_in_syncA[idx]&is_inputA[idx];
    assign hw2regB[idx].sync_in = gpio_in_syncB[idx]&is_inputB[idx];
    assign hw2regC[idx].sync_in = gpio_in_syncC[idx]&is_inputC[idx];
    assign gpio_o[idx] = reg2hw[idx].out&is_output[idx];
    assign gpio_out_en_o[idx] = is_output[idx];

    always_comb
      begin
        hw2regA[idx].out = '0;
        hw2regA[idx].out_valid = '0;
        if (is_outputA[idx]&reg2hwA[idx].toggle)
          begin
            hw2regA[idx].out = ~reg2hwA[idx].out;
            hw2regA[idx].out_valid = 1'b1;
          end

      end

    always_comb
      begin
        hw2regB[idx].out = '0;
        hw2regB[idx].out_valid = '0;
        if (is_outputB[idx]&reg2hwB[idx].toggle)
          begin
            hw2regB[idx].out = ~reg2hwB[idx].out;
            hw2regB[idx].out_valid = 1'b1;
          end

      end

    always_comb
      begin
        hw2regC[idx].out = '0;
        hw2regC[idx].out_valid = '0;
        if (is_outputC[idx]&reg2hwC[idx].toggle)
          begin
            hw2regC[idx].out = ~reg2hwC[idx].out;
            hw2regC[idx].out_valid = 1'b1;
          end

      end
    assign gpio_intrptA[idx] = gpio_edgeA[idx]&reg2hwA[idx].intrpt_en&is_inputA[idx];
    assign gpio_intrptB[idx] = gpio_edgeB[idx]&reg2hwB[idx].intrpt_en&is_inputB[idx];
    assign gpio_intrptC[idx] = gpio_edgeC[idx]&reg2hwC[idx].intrpt_en&is_inputC[idx];
    assign hw2regA[idx].intrpt = gpio_intrptA[idx];
    assign hw2regB[idx].intrpt = gpio_intrptB[idx];
    assign hw2regC[idx].intrpt = gpio_intrptC[idx];
    assign hw2regA[idx].intrpt_valid = gpio_intrptA[idx];
    assign hw2regB[idx].intrpt_valid = gpio_intrptB[idx];
    assign hw2regC[idx].intrpt_valid = gpio_intrptC[idx];
  end

always_comb
  begin : proc_assign_gpioA
    gpio_intrpt_pendingA = 1'b0;
    for(int idx = 0; idx<GpioCount; idx++)
    begin
      gpio_intrpt_pendingA = gpio_intrpt_pendingA|reg2hwA[idx].intrpt;
    end
  end

always_comb
  begin : proc_assign_gpioB
    gpio_intrpt_pendingB = 1'b0;
    for(int idx = 0; idx<GpioCount; idx++)
    begin
      gpio_intrpt_pendingB = gpio_intrpt_pendingB|reg2hwB[idx].intrpt;
    end
  end

always_comb
  begin : proc_assign_gpioC
    gpio_intrpt_pendingC = 1'b0;
    for(int idx = 0; idx<GpioCount; idx++)
    begin
      gpio_intrpt_pendingC = gpio_intrpt_pendingC|reg2hwC[idx].intrpt;
    end
  end
assign interrupt_oA = gpio_intrpt_pendingA;
assign interrupt_oB = gpio_intrpt_pendingB;
assign interrupt_oC = gpio_intrpt_pendingC;

majorityVoter #(.WIDTH( ((((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+1) )) is_outputVoter (
    .inA(is_outputA),
    .inB(is_outputB),
    .inC(is_outputC),
    .out(is_output),
    .tmrErr(is_outputTmrError)
  );

majorityVoter #(.WIDTH( ($size(reg2hw))  *  ((((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+1) )) reg2hwVoter (
    .inA(reg2hwA),
    .inB(reg2hwB),
    .inC(reg2hwC),
    .out(reg2hw),
    .tmrErr(reg2hwTmrError)
  );
assign tmrError = is_outputTmrError|reg2hwTmrError;

majorityVoter #(.WIDTH( ((((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+1) )) serial_qVoterA (
    .inA(serial_qA),
    .inB(serial_qB),
    .inC(serial_qC),
    .out(serial_qVotedA),
    .tmrErr(serial_qTmrErrorA)
  );
assign tmrErrorA = i_reg_filetmrErrorA|i_synctmrErrorA|serial_qTmrErrorA;

majorityVoter #(.WIDTH( ((((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+1) )) serial_qVoterB (
    .inA(serial_qA),
    .inB(serial_qB),
    .inC(serial_qC),
    .out(serial_qVotedB),
    .tmrErr(serial_qTmrErrorB)
  );
assign tmrErrorB = i_reg_filetmrErrorB|i_synctmrErrorB|serial_qTmrErrorB;

majorityVoter #(.WIDTH( ((((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+1) )) serial_qVoterC (
    .inA(serial_qA),
    .inB(serial_qB),
    .inC(serial_qC),
    .out(serial_qVotedC),
    .tmrErr(serial_qTmrErrorC)
  );
assign tmrErrorC = i_reg_filetmrErrorC|i_synctmrErrorC|serial_qTmrErrorC;

fanout clk_iFanout (
    .in(clk_i),
    .outA(clk_iA),
    .outB(clk_iB),
    .outC(clk_iC)
  );

fanout #(.WIDTH( ((((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+1) )) gpio_iFanout (
    .in(gpio_i),
    .outA(gpio_iA),
    .outB(gpio_iB),
    .outC(gpio_iC)
  );

fanout rst_niFanout (
    .in(rst_ni),
    .outA(rst_niA),
    .outB(rst_niB),
    .outC(rst_niC)
  );
endmodule



// /scratch/michaero/git/tmrg/tmrg/../common/voter.v
module majorityVoter #(
  parameter WIDTH = 1
)(
  input wire  [WIDTH-1:0] inA,
  input wire  [WIDTH-1:0] inB,
  input wire  [WIDTH-1:0] inC,
  output wire [WIDTH-1:0] out,
  output reg              tmrErr
);
  assign out = (inA&inB) | (inA&inC) | (inB&inC);
  always @(inA or inB or inC) begin
    if (inA!=inB || inA!=inC || inB!=inC)
      tmrErr = 1;
    else
      tmrErr = 0;
  end
endmodule


// /scratch/michaero/git/tmrg/tmrg/../common/fanout.v
module fanout #(
  parameter WIDTH = 1
)(
  input wire  [WIDTH-1:0] in,
  output wire [WIDTH-1:0] outA,
  output wire [WIDTH-1:0] outB,
  output wire [WIDTH-1:0] outC
);
  assign outA = in;
  assign outB = in;
  assign outC = in;
endmodule
