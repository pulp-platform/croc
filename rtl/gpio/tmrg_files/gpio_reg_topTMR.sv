/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : tmrg_files/gpio_reg_topTMR.sv                                                          *
 *                                                                                                  *
 * user    : michaero                                                                               *
 * host    : camellia.ee.ethz.ch                                                                    *
 * date    : 22/08/2025 20:09:47                                                                    *
 *                                                                                                  *
 * workdir : /scratch/michaero/git/croc/rtl/gpio                                                    *
 * cmd     : /home/michaero/.local/bin/tmrg tmrg_src/sync.sv gpio_reg_top.sv gpio.sv --top-module=gpio *
 *           --tmr-dir=tmrg_files                                                                   *
 * tmrg rev: 7e2935137fada05d9957c7acbad06f9f466f5f7e                                               *
 *                                                                                                  *
 * src file: gpio_reg_top.sv                                                                        *
 *           Git SHA           : c45c846f2648ab3f2bc44d19725c4e0e745d558f (MM gpio_reg_top.sv)      *
 *           Modification time : 2025-08-22 20:09:45.569042                                         *
 *           File Size         : 10133                                                              *
 *           MD5 hash          : db1e183ae83b1fd85a5efaa68bcc08e8                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module gpio_reg_topTMR import gpio_reg_pkg::*; #(
  parameter obi_pkg::obi_cfg_t ObiCfg = obi_pkg::ObiDefaultConfig,
  parameter type obi_req_t         = logic,
  parameter type obi_rsp_t         = logic,
  parameter int unsigned GpioCount = 16
) (
  input logic clk_i,
  input logic rst_ni,
  input obi_req_t obi_req_iA,
  input obi_req_t obi_req_iB,
  input obi_req_t obi_req_iC,
  output obi_rsp_t obi_rsp_oA,
  output obi_rsp_t obi_rsp_oB,
  output obi_rsp_t obi_rsp_oC,
  output gpio_reg2hw_t [GpioCount - 1:0] reg2hwA,
  output gpio_reg2hw_t [GpioCount - 1:0] reg2hwB,
  output gpio_reg2hw_t [GpioCount - 1:0] reg2hwC,
  input gpio_hw2reg_t [GpioCount - 1:0] hw2regA,
  input gpio_hw2reg_t [GpioCount - 1:0] hw2regB,
  input gpio_hw2reg_t [GpioCount - 1:0] hw2regC,
  output tmrErrorA,
  output tmrErrorB,
  output tmrErrorC
);
typedef struct packed { 
  logic [GpioCount - 1:0] dir;
  logic [GpioCount - 1:0] en;
  logic [GpioCount - 1:0] in;
  logic [GpioCount - 1:0] out;
  logic [GpioCount - 1:0] toggle;
  logic [GpioCount - 1:0] intrpt_en;
  logic [GpioCount - 1:0] intrpt;
  logic [GpioCount - 1:0] intrpt_edge;
} gpio_reg_fields_t;
wire rst_niC;
wire rst_niB;
wire rst_niA;
wire clk_iC;
wire clk_iB;
wire clk_iA;
wor we_qTmrErrorC;
wor w_err_qTmrErrorC;
wor valid_qTmrErrorC;
wor req_qTmrErrorC;
wor reg_qTmrErrorC;
wor read_addr_qTmrErrorC;
wor id_qTmrErrorC;
wor we_qTmrErrorB;
wor w_err_qTmrErrorB;
wor valid_qTmrErrorB;
wor req_qTmrErrorB;
wor reg_qTmrErrorB;
wor read_addr_qTmrErrorB;
wor id_qTmrErrorB;
wor we_qTmrErrorA;
wor w_err_qTmrErrorA;
wor valid_qTmrErrorA;
wor req_qTmrErrorA;
wor reg_qTmrErrorA;
wor read_addr_qTmrErrorA;
wor id_qTmrErrorA;
logic valid_dA;
logic valid_dB;
logic valid_dC;
logic valid_qA;
logic valid_qB;
logic valid_qC;
logic valid_qVotedA;
logic valid_qVotedB;
logic valid_qVotedC;
logic we_dA;
logic we_dB;
logic we_dC;
logic we_qA;
logic we_qB;
logic we_qC;
logic we_qVotedA;
logic we_qVotedB;
logic we_qVotedC;
logic req_dA;
logic req_dB;
logic req_dC;
logic req_qA;
logic req_qB;
logic req_qC;
logic req_qVotedA;
logic req_qVotedB;
logic req_qVotedC;
logic [AddressWidth - 1:0] write_addrA;
logic [AddressWidth - 1:0] write_addrB;
logic [AddressWidth - 1:0] write_addrC;
logic [AddressWidth - 1:0] read_addr_dA;
logic [AddressWidth - 1:0] read_addr_dB;
logic [AddressWidth - 1:0] read_addr_dC;
logic [AddressWidth - 1:0] read_addr_qA;
logic [AddressWidth - 1:0] read_addr_qB;
logic [AddressWidth - 1:0] read_addr_qC;
logic [AddressWidth - 1:0] read_addr_qVotedA;
logic [AddressWidth - 1:0] read_addr_qVotedB;
logic [AddressWidth - 1:0] read_addr_qVotedC;
logic [ObiCfg.IdWidth - 1:0] id_dA;
logic [ObiCfg.IdWidth - 1:0] id_dB;
logic [ObiCfg.IdWidth - 1:0] id_dC;
logic [ObiCfg.IdWidth - 1:0] id_qA;
logic [ObiCfg.IdWidth - 1:0] id_qB;
logic [ObiCfg.IdWidth - 1:0] id_qC;
logic [ObiCfg.IdWidth - 1:0] id_qVotedA;
logic [ObiCfg.IdWidth - 1:0] id_qVotedB;
logic [ObiCfg.IdWidth - 1:0] id_qVotedC;
logic obi_errA;
logic obi_errB;
logic obi_errC;
logic w_err_dA;
logic w_err_dB;
logic w_err_dC;
logic w_err_qA;
logic w_err_qB;
logic w_err_qC;
logic w_err_qVotedA;
logic w_err_qVotedB;
logic w_err_qVotedC;
logic [ObiCfg.DataWidth - 1:0] obi_rdataA;
logic [ObiCfg.DataWidth - 1:0] obi_rdataB;
logic [ObiCfg.DataWidth - 1:0] obi_rdataC;
logic [ObiCfg.DataWidth - 1:0] obi_wdataA;
logic [ObiCfg.DataWidth - 1:0] obi_wdataB;
logic [ObiCfg.DataWidth - 1:0] obi_wdataC;
logic obi_read_requestA;
logic obi_read_requestB;
logic obi_read_requestC;
logic obi_write_requestA;
logic obi_write_requestB;
logic obi_write_requestC;

always_comb
  begin
    obi_rsp_oA = '0;
    obi_rsp_oA.r.rdata = obi_rdataA;
    obi_rsp_oA.r.rid = id_qVotedA;
    obi_rsp_oA.r.err = obi_errA;
    obi_rsp_oA.gnt = obi_req_iA.req;
    obi_rsp_oA.rvalid = valid_qVotedA;
  end

always_comb
  begin
    obi_rsp_oB = '0;
    obi_rsp_oB.r.rdata = obi_rdataB;
    obi_rsp_oB.r.rid = id_qVotedB;
    obi_rsp_oB.r.err = obi_errB;
    obi_rsp_oB.gnt = obi_req_iB.req;
    obi_rsp_oB.rvalid = valid_qVotedB;
  end

always_comb
  begin
    obi_rsp_oC = '0;
    obi_rsp_oC.r.rdata = obi_rdataC;
    obi_rsp_oC.r.rid = id_qVotedC;
    obi_rsp_oC.r.err = obi_errC;
    obi_rsp_oC.gnt = obi_req_iC.req;
    obi_rsp_oC.rvalid = valid_qVotedC;
  end
assign obi_wdataA = obi_req_iA.a.wdata;
assign obi_wdataB = obi_req_iB.a.wdata;
assign obi_wdataC = obi_req_iC.a.wdata;
assign obi_read_requestA = req_qVotedA&~we_qVotedA;
assign obi_read_requestB = req_qVotedB&~we_qVotedB;
assign obi_read_requestC = req_qVotedC&~we_qVotedC;
assign obi_write_requestA = obi_req_iA.req&obi_req_iA.a.we;
assign obi_write_requestB = obi_req_iB.req&obi_req_iB.a.we;
assign obi_write_requestC = obi_req_iC.req&obi_req_iC.a.we;
assign id_dA = obi_req_iA.a.aid;
assign id_dB = obi_req_iB.a.aid;
assign id_dC = obi_req_iC.a.aid;
assign valid_dA = obi_req_iA.req;
assign valid_dB = obi_req_iB.req;
assign valid_dC = obi_req_iC.req;
assign write_addrA = obi_req_iA.a.addr[AddressWidth - 1:2];
assign write_addrB = obi_req_iB.a.addr[AddressWidth - 1:2];
assign write_addrC = obi_req_iC.a.addr[AddressWidth - 1:2];
assign read_addr_dA = obi_req_iA.a.addr[AddressWidth - 1:2];
assign read_addr_dB = obi_req_iB.a.addr[AddressWidth - 1:2];
assign read_addr_dC = obi_req_iC.a.addr[AddressWidth - 1:2];
assign we_dA = obi_req_iA.a.we;
assign we_dB = obi_req_iB.a.we;
assign we_dC = obi_req_iC.a.we;
assign req_dA = obi_req_iA.req;
assign req_dB = obi_req_iB.req;
assign req_dC = obi_req_iC.req;

always_ff @( posedge clk_iA or negedge rst_niA )
  begin
    if (!rst_niA)
      begin
        id_qA <= '0;
        valid_qA <= '0;
        read_addr_qA <= '0;
        req_qA <= '0;
        we_qA <= '0;
        w_err_qA <= '0;
      end
    else
      begin
        id_qA <= id_dA;
        valid_qA <= valid_dA;
        read_addr_qA <= read_addr_dA;
        req_qA <= req_dA;
        we_qA <= we_dA;
        w_err_qA <= w_err_dA;
      end
  end

always_ff @( posedge clk_iB or negedge rst_niB )
  begin
    if (!rst_niB)
      begin
        id_qB <= '0;
        valid_qB <= '0;
        read_addr_qB <= '0;
        req_qB <= '0;
        we_qB <= '0;
        w_err_qB <= '0;
      end
    else
      begin
        id_qB <= id_dB;
        valid_qB <= valid_dB;
        read_addr_qB <= read_addr_dB;
        req_qB <= req_dB;
        we_qB <= we_dB;
        w_err_qB <= w_err_dB;
      end
  end

always_ff @( posedge clk_iC or negedge rst_niC )
  begin
    if (!rst_niC)
      begin
        id_qC <= '0;
        valid_qC <= '0;
        read_addr_qC <= '0;
        req_qC <= '0;
        we_qC <= '0;
        w_err_qC <= '0;
      end
    else
      begin
        id_qC <= id_dC;
        valid_qC <= valid_dC;
        read_addr_qC <= read_addr_dC;
        req_qC <= req_dC;
        we_qC <= we_dC;
        w_err_qC <= w_err_dC;
      end
  end
gpio_reg_fields_t reg_dA;
gpio_reg_fields_t reg_dB;
gpio_reg_fields_t reg_dC;
gpio_reg_fields_t reg_qA;
gpio_reg_fields_t reg_qB;
gpio_reg_fields_t reg_qC;
gpio_reg_fields_t reg_qVotedA;
gpio_reg_fields_t reg_qVotedB;
gpio_reg_fields_t reg_qVotedC;

always_ff @( posedge clk_iA or negedge rst_niA )
  begin
    if (!rst_niA)
      begin
        reg_qA <= '0;
      end
    else
      begin
        reg_qA <= reg_dA;
      end
  end

always_ff @( posedge clk_iB or negedge rst_niB )
  begin
    if (!rst_niB)
      begin
        reg_qB <= '0;
      end
    else
      begin
        reg_qB <= reg_dB;
      end
  end

always_ff @( posedge clk_iC or negedge rst_niC )
  begin
    if (!rst_niC)
      begin
        reg_qC <= '0;
      end
    else
      begin
        reg_qC <= reg_dC;
      end
  end
gpio_reg_fields_t new_regA;
gpio_reg_fields_t new_regB;
gpio_reg_fields_t new_regC;
logic [GpioCount - 1:0] new_intrptA;
logic [GpioCount - 1:0] new_intrptB;
logic [GpioCount - 1:0] new_intrptC;
logic [GpioCount - 1:0] toggle_outA;
logic [GpioCount - 1:0] toggle_outB;
logic [GpioCount - 1:0] toggle_outC;
logic [ObiCfg.DataWidth - 1:0] bit_maskA;
logic [ObiCfg.DataWidth - 1:0] bit_maskB;
logic [ObiCfg.DataWidth - 1:0] bit_maskC;
for(genvar i = 0; unsigned' (i) <ObiCfg.DataWidth / 8; i++)
  begin : gen_write_mask
    assign bit_maskA[8 * i+:8] = {8{obi_req_iA.a.be[i]}};
    assign bit_maskB[8 * i+:8] = {8{obi_req_iB.a.be[i]}};
    assign bit_maskC[8 * i+:8] = {8{obi_req_iC.a.be[i]}};
  end

always_comb
  begin
    for(int unsigned idx = 0; idx<GpioCount; idx++)
    begin
      reg2hwA[idx].dir = reg_qVotedA.dir[idx];
      reg2hwA[idx].en = reg_qVotedA.en[idx];
      reg2hwA[idx].out = reg_qVotedA.out[idx];
      reg2hwA[idx].toggle = toggle_outA[idx];
      reg2hwA[idx].intrpt_en = reg_qVotedA.intrpt_en[idx];
      reg2hwA[idx].intrpt = reg_qVotedA.intrpt[idx];
      reg2hwA[idx].intrpt_edge = reg_qVotedA.intrpt_edge[idx];
    end
  end

always_comb
  begin
    for(int unsigned idx = 0; idx<GpioCount; idx++)
    begin
      reg2hwB[idx].dir = reg_qVotedB.dir[idx];
      reg2hwB[idx].en = reg_qVotedB.en[idx];
      reg2hwB[idx].out = reg_qVotedB.out[idx];
      reg2hwB[idx].toggle = toggle_outB[idx];
      reg2hwB[idx].intrpt_en = reg_qVotedB.intrpt_en[idx];
      reg2hwB[idx].intrpt = reg_qVotedB.intrpt[idx];
      reg2hwB[idx].intrpt_edge = reg_qVotedB.intrpt_edge[idx];
    end
  end

always_comb
  begin
    for(int unsigned idx = 0; idx<GpioCount; idx++)
    begin
      reg2hwC[idx].dir = reg_qVotedC.dir[idx];
      reg2hwC[idx].en = reg_qVotedC.en[idx];
      reg2hwC[idx].out = reg_qVotedC.out[idx];
      reg2hwC[idx].toggle = toggle_outC[idx];
      reg2hwC[idx].intrpt_en = reg_qVotedC.intrpt_en[idx];
      reg2hwC[idx].intrpt = reg_qVotedC.intrpt[idx];
      reg2hwC[idx].intrpt_edge = reg_qVotedC.intrpt_edge[idx];
    end
  end

always_comb
  begin
    obi_rdataA = 32'h0;
    obi_errA = w_err_qVotedA;
    w_err_dA = 1'b0;
    new_regA = reg_qVotedA;
    new_intrptA = '0;
    toggle_outA = '0;
    for(int unsigned idx = 0; idx<GpioCount; idx++)
    begin
      new_regA.in[idx] = hw2regA[idx].sync_in;
      new_regA.toggle[idx] = '0;
      new_regA.out[idx] = hw2regA[idx].out_valid ? hw2regA[idx].out : reg_qVotedA.out[idx];
      new_regA.intrpt[idx] = hw2regA[idx].intrpt_valid ? hw2regA[idx].intrpt : reg_qVotedA.intrpt[idx];
      new_intrptA[idx] = hw2regA[idx].intrpt_valid&hw2regA[idx].intrpt;
    end
    reg_dA = new_regA;
    if (obi_write_requestA)
      begin
        obi_errA = 1'b0;
        case ({write_addrA, 2'b00})
          GPIO_DIR_OFFSET : 
            begin
              reg_dA.dir =  (~ bit_maskA & new_regA.dir ) | (bit_maskA&obi_wdataA[GpioCount - 1:0]) ;
            end
          GPIO_EN_OFFSET : 
            begin
              reg_dA.en =  (~ bit_maskA & new_regA.en ) | (bit_maskA&obi_wdataA[GpioCount - 1:0]) ;
            end
          GPIO_OUT_OFFSET : 
            begin
              reg_dA.out =  (~ bit_maskA & new_regA.out ) | (bit_maskA&obi_wdataA[GpioCount - 1:0]) ;
            end
          GPIO_TOGGLE_OFFSET : 
            begin
              toggle_outA = bit_maskA&obi_wdataA[GpioCount - 1:0];
            end
          GPIO_INTRPT_EN_OFFSET : 
            begin
              reg_dA.intrpt_en =  (~ bit_maskA & new_regA.intrpt_en ) | (bit_maskA&obi_wdataA[GpioCount - 1:0]) ;
            end
          GPIO_INTRPT_EDGE_OFFSET : 
            begin
              reg_dA.intrpt_edge =  (~ bit_maskA & new_regA.intrpt_edge ) | (bit_maskA&obi_wdataA[GpioCount - 1:0]) ;
            end
          default : 
            begin
              w_err_dA = 1'b1;
            end
        endcase
      end

    if (obi_read_requestA)
      begin
        obi_errA = 1'b0;
        case ({read_addr_qVotedA, 2'b00})
          GPIO_DIR_OFFSET : 
            begin
              obi_rdataA = reg_qVotedA.dir;
            end
          GPIO_EN_OFFSET : 
            begin
              obi_rdataA = reg_qVotedA.en;
            end
          GPIO_IN_OFFSET : 
            begin
              obi_rdataA = reg_qVotedA.in;
            end
          GPIO_OUT_OFFSET : 
            begin
              obi_rdataA = reg_qVotedA.out;
            end
          GPIO_TOGGLE_OFFSET : 
            begin
              obi_rdataA = '0;
            end
          GPIO_INTRPT_EN_OFFSET : 
            begin
              obi_rdataA = reg_qVotedA.intrpt_en;
            end
          GPIO_INTRPT_STATUS_OFFSET : 
            begin
              obi_rdataA = reg_qVotedA.intrpt;
              reg_dA.intrpt = new_intrptA;
            end
          GPIO_INTRPT_EDGE_OFFSET : 
            begin
              obi_rdataA = reg_qVotedA.intrpt_edge;
            end
          default : 
            begin
              obi_rdataA = 32'hBADCAB1E;
              obi_errA = 1'b1;
            end
        endcase
      end

  end

always_comb
  begin
    obi_rdataB = 32'h0;
    obi_errB = w_err_qVotedB;
    w_err_dB = 1'b0;
    new_regB = reg_qVotedB;
    new_intrptB = '0;
    toggle_outB = '0;
    for(int unsigned idx = 0; idx<GpioCount; idx++)
    begin
      new_regB.in[idx] = hw2regB[idx].sync_in;
      new_regB.toggle[idx] = '0;
      new_regB.out[idx] = hw2regB[idx].out_valid ? hw2regB[idx].out : reg_qVotedB.out[idx];
      new_regB.intrpt[idx] = hw2regB[idx].intrpt_valid ? hw2regB[idx].intrpt : reg_qVotedB.intrpt[idx];
      new_intrptB[idx] = hw2regB[idx].intrpt_valid&hw2regB[idx].intrpt;
    end
    reg_dB = new_regB;
    if (obi_write_requestB)
      begin
        obi_errB = 1'b0;
        case ({write_addrB, 2'b00})
          GPIO_DIR_OFFSET : 
            begin
              reg_dB.dir =  (~ bit_maskB & new_regB.dir ) | (bit_maskB&obi_wdataB[GpioCount - 1:0]) ;
            end
          GPIO_EN_OFFSET : 
            begin
              reg_dB.en =  (~ bit_maskB & new_regB.en ) | (bit_maskB&obi_wdataB[GpioCount - 1:0]) ;
            end
          GPIO_OUT_OFFSET : 
            begin
              reg_dB.out =  (~ bit_maskB & new_regB.out ) | (bit_maskB&obi_wdataB[GpioCount - 1:0]) ;
            end
          GPIO_TOGGLE_OFFSET : 
            begin
              toggle_outB = bit_maskB&obi_wdataB[GpioCount - 1:0];
            end
          GPIO_INTRPT_EN_OFFSET : 
            begin
              reg_dB.intrpt_en =  (~ bit_maskB & new_regB.intrpt_en ) | (bit_maskB&obi_wdataB[GpioCount - 1:0]) ;
            end
          GPIO_INTRPT_EDGE_OFFSET : 
            begin
              reg_dB.intrpt_edge =  (~ bit_maskB & new_regB.intrpt_edge ) | (bit_maskB&obi_wdataB[GpioCount - 1:0]) ;
            end
          default : 
            begin
              w_err_dB = 1'b1;
            end
        endcase
      end

    if (obi_read_requestB)
      begin
        obi_errB = 1'b0;
        case ({read_addr_qVotedB, 2'b00})
          GPIO_DIR_OFFSET : 
            begin
              obi_rdataB = reg_qVotedB.dir;
            end
          GPIO_EN_OFFSET : 
            begin
              obi_rdataB = reg_qVotedB.en;
            end
          GPIO_IN_OFFSET : 
            begin
              obi_rdataB = reg_qVotedB.in;
            end
          GPIO_OUT_OFFSET : 
            begin
              obi_rdataB = reg_qVotedB.out;
            end
          GPIO_TOGGLE_OFFSET : 
            begin
              obi_rdataB = '0;
            end
          GPIO_INTRPT_EN_OFFSET : 
            begin
              obi_rdataB = reg_qVotedB.intrpt_en;
            end
          GPIO_INTRPT_STATUS_OFFSET : 
            begin
              obi_rdataB = reg_qVotedB.intrpt;
              reg_dB.intrpt = new_intrptB;
            end
          GPIO_INTRPT_EDGE_OFFSET : 
            begin
              obi_rdataB = reg_qVotedB.intrpt_edge;
            end
          default : 
            begin
              obi_rdataB = 32'hBADCAB1E;
              obi_errB = 1'b1;
            end
        endcase
      end

  end

always_comb
  begin
    obi_rdataC = 32'h0;
    obi_errC = w_err_qVotedC;
    w_err_dC = 1'b0;
    new_regC = reg_qVotedC;
    new_intrptC = '0;
    toggle_outC = '0;
    for(int unsigned idx = 0; idx<GpioCount; idx++)
    begin
      new_regC.in[idx] = hw2regC[idx].sync_in;
      new_regC.toggle[idx] = '0;
      new_regC.out[idx] = hw2regC[idx].out_valid ? hw2regC[idx].out : reg_qVotedC.out[idx];
      new_regC.intrpt[idx] = hw2regC[idx].intrpt_valid ? hw2regC[idx].intrpt : reg_qVotedC.intrpt[idx];
      new_intrptC[idx] = hw2regC[idx].intrpt_valid&hw2regC[idx].intrpt;
    end
    reg_dC = new_regC;
    if (obi_write_requestC)
      begin
        obi_errC = 1'b0;
        case ({write_addrC, 2'b00})
          GPIO_DIR_OFFSET : 
            begin
              reg_dC.dir =  (~ bit_maskC & new_regC.dir ) | (bit_maskC&obi_wdataC[GpioCount - 1:0]) ;
            end
          GPIO_EN_OFFSET : 
            begin
              reg_dC.en =  (~ bit_maskC & new_regC.en ) | (bit_maskC&obi_wdataC[GpioCount - 1:0]) ;
            end
          GPIO_OUT_OFFSET : 
            begin
              reg_dC.out =  (~ bit_maskC & new_regC.out ) | (bit_maskC&obi_wdataC[GpioCount - 1:0]) ;
            end
          GPIO_TOGGLE_OFFSET : 
            begin
              toggle_outC = bit_maskC&obi_wdataC[GpioCount - 1:0];
            end
          GPIO_INTRPT_EN_OFFSET : 
            begin
              reg_dC.intrpt_en =  (~ bit_maskC & new_regC.intrpt_en ) | (bit_maskC&obi_wdataC[GpioCount - 1:0]) ;
            end
          GPIO_INTRPT_EDGE_OFFSET : 
            begin
              reg_dC.intrpt_edge =  (~ bit_maskC & new_regC.intrpt_edge ) | (bit_maskC&obi_wdataC[GpioCount - 1:0]) ;
            end
          default : 
            begin
              w_err_dC = 1'b1;
            end
        endcase
      end

    if (obi_read_requestC)
      begin
        obi_errC = 1'b0;
        case ({read_addr_qVotedC, 2'b00})
          GPIO_DIR_OFFSET : 
            begin
              obi_rdataC = reg_qVotedC.dir;
            end
          GPIO_EN_OFFSET : 
            begin
              obi_rdataC = reg_qVotedC.en;
            end
          GPIO_IN_OFFSET : 
            begin
              obi_rdataC = reg_qVotedC.in;
            end
          GPIO_OUT_OFFSET : 
            begin
              obi_rdataC = reg_qVotedC.out;
            end
          GPIO_TOGGLE_OFFSET : 
            begin
              obi_rdataC = '0;
            end
          GPIO_INTRPT_EN_OFFSET : 
            begin
              obi_rdataC = reg_qVotedC.intrpt_en;
            end
          GPIO_INTRPT_STATUS_OFFSET : 
            begin
              obi_rdataC = reg_qVotedC.intrpt;
              reg_dC.intrpt = new_intrptC;
            end
          GPIO_INTRPT_EDGE_OFFSET : 
            begin
              obi_rdataC = reg_qVotedC.intrpt_edge;
            end
          default : 
            begin
              obi_rdataC = 32'hBADCAB1E;
              obi_errC = 1'b1;
            end
        endcase
      end

  end

majorityVoter #(.WIDTH( ((((ObiCfg.IdWidth-1)>0) ? (ObiCfg.IdWidth-1) : - ( ObiCfg.IdWidth-1 ) )+1) )) id_qVoterA (
    .inA(id_qA),
    .inB(id_qB),
    .inC(id_qC),
    .out(id_qVotedA),
    .tmrErr(id_qTmrErrorA)
  );

majorityVoter #(.WIDTH( ((((AddressWidth-1)>0) ? (AddressWidth-1) : - ( AddressWidth-1 ) )+1) )) read_addr_qVoterA (
    .inA(read_addr_qA),
    .inB(read_addr_qB),
    .inC(read_addr_qC),
    .out(read_addr_qVotedA),
    .tmrErr(read_addr_qTmrErrorA)
  );

majorityVoter #(.WIDTH( ((((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+8) )) reg_qVoterA (
    .inA(reg_qA),
    .inB(reg_qB),
    .inC(reg_qC),
    .out(reg_qVotedA),
    .tmrErr(reg_qTmrErrorA)
  );

majorityVoter req_qVoterA (
    .inA(req_qA),
    .inB(req_qB),
    .inC(req_qC),
    .out(req_qVotedA),
    .tmrErr(req_qTmrErrorA)
  );

majorityVoter valid_qVoterA (
    .inA(valid_qA),
    .inB(valid_qB),
    .inC(valid_qC),
    .out(valid_qVotedA),
    .tmrErr(valid_qTmrErrorA)
  );

majorityVoter w_err_qVoterA (
    .inA(w_err_qA),
    .inB(w_err_qB),
    .inC(w_err_qC),
    .out(w_err_qVotedA),
    .tmrErr(w_err_qTmrErrorA)
  );

majorityVoter we_qVoterA (
    .inA(we_qA),
    .inB(we_qB),
    .inC(we_qC),
    .out(we_qVotedA),
    .tmrErr(we_qTmrErrorA)
  );
assign tmrErrorA = id_qTmrErrorA|read_addr_qTmrErrorA|reg_qTmrErrorA|req_qTmrErrorA|valid_qTmrErrorA|w_err_qTmrErrorA|we_qTmrErrorA;

majorityVoter #(.WIDTH( ((((ObiCfg.IdWidth-1)>0) ? (ObiCfg.IdWidth-1) : - ( ObiCfg.IdWidth-1 ) )+1) )) id_qVoterB (
    .inA(id_qA),
    .inB(id_qB),
    .inC(id_qC),
    .out(id_qVotedB),
    .tmrErr(id_qTmrErrorB)
  );

majorityVoter #(.WIDTH( ((((AddressWidth-1)>0) ? (AddressWidth-1) : - ( AddressWidth-1 ) )+1) )) read_addr_qVoterB (
    .inA(read_addr_qA),
    .inB(read_addr_qB),
    .inC(read_addr_qC),
    .out(read_addr_qVotedB),
    .tmrErr(read_addr_qTmrErrorB)
  );

majorityVoter #(.WIDTH( ((((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+8) )) reg_qVoterB (
    .inA(reg_qA),
    .inB(reg_qB),
    .inC(reg_qC),
    .out(reg_qVotedB),
    .tmrErr(reg_qTmrErrorB)
  );

majorityVoter req_qVoterB (
    .inA(req_qA),
    .inB(req_qB),
    .inC(req_qC),
    .out(req_qVotedB),
    .tmrErr(req_qTmrErrorB)
  );

majorityVoter valid_qVoterB (
    .inA(valid_qA),
    .inB(valid_qB),
    .inC(valid_qC),
    .out(valid_qVotedB),
    .tmrErr(valid_qTmrErrorB)
  );

majorityVoter w_err_qVoterB (
    .inA(w_err_qA),
    .inB(w_err_qB),
    .inC(w_err_qC),
    .out(w_err_qVotedB),
    .tmrErr(w_err_qTmrErrorB)
  );

majorityVoter we_qVoterB (
    .inA(we_qA),
    .inB(we_qB),
    .inC(we_qC),
    .out(we_qVotedB),
    .tmrErr(we_qTmrErrorB)
  );
assign tmrErrorB = id_qTmrErrorB|read_addr_qTmrErrorB|reg_qTmrErrorB|req_qTmrErrorB|valid_qTmrErrorB|w_err_qTmrErrorB|we_qTmrErrorB;

majorityVoter #(.WIDTH( ((((ObiCfg.IdWidth-1)>0) ? (ObiCfg.IdWidth-1) : - ( ObiCfg.IdWidth-1 ) )+1) )) id_qVoterC (
    .inA(id_qA),
    .inB(id_qB),
    .inC(id_qC),
    .out(id_qVotedC),
    .tmrErr(id_qTmrErrorC)
  );

majorityVoter #(.WIDTH( ((((AddressWidth-1)>0) ? (AddressWidth-1) : - ( AddressWidth-1 ) )+1) )) read_addr_qVoterC (
    .inA(read_addr_qA),
    .inB(read_addr_qB),
    .inC(read_addr_qC),
    .out(read_addr_qVotedC),
    .tmrErr(read_addr_qTmrErrorC)
  );

majorityVoter #(.WIDTH( ((((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+(((GpioCount-1)>0) ? (GpioCount-1) : - ( GpioCount-1 ) )+8) )) reg_qVoterC (
    .inA(reg_qA),
    .inB(reg_qB),
    .inC(reg_qC),
    .out(reg_qVotedC),
    .tmrErr(reg_qTmrErrorC)
  );

majorityVoter req_qVoterC (
    .inA(req_qA),
    .inB(req_qB),
    .inC(req_qC),
    .out(req_qVotedC),
    .tmrErr(req_qTmrErrorC)
  );

majorityVoter valid_qVoterC (
    .inA(valid_qA),
    .inB(valid_qB),
    .inC(valid_qC),
    .out(valid_qVotedC),
    .tmrErr(valid_qTmrErrorC)
  );

majorityVoter w_err_qVoterC (
    .inA(w_err_qA),
    .inB(w_err_qB),
    .inC(w_err_qC),
    .out(w_err_qVotedC),
    .tmrErr(w_err_qTmrErrorC)
  );

majorityVoter we_qVoterC (
    .inA(we_qA),
    .inB(we_qB),
    .inC(we_qC),
    .out(we_qVotedC),
    .tmrErr(we_qTmrErrorC)
  );
assign tmrErrorC = id_qTmrErrorC|read_addr_qTmrErrorC|reg_qTmrErrorC|req_qTmrErrorC|valid_qTmrErrorC|w_err_qTmrErrorC|we_qTmrErrorC;

fanout clk_iFanout (
    .in(clk_i),
    .outA(clk_iA),
    .outB(clk_iB),
    .outC(clk_iC)
  );

fanout rst_niFanout (
    .in(rst_ni),
    .outA(rst_niA),
    .outB(rst_niB),
    .outC(rst_niC)
  );
endmodule

