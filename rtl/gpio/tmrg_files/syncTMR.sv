/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : tmrg_files/syncTMR.sv                                                                  *
 *                                                                                                  *
 * user    : michaero                                                                               *
 * host    : camellia.ee.ethz.ch                                                                    *
 * date    : 22/08/2025 20:09:46                                                                    *
 *                                                                                                  *
 * workdir : /scratch/michaero/git/croc/rtl/gpio                                                    *
 * cmd     : /home/michaero/.local/bin/tmrg tmrg_src/sync.sv gpio_reg_top.sv gpio.sv --top-module=gpio *
 *           --tmr-dir=tmrg_files                                                                   *
 * tmrg rev: 7e2935137fada05d9957c7acbad06f9f466f5f7e                                               *
 *                                                                                                  *
 * src file: tmrg_src/sync.sv                                                                       *
 *           Git SHA           : c45c846f2648ab3f2bc44d19725c4e0e745d558f (A  tmrg_src/sync.sv)     *
 *           Modification time : 2025-08-22 19:35:29.489957                                         *
 *           File Size         : 1436                                                               *
 *           MD5 hash          : ef827c744d26c270ef532cbb9b1308d3                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module syncTMR #(
  parameter int unsigned STAGES = 2,
  parameter bit ResetValue = 1'b0
) (
  input logic clk_i,
  input logic rst_ni,
  input logic serial_iA,
  input logic serial_iB,
  input logic serial_iC,
  output logic serial_oA,
  output logic serial_oB,
  output logic serial_oC,
  output tmrErrorA,
  output tmrErrorB,
  output tmrErrorC
);
wire rst_niC;
wire rst_niB;
wire rst_niA;
wire clk_iC;
wire clk_iB;
wire clk_iA;
wor reg_qTmrErrorC;
wor reg_qTmrErrorB;
wor reg_qTmrErrorA;
(* dont_touch = "true" *)(* async_reg = "true" *) logic [STAGES - 1:0] reg_qA;
(* dont_touch = "true" *)(* async_reg = "true" *) logic [STAGES - 1:0] reg_qB;
(* dont_touch = "true" *)(* async_reg = "true" *) logic [STAGES - 1:0] reg_qC;
(* dont_touch = "true" *)(* async_reg = "true" *) logic [STAGES - 1:0] reg_qVotedA;
(* dont_touch = "true" *)(* async_reg = "true" *) logic [STAGES - 1:0] reg_qVotedB;
(* dont_touch = "true" *)(* async_reg = "true" *) logic [STAGES - 1:0] reg_qVotedC;

always_ff @( posedge clk_iA or negedge rst_niA )
  begin
    if (!rst_niA)
      begin
        reg_qA <= {STAGES{ResetValue}};
      end
    else
      begin
        reg_qA <= {reg_qVotedA[STAGES - 2:0], serial_iA};
      end
  end

always_ff @( posedge clk_iB or negedge rst_niB )
  begin
    if (!rst_niB)
      begin
        reg_qB <= {STAGES{ResetValue}};
      end
    else
      begin
        reg_qB <= {reg_qVotedB[STAGES - 2:0], serial_iB};
      end
  end

always_ff @( posedge clk_iC or negedge rst_niC )
  begin
    if (!rst_niC)
      begin
        reg_qC <= {STAGES{ResetValue}};
      end
    else
      begin
        reg_qC <= {reg_qVotedC[STAGES - 2:0], serial_iC};
      end
  end
assign serial_oA = reg_qVotedA[STAGES-1];
assign serial_oB = reg_qVotedB[STAGES-1];
assign serial_oC = reg_qVotedC[STAGES-1];

majorityVoter #(.WIDTH( ((((STAGES-1)>0) ? (STAGES-1) : - ( STAGES-1 ) )+1) )) reg_qVoterA (
    .inA(reg_qA),
    .inB(reg_qB),
    .inC(reg_qC),
    .out(reg_qVotedA),
    .tmrErr(reg_qTmrErrorA)
  );
assign tmrErrorA = reg_qTmrErrorA;

majorityVoter #(.WIDTH( ((((STAGES-1)>0) ? (STAGES-1) : - ( STAGES-1 ) )+1) )) reg_qVoterB (
    .inA(reg_qA),
    .inB(reg_qB),
    .inC(reg_qC),
    .out(reg_qVotedB),
    .tmrErr(reg_qTmrErrorB)
  );
assign tmrErrorB = reg_qTmrErrorB;

majorityVoter #(.WIDTH( ((((STAGES-1)>0) ? (STAGES-1) : - ( STAGES-1 ) )+1) )) reg_qVoterC (
    .inA(reg_qA),
    .inB(reg_qB),
    .inC(reg_qC),
    .out(reg_qVotedC),
    .tmrErr(reg_qTmrErrorC)
  );
assign tmrErrorC = reg_qTmrErrorC;

fanout clk_iFanout (
    .in(clk_i),
    .outA(clk_iA),
    .outB(clk_iB),
    .outC(clk_iC)
  );

fanout rst_niFanout (
    .in(rst_ni),
    .outA(rst_niA),
    .outB(rst_niB),
    .outC(rst_niC)
  );
endmodule

